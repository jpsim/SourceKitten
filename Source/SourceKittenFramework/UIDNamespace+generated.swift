extension UID {
    public struct Key {
        public let uid: UID
        /// key.accessibility
        public static let accessibility: Key = "key.accessibility"
        /// key.actionable
        public static let actionable: Key = "key.actionable"
        /// key.actionname
        public static let actionname: Key = "key.actionname"
        /// key.annotated_decl
        public static let annotated_decl: Key = "key.annotated_decl"
        /// key.annotations
        public static let annotations: Key = "key.annotations"
        /// key.associated_usrs
        public static let associated_usrs: Key = "key.associated_usrs"
        /// key.attribute
        public static let attribute: Key = "key.attribute"
        /// key.attributes
        public static let attributes: Key = "key.attributes"
        /// key.bodylength
        public static let bodylength: Key = "key.bodylength"
        /// key.bodyoffset
        public static let bodyoffset: Key = "key.bodyoffset"
        /// key.codecomplete.addinitstotoplevel
        public static let codecompleteAddinitstotoplevel: Key = "key.codecomplete.addinitstotoplevel"
        /// key.codecomplete.addinneroperators
        public static let codecompleteAddinneroperators: Key = "key.codecomplete.addinneroperators"
        /// key.codecomplete.addinnerresults
        public static let codecompleteAddinnerresults: Key = "key.codecomplete.addinnerresults"
        /// key.codecomplete.filterrules
        public static let codecompleteFilterrules: Key = "key.codecomplete.filterrules"
        /// key.codecomplete.filtertext
        public static let codecompleteFiltertext: Key = "key.codecomplete.filtertext"
        /// key.codecomplete.fuzzymatching
        public static let codecompleteFuzzymatching: Key = "key.codecomplete.fuzzymatching"
        /// key.codecomplete.group.overloads
        public static let codecompleteGroupOverloads: Key = "key.codecomplete.group.overloads"
        /// key.codecomplete.group.stems
        public static let codecompleteGroupStems: Key = "key.codecomplete.group.stems"
        /// key.codecomplete.hidebyname
        public static let codecompleteHidebyname: Key = "key.codecomplete.hidebyname"
        /// key.codecomplete.hidelowpriority
        public static let codecompleteHidelowpriority: Key = "key.codecomplete.hidelowpriority"
        /// key.codecomplete.hideunderscores
        public static let codecompleteHideunderscores: Key = "key.codecomplete.hideunderscores"
        /// key.codecomplete.includeexactmatch
        public static let codecompleteIncludeexactmatch: Key = "key.codecomplete.includeexactmatch"
        /// key.codecomplete.options
        public static let codecompleteOptions: Key = "key.codecomplete.options"
        /// key.codecomplete.requestlimit
        public static let codecompleteRequestlimit: Key = "key.codecomplete.requestlimit"
        /// key.codecomplete.requeststart
        public static let codecompleteRequeststart: Key = "key.codecomplete.requeststart"
        /// key.codecomplete.showtopnonliteralresults
        public static let codecompleteShowtopnonliteralresults: Key = "key.codecomplete.showtopnonliteralresults"
        /// key.codecomplete.sort.byname
        public static let codecompleteSortByname: Key = "key.codecomplete.sort.byname"
        /// key.codecomplete.sort.contextweight
        public static let codecompleteSortContextweight: Key = "key.codecomplete.sort.contextweight"
        /// key.codecomplete.sort.fuzzyweight
        public static let codecompleteSortFuzzyweight: Key = "key.codecomplete.sort.fuzzyweight"
        /// key.codecomplete.sort.popularitybonus
        public static let codecompleteSortPopularitybonus: Key = "key.codecomplete.sort.popularitybonus"
        /// key.codecomplete.sort.useimportdepth
        public static let codecompleteSortUseimportdepth: Key = "key.codecomplete.sort.useimportdepth"
        /// key.column
        public static let column: Key = "key.column"
        /// key.compilerargs
        public static let compilerargs: Key = "key.compilerargs"
        /// key.conforms
        public static let conforms: Key = "key.conforms"
        /// key.containertypeusr
        public static let containertypeusr: Key = "key.containertypeusr"
        /// key.context
        public static let context: Key = "key.context"
        /// key.default_implementation_of
        public static let default_implementation_of: Key = "key.default_implementation_of"
        /// key.dependencies
        public static let dependencies: Key = "key.dependencies"
        /// key.deprecated
        public static let deprecated: Key = "key.deprecated"
        /// key.description
        public static let description: Key = "key.description"
        /// key.diagnostic_stage
        public static let diagnostic_stage: Key = "key.diagnostic_stage"
        /// key.diagnostics
        public static let diagnostics: Key = "key.diagnostics"
        /// key.doc.brief
        public static let docBrief: Key = "key.doc.brief"
        /// key.doc.full_as_xml
        public static let docFull_As_Xml: Key = "key.doc.full_as_xml"
        /// key.duration
        public static let duration: Key = "key.duration"
        /// key.editor.format.indentwidth
        public static let editorFormatIndentwidth: Key = "key.editor.format.indentwidth"
        /// key.editor.format.options
        public static let editorFormatOptions: Key = "key.editor.format.options"
        /// key.editor.format.tabwidth
        public static let editorFormatTabwidth: Key = "key.editor.format.tabwidth"
        /// key.editor.format.usetabs
        public static let editorFormatUsetabs: Key = "key.editor.format.usetabs"
        /// key.elements
        public static let elements: Key = "key.elements"
        /// key.enablediagnostics
        public static let enablediagnostics: Key = "key.enablediagnostics"
        /// key.enablesubstructure
        public static let enablesubstructure: Key = "key.enablesubstructure"
        /// key.enablesyntaxmap
        public static let enablesyntaxmap: Key = "key.enablesyntaxmap"
        /// key.entities
        public static let entities: Key = "key.entities"
        /// key.extends
        public static let extends: Key = "key.extends"
        /// key.filepath
        public static let filepath: Key = "key.filepath"
        /// key.fixits
        public static let fixits: Key = "key.fixits"
        /// key.fully_annotated_decl
        public static let fully_annotated_decl: Key = "key.fully_annotated_decl"
        /// key.generic_params
        public static let generic_params: Key = "key.generic_params"
        /// key.generic_requirements
        public static let generic_requirements: Key = "key.generic_requirements"
        /// key.groupname
        public static let groupname: Key = "key.groupname"
        /// key.hash
        public static let hash: Key = "key.hash"
        /// key.hide
        public static let hide: Key = "key.hide"
        /// key.inheritedtypes
        public static let inheritedtypes: Key = "key.inheritedtypes"
        /// key.inherits
        public static let inherits: Key = "key.inherits"
        /// key.interested_usr
        public static let interested_usr: Key = "key.interested_usr"
        /// key.introduced
        public static let introduced: Key = "key.introduced"
        /// key.is_deprecated
        public static let is_deprecated: Key = "key.is_deprecated"
        /// key.is_dynamic
        public static let is_dynamic: Key = "key.is_dynamic"
        /// key.is_local
        public static let is_local: Key = "key.is_local"
        /// key.is_optional
        public static let is_optional: Key = "key.is_optional"
        /// key.is_system
        public static let is_system: Key = "key.is_system"
        /// key.is_test_candidate
        public static let is_test_candidate: Key = "key.is_test_candidate"
        /// key.is_unavailable
        public static let is_unavailable: Key = "key.is_unavailable"
        /// key.keyword
        public static let keyword: Key = "key.keyword"
        /// key.kind
        public static let kind: Key = "key.kind"
        /// key.length
        public static let length: Key = "key.length"
        /// key.line
        public static let line: Key = "key.line"
        /// key.message
        public static let message: Key = "key.message"
        /// key.module_interface_name
        public static let module_interface_name: Key = "key.module_interface_name"
        /// key.modulegroups
        public static let modulegroups: Key = "key.modulegroups"
        /// key.moduleimportdepth
        public static let moduleimportdepth: Key = "key.moduleimportdepth"
        /// key.modulename
        public static let modulename: Key = "key.modulename"
        /// key.name
        public static let name: Key = "key.name"
        /// key.namelength
        public static let namelength: Key = "key.namelength"
        /// key.nameoffset
        public static let nameoffset: Key = "key.nameoffset"
        /// key.names
        public static let names: Key = "key.names"
        /// key.nextrequeststart
        public static let nextrequeststart: Key = "key.nextrequeststart"
        /// key.not_recommended
        public static let not_recommended: Key = "key.not_recommended"
        /// key.notification
        public static let notification: Key = "key.notification"
        /// key.num_bytes_to_erase
        public static let num_bytes_to_erase: Key = "key.num_bytes_to_erase"
        /// key.obsoleted
        public static let obsoleted: Key = "key.obsoleted"
        /// key.offset
        public static let offset: Key = "key.offset"
        /// key.original_usr
        public static let original_usr: Key = "key.original_usr"
        /// key.overrides
        public static let overrides: Key = "key.overrides"
        /// key.platform
        public static let platform: Key = "key.platform"
        /// key.popular
        public static let popular: Key = "key.popular"
        /// key.rangecontent
        public static let rangecontent: Key = "key.rangecontent"
        /// key.ranges
        public static let ranges: Key = "key.ranges"
        /// key.receiver_usr
        public static let receiver_usr: Key = "key.receiver_usr"
        /// key.related
        public static let related: Key = "key.related"
        /// key.related_decls
        public static let related_decls: Key = "key.related_decls"
        /// key.removecache
        public static let removecache: Key = "key.removecache"
        /// key.request
        public static let request: Key = "key.request"
        /// key.results
        public static let results: Key = "key.results"
        /// key.runtime_name
        public static let runtime_name: Key = "key.runtime_name"
        /// key.selector_name
        public static let selector_name: Key = "key.selector_name"
        /// key.setter_accessibility
        public static let setter_accessibility: Key = "key.setter_accessibility"
        /// key.severity
        public static let severity: Key = "key.severity"
        /// key.simplified
        public static let simplified: Key = "key.simplified"
        /// key.sourcefile
        public static let sourcefile: Key = "key.sourcefile"
        /// key.sourcetext
        public static let sourcetext: Key = "key.sourcetext"
        /// key.substructure
        public static let substructure: Key = "key.substructure"
        /// key.syntactic_only
        public static let syntactic_only: Key = "key.syntactic_only"
        /// key.syntaxmap
        public static let syntaxmap: Key = "key.syntaxmap"
        /// key.synthesizedextensions
        public static let synthesizedextensions: Key = "key.synthesizedextensions"
        /// key.throwlength
        public static let throwlength: Key = "key.throwlength"
        /// key.throwoffset
        public static let throwoffset: Key = "key.throwoffset"
        /// key.typeinterface
        public static let typeinterface: Key = "key.typeinterface"
        /// key.typename
        public static let typename: Key = "key.typename"
        /// key.typeusr
        public static let typeusr: Key = "key.typeusr"
        /// key.uids
        public static let uids: Key = "key.uids"
        /// key.unpopular
        public static let unpopular: Key = "key.unpopular"
        /// key.usr
        public static let usr: Key = "key.usr"
        /// key.version_major
        public static let version_major: Key = "key.version_major"
        /// key.version_minor
        public static let version_minor: Key = "key.version_minor"
    }
    public struct SourceAvailabilityPlatform {
        public let uid: UID
        /// source.availability.platform.ios
        public static let ios: SourceAvailabilityPlatform = "source.availability.platform.ios"
        /// source.availability.platform.ios_app_extension
        public static let ios_app_extension: SourceAvailabilityPlatform = "source.availability.platform.ios_app_extension"
        /// source.availability.platform.osx
        public static let osx: SourceAvailabilityPlatform = "source.availability.platform.osx"
        /// source.availability.platform.osx_app_extension
        public static let osx_app_extension: SourceAvailabilityPlatform = "source.availability.platform.osx_app_extension"
        /// source.availability.platform.tvos
        public static let tvos: SourceAvailabilityPlatform = "source.availability.platform.tvos"
        /// source.availability.platform.tvos_app_extension
        public static let tvos_app_extension: SourceAvailabilityPlatform = "source.availability.platform.tvos_app_extension"
        /// source.availability.platform.watchos
        public static let watchos: SourceAvailabilityPlatform = "source.availability.platform.watchos"
        /// source.availability.platform.watchos_app_extension
        public static let watchos_app_extension: SourceAvailabilityPlatform = "source.availability.platform.watchos_app_extension"
    }
    public struct SourceCodecompletion {
        public let uid: UID
        /// source.codecompletion.context.exprspecific
        public static let contextExprspecific: SourceCodecompletion = "source.codecompletion.context.exprspecific"
        /// source.codecompletion.context.local
        public static let contextLocal: SourceCodecompletion = "source.codecompletion.context.local"
        /// source.codecompletion.context.none
        public static let contextNone: SourceCodecompletion = "source.codecompletion.context.none"
        /// source.codecompletion.context.otherclass
        public static let contextOtherclass: SourceCodecompletion = "source.codecompletion.context.otherclass"
        /// source.codecompletion.context.othermodule
        public static let contextOthermodule: SourceCodecompletion = "source.codecompletion.context.othermodule"
        /// source.codecompletion.context.superclass
        public static let contextSuperclass: SourceCodecompletion = "source.codecompletion.context.superclass"
        /// source.codecompletion.context.thisclass
        public static let contextThisclass: SourceCodecompletion = "source.codecompletion.context.thisclass"
        /// source.codecompletion.context.thismodule
        public static let contextThismodule: SourceCodecompletion = "source.codecompletion.context.thismodule"
        /// source.codecompletion.custom
        public static let custom: SourceCodecompletion = "source.codecompletion.custom"
        /// source.codecompletion.everything
        public static let everything: SourceCodecompletion = "source.codecompletion.everything"
        /// source.codecompletion.identifier
        public static let identifier: SourceCodecompletion = "source.codecompletion.identifier"
        /// source.codecompletion.keyword
        public static let keyword: SourceCodecompletion = "source.codecompletion.keyword"
        /// source.codecompletion.literal
        public static let literal: SourceCodecompletion = "source.codecompletion.literal"
        /// source.codecompletion.module
        public static let module: SourceCodecompletion = "source.codecompletion.module"
    }
    public struct SourceDeclAttribute {
        public let uid: UID
        /// source.decl.attribute.LLDBDebuggerFunction
        public static let LLDBDebuggerFunction: SourceDeclAttribute = "source.decl.attribute.LLDBDebuggerFunction"
        /// source.decl.attribute.NSApplicationMain
        public static let NSApplicationMain: SourceDeclAttribute = "source.decl.attribute.NSApplicationMain"
        /// source.decl.attribute.NSCopying
        public static let NSCopying: SourceDeclAttribute = "source.decl.attribute.NSCopying"
        /// source.decl.attribute.NSManaged
        public static let NSManaged: SourceDeclAttribute = "source.decl.attribute.NSManaged"
        /// source.decl.attribute.UIApplicationMain
        public static let UIApplicationMain: SourceDeclAttribute = "source.decl.attribute.UIApplicationMain"
        /// source.decl.attribute.__objc_bridged
        public static let __objc_bridged: SourceDeclAttribute = "source.decl.attribute.__objc_bridged"
        /// source.decl.attribute.__synthesized_protocol
        public static let __synthesized_protocol: SourceDeclAttribute = "source.decl.attribute.__synthesized_protocol"
        /// source.decl.attribute._alignment
        public static let _alignment: SourceDeclAttribute = "source.decl.attribute._alignment"
        /// source.decl.attribute._cdecl
        public static let _cdecl: SourceDeclAttribute = "source.decl.attribute._cdecl"
        /// source.decl.attribute._exported
        public static let _exported: SourceDeclAttribute = "source.decl.attribute._exported"
        /// source.decl.attribute._fixed_layout
        public static let _fixed_layout: SourceDeclAttribute = "source.decl.attribute._fixed_layout"
        /// source.decl.attribute._inlineable
        public static let _inlineable: SourceDeclAttribute = "source.decl.attribute._inlineable"
        /// source.decl.attribute._semantics
        public static let _semantics: SourceDeclAttribute = "source.decl.attribute._semantics"
        /// source.decl.attribute._silgen_name
        public static let _silgen_name: SourceDeclAttribute = "source.decl.attribute._silgen_name"
        /// source.decl.attribute._specialize
        public static let _specialize: SourceDeclAttribute = "source.decl.attribute._specialize"
        /// source.decl.attribute._swift_native_objc_runtime_base
        public static let _swift_native_objc_runtime_base: SourceDeclAttribute = "source.decl.attribute._swift_native_objc_runtime_base"
        /// source.decl.attribute._transparent
        public static let _transparent: SourceDeclAttribute = "source.decl.attribute._transparent"
        /// source.decl.attribute._versioned
        public static let _versioned: SourceDeclAttribute = "source.decl.attribute._versioned"
        /// source.decl.attribute.autoclosure
        public static let autoclosure: SourceDeclAttribute = "source.decl.attribute.autoclosure"
        /// source.decl.attribute.available
        public static let available: SourceDeclAttribute = "source.decl.attribute.available"
        /// source.decl.attribute.convenience
        public static let convenience: SourceDeclAttribute = "source.decl.attribute.convenience"
        /// source.decl.attribute.discardableResult
        public static let discardableResult: SourceDeclAttribute = "source.decl.attribute.discardableResult"
        /// source.decl.attribute.dynamic
        public static let dynamic: SourceDeclAttribute = "source.decl.attribute.dynamic"
        /// source.decl.attribute.effects
        public static let effects: SourceDeclAttribute = "source.decl.attribute.effects"
        /// source.decl.attribute.final
        public static let final: SourceDeclAttribute = "source.decl.attribute.final"
        /// source.decl.attribute.gkinspectable
        public static let gkinspectable: SourceDeclAttribute = "source.decl.attribute.gkinspectable"
        /// source.decl.attribute.ibaction
        public static let ibaction: SourceDeclAttribute = "source.decl.attribute.ibaction"
        /// source.decl.attribute.ibdesignable
        public static let ibdesignable: SourceDeclAttribute = "source.decl.attribute.ibdesignable"
        /// source.decl.attribute.ibinspectable
        public static let ibinspectable: SourceDeclAttribute = "source.decl.attribute.ibinspectable"
        /// source.decl.attribute.iboutlet
        public static let iboutlet: SourceDeclAttribute = "source.decl.attribute.iboutlet"
        /// source.decl.attribute.indirect
        public static let indirect: SourceDeclAttribute = "source.decl.attribute.indirect"
        /// source.decl.attribute.infix
        public static let infix: SourceDeclAttribute = "source.decl.attribute.infix"
        /// source.decl.attribute.inline
        public static let inline: SourceDeclAttribute = "source.decl.attribute.inline"
        /// source.decl.attribute.lazy
        public static let lazy: SourceDeclAttribute = "source.decl.attribute.lazy"
        /// source.decl.attribute.mutating
        public static let mutating: SourceDeclAttribute = "source.decl.attribute.mutating"
        /// source.decl.attribute.noescape
        public static let noescape: SourceDeclAttribute = "source.decl.attribute.noescape"
        /// source.decl.attribute.nonmutating
        public static let nonmutating: SourceDeclAttribute = "source.decl.attribute.nonmutating"
        /// source.decl.attribute.nonobjc
        public static let nonobjc: SourceDeclAttribute = "source.decl.attribute.nonobjc"
        /// source.decl.attribute.noreturn
        public static let noreturn: SourceDeclAttribute = "source.decl.attribute.noreturn"
        /// source.decl.attribute.objc
        public static let objc: SourceDeclAttribute = "source.decl.attribute.objc"
        /// source.decl.attribute.objc.name
        public static let objcName: SourceDeclAttribute = "source.decl.attribute.objc.name"
        /// source.decl.attribute.objc_non_lazy_realization
        public static let objc_non_lazy_realization: SourceDeclAttribute = "source.decl.attribute.objc_non_lazy_realization"
        /// source.decl.attribute.optional
        public static let optional: SourceDeclAttribute = "source.decl.attribute.optional"
        /// source.decl.attribute.override
        public static let override: SourceDeclAttribute = "source.decl.attribute.override"
        /// source.decl.attribute.postfix
        public static let postfix: SourceDeclAttribute = "source.decl.attribute.postfix"
        /// source.decl.attribute.prefix
        public static let prefix: SourceDeclAttribute = "source.decl.attribute.prefix"
        /// source.decl.attribute.required
        public static let required: SourceDeclAttribute = "source.decl.attribute.required"
        /// source.decl.attribute.requires_stored_property_inits
        public static let requires_stored_property_inits: SourceDeclAttribute = "source.decl.attribute.requires_stored_property_inits"
        /// source.decl.attribute.rethrows
        public static let `rethrows`: SourceDeclAttribute = "source.decl.attribute.rethrows"
        /// source.decl.attribute.sil_stored
        public static let sil_stored: SourceDeclAttribute = "source.decl.attribute.sil_stored"
        /// source.decl.attribute.testable
        public static let testable: SourceDeclAttribute = "source.decl.attribute.testable"
        /// source.decl.attribute.unsafe_no_objc_tagged_pointer
        public static let unsafe_no_objc_tagged_pointer: SourceDeclAttribute = "source.decl.attribute.unsafe_no_objc_tagged_pointer"
        /// source.decl.attribute.warn_unqualified_access
        public static let warn_unqualified_access: SourceDeclAttribute = "source.decl.attribute.warn_unqualified_access"
        /// source.decl.attribute.weak
        public static let weak: SourceDeclAttribute = "source.decl.attribute.weak"
    }
    public struct SourceDiagnosticSeverity {
        public let uid: UID
        /// source.diagnostic.severity.error
        public static let error: SourceDiagnosticSeverity = "source.diagnostic.severity.error"
        /// source.diagnostic.severity.note
        public static let note: SourceDiagnosticSeverity = "source.diagnostic.severity.note"
        /// source.diagnostic.severity.warning
        public static let warning: SourceDiagnosticSeverity = "source.diagnostic.severity.warning"
    }
    public struct SourceDiagnosticStageSwift {
        public let uid: UID
        /// source.diagnostic.stage.swift.parse
        public static let parse: SourceDiagnosticStageSwift = "source.diagnostic.stage.swift.parse"
        /// source.diagnostic.stage.swift.sema
        public static let sema: SourceDiagnosticStageSwift = "source.diagnostic.stage.swift.sema"
    }
    public struct SourceLangSwift {
        public let uid: UID
        /// source.lang.swift.expr
        public static let expr: SourceLangSwift = "source.lang.swift.expr"
        /// source.lang.swift.keyword
        public static let keyword: SourceLangSwift = "source.lang.swift.keyword"
        /// source.lang.swift.pattern
        public static let pattern: SourceLangSwift = "source.lang.swift.pattern"
        /// source.lang.swift.range.invalid
        public static let rangeInvalid: SourceLangSwift = "source.lang.swift.range.invalid"
        /// source.lang.swift.range.multistatement
        public static let rangeMultistatement: SourceLangSwift = "source.lang.swift.range.multistatement"
        /// source.lang.swift.range.singledeclaration
        public static let rangeSingledeclaration: SourceLangSwift = "source.lang.swift.range.singledeclaration"
        /// source.lang.swift.range.singleexpression
        public static let rangeSingleexpression: SourceLangSwift = "source.lang.swift.range.singleexpression"
        /// source.lang.swift.range.singlestatement
        public static let rangeSinglestatement: SourceLangSwift = "source.lang.swift.range.singlestatement"
        /// source.lang.swift.stmt
        public static let stmt: SourceLangSwift = "source.lang.swift.stmt"
        /// source.lang.swift.type
        public static let type: SourceLangSwift = "source.lang.swift.type"
    }
    public struct SourceLangSwiftAccessibility {
        public let uid: UID
        /// source.lang.swift.accessibility.fileprivate
        public static let `fileprivate`: SourceLangSwiftAccessibility = "source.lang.swift.accessibility.fileprivate"
        /// source.lang.swift.accessibility.internal
        public static let `internal`: SourceLangSwiftAccessibility = "source.lang.swift.accessibility.internal"
        /// source.lang.swift.accessibility.open
        public static let open: SourceLangSwiftAccessibility = "source.lang.swift.accessibility.open"
        /// source.lang.swift.accessibility.private
        public static let `private`: SourceLangSwiftAccessibility = "source.lang.swift.accessibility.private"
        /// source.lang.swift.accessibility.public
        public static let `public`: SourceLangSwiftAccessibility = "source.lang.swift.accessibility.public"
    }
    public struct SourceLangSwiftAttribute {
        public let uid: UID
        /// source.lang.swift.attribute.availability
        public static let availability: SourceLangSwiftAttribute = "source.lang.swift.attribute.availability"
    }
    public struct SourceLangSwiftCodecomplete {
        public let uid: UID
        /// source.lang.swift.codecomplete.group
        public static let group: SourceLangSwiftCodecomplete = "source.lang.swift.codecomplete.group"
    }
    public struct SourceLangSwiftDecl {
        public let uid: UID
        /// source.lang.swift.decl.associatedtype
        public static let `associatedtype`: SourceLangSwiftDecl = "source.lang.swift.decl.associatedtype"
        /// source.lang.swift.decl.class
        public static let `class`: SourceLangSwiftDecl = "source.lang.swift.decl.class"
        /// source.lang.swift.decl.enum
        public static let `enum`: SourceLangSwiftDecl = "source.lang.swift.decl.enum"
        /// source.lang.swift.decl.enumcase
        public static let enumcase: SourceLangSwiftDecl = "source.lang.swift.decl.enumcase"
        /// source.lang.swift.decl.enumelement
        public static let enumelement: SourceLangSwiftDecl = "source.lang.swift.decl.enumelement"
        /// source.lang.swift.decl.extension
        public static let `extension`: SourceLangSwiftDecl = "source.lang.swift.decl.extension"
        /// source.lang.swift.decl.extension.class
        public static let extensionClass: SourceLangSwiftDecl = "source.lang.swift.decl.extension.class"
        /// source.lang.swift.decl.extension.enum
        public static let extensionEnum: SourceLangSwiftDecl = "source.lang.swift.decl.extension.enum"
        /// source.lang.swift.decl.extension.protocol
        public static let extensionProtocol: SourceLangSwiftDecl = "source.lang.swift.decl.extension.protocol"
        /// source.lang.swift.decl.extension.struct
        public static let extensionStruct: SourceLangSwiftDecl = "source.lang.swift.decl.extension.struct"
        /// source.lang.swift.decl.function.accessor.address
        public static let functionAccessorAddress: SourceLangSwiftDecl = "source.lang.swift.decl.function.accessor.address"
        /// source.lang.swift.decl.function.accessor.didset
        public static let functionAccessorDidset: SourceLangSwiftDecl = "source.lang.swift.decl.function.accessor.didset"
        /// source.lang.swift.decl.function.accessor.getter
        public static let functionAccessorGetter: SourceLangSwiftDecl = "source.lang.swift.decl.function.accessor.getter"
        /// source.lang.swift.decl.function.accessor.mutableaddress
        public static let functionAccessorMutableaddress: SourceLangSwiftDecl = "source.lang.swift.decl.function.accessor.mutableaddress"
        /// source.lang.swift.decl.function.accessor.setter
        public static let functionAccessorSetter: SourceLangSwiftDecl = "source.lang.swift.decl.function.accessor.setter"
        /// source.lang.swift.decl.function.accessor.willset
        public static let functionAccessorWillset: SourceLangSwiftDecl = "source.lang.swift.decl.function.accessor.willset"
        /// source.lang.swift.decl.function.constructor
        public static let functionConstructor: SourceLangSwiftDecl = "source.lang.swift.decl.function.constructor"
        /// source.lang.swift.decl.function.destructor
        public static let functionDestructor: SourceLangSwiftDecl = "source.lang.swift.decl.function.destructor"
        /// source.lang.swift.decl.function.free
        public static let functionFree: SourceLangSwiftDecl = "source.lang.swift.decl.function.free"
        /// source.lang.swift.decl.function.method.class
        public static let functionMethodClass: SourceLangSwiftDecl = "source.lang.swift.decl.function.method.class"
        /// source.lang.swift.decl.function.method.instance
        public static let functionMethodInstance: SourceLangSwiftDecl = "source.lang.swift.decl.function.method.instance"
        /// source.lang.swift.decl.function.method.static
        public static let functionMethodStatic: SourceLangSwiftDecl = "source.lang.swift.decl.function.method.static"
        /// source.lang.swift.decl.function.operator.infix
        public static let functionOperatorInfix: SourceLangSwiftDecl = "source.lang.swift.decl.function.operator.infix"
        /// source.lang.swift.decl.function.operator.postfix
        public static let functionOperatorPostfix: SourceLangSwiftDecl = "source.lang.swift.decl.function.operator.postfix"
        /// source.lang.swift.decl.function.operator.prefix
        public static let functionOperatorPrefix: SourceLangSwiftDecl = "source.lang.swift.decl.function.operator.prefix"
        /// source.lang.swift.decl.function.subscript
        public static let functionSubscript: SourceLangSwiftDecl = "source.lang.swift.decl.function.subscript"
        /// source.lang.swift.decl.generic_type_param
        public static let generic_type_param: SourceLangSwiftDecl = "source.lang.swift.decl.generic_type_param"
        /// source.lang.swift.decl.module
        public static let module: SourceLangSwiftDecl = "source.lang.swift.decl.module"
        /// source.lang.swift.decl.precedencegroup
        public static let `precedencegroup`: SourceLangSwiftDecl = "source.lang.swift.decl.precedencegroup"
        /// source.lang.swift.decl.protocol
        public static let `protocol`: SourceLangSwiftDecl = "source.lang.swift.decl.protocol"
        /// source.lang.swift.decl.struct
        public static let `struct`: SourceLangSwiftDecl = "source.lang.swift.decl.struct"
        /// source.lang.swift.decl.typealias
        public static let `typealias`: SourceLangSwiftDecl = "source.lang.swift.decl.typealias"
        /// source.lang.swift.decl.var.class
        public static let varClass: SourceLangSwiftDecl = "source.lang.swift.decl.var.class"
        /// source.lang.swift.decl.var.global
        public static let varGlobal: SourceLangSwiftDecl = "source.lang.swift.decl.var.global"
        /// source.lang.swift.decl.var.instance
        public static let varInstance: SourceLangSwiftDecl = "source.lang.swift.decl.var.instance"
        /// source.lang.swift.decl.var.local
        public static let varLocal: SourceLangSwiftDecl = "source.lang.swift.decl.var.local"
        /// source.lang.swift.decl.var.parameter
        public static let varParameter: SourceLangSwiftDecl = "source.lang.swift.decl.var.parameter"
        /// source.lang.swift.decl.var.static
        public static let varStatic: SourceLangSwiftDecl = "source.lang.swift.decl.var.static"
    }
    public struct SourceLangSwiftExpr {
        public let uid: UID
        /// source.lang.swift.expr.argument
        public static let argument: SourceLangSwiftExpr = "source.lang.swift.expr.argument"
        /// source.lang.swift.expr.array
        public static let array: SourceLangSwiftExpr = "source.lang.swift.expr.array"
        /// source.lang.swift.expr.call
        public static let call: SourceLangSwiftExpr = "source.lang.swift.expr.call"
        /// source.lang.swift.expr.dictionary
        public static let dictionary: SourceLangSwiftExpr = "source.lang.swift.expr.dictionary"
        /// source.lang.swift.expr.object_literal
        public static let object_literal: SourceLangSwiftExpr = "source.lang.swift.expr.object_literal"
    }
    public struct SourceLangSwiftImportModule {
        public let uid: UID
        /// source.lang.swift.import.module.clang
        public static let clang: SourceLangSwiftImportModule = "source.lang.swift.import.module.clang"
        /// source.lang.swift.import.module.swift
        public static let swift: SourceLangSwiftImportModule = "source.lang.swift.import.module.swift"
    }
    public struct SourceLangSwiftKeyword {
        public let uid: UID
        /// source.lang.swift.keyword.Any
        public static let `Any`: SourceLangSwiftKeyword = "source.lang.swift.keyword.Any"
        /// source.lang.swift.keyword.Self
        public static let `Self`: SourceLangSwiftKeyword = "source.lang.swift.keyword.Self"
        /// source.lang.swift.keyword._
        public static let `_`: SourceLangSwiftKeyword = "source.lang.swift.keyword._"
        /// source.lang.swift.keyword.__COLUMN__
        public static let `__COLUMN__`: SourceLangSwiftKeyword = "source.lang.swift.keyword.__COLUMN__"
        /// source.lang.swift.keyword.__DSO_HANDLE__
        public static let `__DSO_HANDLE__`: SourceLangSwiftKeyword = "source.lang.swift.keyword.__DSO_HANDLE__"
        /// source.lang.swift.keyword.__FILE__
        public static let `__FILE__`: SourceLangSwiftKeyword = "source.lang.swift.keyword.__FILE__"
        /// source.lang.swift.keyword.__FUNCTION__
        public static let `__FUNCTION__`: SourceLangSwiftKeyword = "source.lang.swift.keyword.__FUNCTION__"
        /// source.lang.swift.keyword.__LINE__
        public static let `__LINE__`: SourceLangSwiftKeyword = "source.lang.swift.keyword.__LINE__"
        /// source.lang.swift.keyword.as
        public static let `as`: SourceLangSwiftKeyword = "source.lang.swift.keyword.as"
        /// source.lang.swift.keyword.associatedtype
        public static let `associatedtype`: SourceLangSwiftKeyword = "source.lang.swift.keyword.associatedtype"
        /// source.lang.swift.keyword.break
        public static let `break`: SourceLangSwiftKeyword = "source.lang.swift.keyword.break"
        /// source.lang.swift.keyword.case
        public static let `case`: SourceLangSwiftKeyword = "source.lang.swift.keyword.case"
        /// source.lang.swift.keyword.catch
        public static let `catch`: SourceLangSwiftKeyword = "source.lang.swift.keyword.catch"
        /// source.lang.swift.keyword.class
        public static let `class`: SourceLangSwiftKeyword = "source.lang.swift.keyword.class"
        /// source.lang.swift.keyword.continue
        public static let `continue`: SourceLangSwiftKeyword = "source.lang.swift.keyword.continue"
        /// source.lang.swift.keyword.default
        public static let `default`: SourceLangSwiftKeyword = "source.lang.swift.keyword.default"
        /// source.lang.swift.keyword.defer
        public static let `defer`: SourceLangSwiftKeyword = "source.lang.swift.keyword.defer"
        /// source.lang.swift.keyword.deinit
        public static let `deinit`: SourceLangSwiftKeyword = "source.lang.swift.keyword.deinit"
        /// source.lang.swift.keyword.do
        public static let `do`: SourceLangSwiftKeyword = "source.lang.swift.keyword.do"
        /// source.lang.swift.keyword.else
        public static let `else`: SourceLangSwiftKeyword = "source.lang.swift.keyword.else"
        /// source.lang.swift.keyword.enum
        public static let `enum`: SourceLangSwiftKeyword = "source.lang.swift.keyword.enum"
        /// source.lang.swift.keyword.extension
        public static let `extension`: SourceLangSwiftKeyword = "source.lang.swift.keyword.extension"
        /// source.lang.swift.keyword.fallthrough
        public static let `fallthrough`: SourceLangSwiftKeyword = "source.lang.swift.keyword.fallthrough"
        /// source.lang.swift.keyword.false
        public static let `false`: SourceLangSwiftKeyword = "source.lang.swift.keyword.false"
        /// source.lang.swift.keyword.fileprivate
        public static let `fileprivate`: SourceLangSwiftKeyword = "source.lang.swift.keyword.fileprivate"
        /// source.lang.swift.keyword.for
        public static let `for`: SourceLangSwiftKeyword = "source.lang.swift.keyword.for"
        /// source.lang.swift.keyword.func
        public static let `func`: SourceLangSwiftKeyword = "source.lang.swift.keyword.func"
        /// source.lang.swift.keyword.guard
        public static let `guard`: SourceLangSwiftKeyword = "source.lang.swift.keyword.guard"
        /// source.lang.swift.keyword.if
        public static let `if`: SourceLangSwiftKeyword = "source.lang.swift.keyword.if"
        /// source.lang.swift.keyword.import
        public static let `import`: SourceLangSwiftKeyword = "source.lang.swift.keyword.import"
        /// source.lang.swift.keyword.in
        public static let `in`: SourceLangSwiftKeyword = "source.lang.swift.keyword.in"
        /// source.lang.swift.keyword.init
        public static let `init`: SourceLangSwiftKeyword = "source.lang.swift.keyword.init"
        /// source.lang.swift.keyword.inout
        public static let `inout`: SourceLangSwiftKeyword = "source.lang.swift.keyword.inout"
        /// source.lang.swift.keyword.internal
        public static let `internal`: SourceLangSwiftKeyword = "source.lang.swift.keyword.internal"
        /// source.lang.swift.keyword.is
        public static let `is`: SourceLangSwiftKeyword = "source.lang.swift.keyword.is"
        /// source.lang.swift.keyword.let
        public static let `let`: SourceLangSwiftKeyword = "source.lang.swift.keyword.let"
        /// source.lang.swift.keyword.nil
        public static let `nil`: SourceLangSwiftKeyword = "source.lang.swift.keyword.nil"
        /// source.lang.swift.keyword.operator
        public static let `operator`: SourceLangSwiftKeyword = "source.lang.swift.keyword.operator"
        /// source.lang.swift.keyword.precedencegroup
        public static let `precedencegroup`: SourceLangSwiftKeyword = "source.lang.swift.keyword.precedencegroup"
        /// source.lang.swift.keyword.private
        public static let `private`: SourceLangSwiftKeyword = "source.lang.swift.keyword.private"
        /// source.lang.swift.keyword.protocol
        public static let `protocol`: SourceLangSwiftKeyword = "source.lang.swift.keyword.protocol"
        /// source.lang.swift.keyword.public
        public static let `public`: SourceLangSwiftKeyword = "source.lang.swift.keyword.public"
        /// source.lang.swift.keyword.repeat
        public static let `repeat`: SourceLangSwiftKeyword = "source.lang.swift.keyword.repeat"
        /// source.lang.swift.keyword.rethrows
        public static let `rethrows`: SourceLangSwiftKeyword = "source.lang.swift.keyword.rethrows"
        /// source.lang.swift.keyword.return
        public static let `return`: SourceLangSwiftKeyword = "source.lang.swift.keyword.return"
        /// source.lang.swift.keyword.self
        public static let `self`: SourceLangSwiftKeyword = "source.lang.swift.keyword.self"
        /// source.lang.swift.keyword.static
        public static let `static`: SourceLangSwiftKeyword = "source.lang.swift.keyword.static"
        /// source.lang.swift.keyword.struct
        public static let `struct`: SourceLangSwiftKeyword = "source.lang.swift.keyword.struct"
        /// source.lang.swift.keyword.subscript
        public static let `subscript`: SourceLangSwiftKeyword = "source.lang.swift.keyword.subscript"
        /// source.lang.swift.keyword.super
        public static let `super`: SourceLangSwiftKeyword = "source.lang.swift.keyword.super"
        /// source.lang.swift.keyword.switch
        public static let `switch`: SourceLangSwiftKeyword = "source.lang.swift.keyword.switch"
        /// source.lang.swift.keyword.throw
        public static let `throw`: SourceLangSwiftKeyword = "source.lang.swift.keyword.throw"
        /// source.lang.swift.keyword.throws
        public static let `throws`: SourceLangSwiftKeyword = "source.lang.swift.keyword.throws"
        /// source.lang.swift.keyword.true
        public static let `true`: SourceLangSwiftKeyword = "source.lang.swift.keyword.true"
        /// source.lang.swift.keyword.try
        public static let `try`: SourceLangSwiftKeyword = "source.lang.swift.keyword.try"
        /// source.lang.swift.keyword.typealias
        public static let `typealias`: SourceLangSwiftKeyword = "source.lang.swift.keyword.typealias"
        /// source.lang.swift.keyword.var
        public static let `var`: SourceLangSwiftKeyword = "source.lang.swift.keyword.var"
        /// source.lang.swift.keyword.where
        public static let `where`: SourceLangSwiftKeyword = "source.lang.swift.keyword.where"
        /// source.lang.swift.keyword.while
        public static let `while`: SourceLangSwiftKeyword = "source.lang.swift.keyword.while"
    }
    public struct SourceLangSwiftLiteral {
        public let uid: UID
        /// source.lang.swift.literal.array
        public static let array: SourceLangSwiftLiteral = "source.lang.swift.literal.array"
        /// source.lang.swift.literal.boolean
        public static let boolean: SourceLangSwiftLiteral = "source.lang.swift.literal.boolean"
        /// source.lang.swift.literal.color
        public static let color: SourceLangSwiftLiteral = "source.lang.swift.literal.color"
        /// source.lang.swift.literal.dictionary
        public static let dictionary: SourceLangSwiftLiteral = "source.lang.swift.literal.dictionary"
        /// source.lang.swift.literal.image
        public static let image: SourceLangSwiftLiteral = "source.lang.swift.literal.image"
        /// source.lang.swift.literal.integer
        public static let integer: SourceLangSwiftLiteral = "source.lang.swift.literal.integer"
        /// source.lang.swift.literal.nil
        public static let `nil`: SourceLangSwiftLiteral = "source.lang.swift.literal.nil"
        /// source.lang.swift.literal.string
        public static let string: SourceLangSwiftLiteral = "source.lang.swift.literal.string"
        /// source.lang.swift.literal.tuple
        public static let tuple: SourceLangSwiftLiteral = "source.lang.swift.literal.tuple"
    }
    public struct SourceLangSwiftRef {
        public let uid: UID
        /// source.lang.swift.ref.associatedtype
        public static let `associatedtype`: SourceLangSwiftRef = "source.lang.swift.ref.associatedtype"
        /// source.lang.swift.ref.class
        public static let `class`: SourceLangSwiftRef = "source.lang.swift.ref.class"
        /// source.lang.swift.ref.enum
        public static let `enum`: SourceLangSwiftRef = "source.lang.swift.ref.enum"
        /// source.lang.swift.ref.enumelement
        public static let enumelement: SourceLangSwiftRef = "source.lang.swift.ref.enumelement"
        /// source.lang.swift.ref.function.accessor.address
        public static let functionAccessorAddress: SourceLangSwiftRef = "source.lang.swift.ref.function.accessor.address"
        /// source.lang.swift.ref.function.accessor.didset
        public static let functionAccessorDidset: SourceLangSwiftRef = "source.lang.swift.ref.function.accessor.didset"
        /// source.lang.swift.ref.function.accessor.getter
        public static let functionAccessorGetter: SourceLangSwiftRef = "source.lang.swift.ref.function.accessor.getter"
        /// source.lang.swift.ref.function.accessor.mutableaddress
        public static let functionAccessorMutableaddress: SourceLangSwiftRef = "source.lang.swift.ref.function.accessor.mutableaddress"
        /// source.lang.swift.ref.function.accessor.setter
        public static let functionAccessorSetter: SourceLangSwiftRef = "source.lang.swift.ref.function.accessor.setter"
        /// source.lang.swift.ref.function.accessor.willset
        public static let functionAccessorWillset: SourceLangSwiftRef = "source.lang.swift.ref.function.accessor.willset"
        /// source.lang.swift.ref.function.constructor
        public static let functionConstructor: SourceLangSwiftRef = "source.lang.swift.ref.function.constructor"
        /// source.lang.swift.ref.function.destructor
        public static let functionDestructor: SourceLangSwiftRef = "source.lang.swift.ref.function.destructor"
        /// source.lang.swift.ref.function.free
        public static let functionFree: SourceLangSwiftRef = "source.lang.swift.ref.function.free"
        /// source.lang.swift.ref.function.method.class
        public static let functionMethodClass: SourceLangSwiftRef = "source.lang.swift.ref.function.method.class"
        /// source.lang.swift.ref.function.method.instance
        public static let functionMethodInstance: SourceLangSwiftRef = "source.lang.swift.ref.function.method.instance"
        /// source.lang.swift.ref.function.method.static
        public static let functionMethodStatic: SourceLangSwiftRef = "source.lang.swift.ref.function.method.static"
        /// source.lang.swift.ref.function.operator.infix
        public static let functionOperatorInfix: SourceLangSwiftRef = "source.lang.swift.ref.function.operator.infix"
        /// source.lang.swift.ref.function.operator.postfix
        public static let functionOperatorPostfix: SourceLangSwiftRef = "source.lang.swift.ref.function.operator.postfix"
        /// source.lang.swift.ref.function.operator.prefix
        public static let functionOperatorPrefix: SourceLangSwiftRef = "source.lang.swift.ref.function.operator.prefix"
        /// source.lang.swift.ref.function.subscript
        public static let functionSubscript: SourceLangSwiftRef = "source.lang.swift.ref.function.subscript"
        /// source.lang.swift.ref.generic_type_param
        public static let generic_type_param: SourceLangSwiftRef = "source.lang.swift.ref.generic_type_param"
        /// source.lang.swift.ref.module
        public static let module: SourceLangSwiftRef = "source.lang.swift.ref.module"
        /// source.lang.swift.ref.precedencegroup
        public static let `precedencegroup`: SourceLangSwiftRef = "source.lang.swift.ref.precedencegroup"
        /// source.lang.swift.ref.protocol
        public static let `protocol`: SourceLangSwiftRef = "source.lang.swift.ref.protocol"
        /// source.lang.swift.ref.struct
        public static let `struct`: SourceLangSwiftRef = "source.lang.swift.ref.struct"
        /// source.lang.swift.ref.typealias
        public static let `typealias`: SourceLangSwiftRef = "source.lang.swift.ref.typealias"
        /// source.lang.swift.ref.var.class
        public static let varClass: SourceLangSwiftRef = "source.lang.swift.ref.var.class"
        /// source.lang.swift.ref.var.global
        public static let varGlobal: SourceLangSwiftRef = "source.lang.swift.ref.var.global"
        /// source.lang.swift.ref.var.instance
        public static let varInstance: SourceLangSwiftRef = "source.lang.swift.ref.var.instance"
        /// source.lang.swift.ref.var.local
        public static let varLocal: SourceLangSwiftRef = "source.lang.swift.ref.var.local"
        /// source.lang.swift.ref.var.static
        public static let varStatic: SourceLangSwiftRef = "source.lang.swift.ref.var.static"
    }
    public struct SourceLangSwiftStmt {
        public let uid: UID
        /// source.lang.swift.stmt.brace
        public static let brace: SourceLangSwiftStmt = "source.lang.swift.stmt.brace"
        /// source.lang.swift.stmt.case
        public static let `case`: SourceLangSwiftStmt = "source.lang.swift.stmt.case"
        /// source.lang.swift.stmt.for
        public static let `for`: SourceLangSwiftStmt = "source.lang.swift.stmt.for"
        /// source.lang.swift.stmt.foreach
        public static let foreach: SourceLangSwiftStmt = "source.lang.swift.stmt.foreach"
        /// source.lang.swift.stmt.guard
        public static let `guard`: SourceLangSwiftStmt = "source.lang.swift.stmt.guard"
        /// source.lang.swift.stmt.if
        public static let `if`: SourceLangSwiftStmt = "source.lang.swift.stmt.if"
        /// source.lang.swift.stmt.repeatwhile
        public static let repeatwhile: SourceLangSwiftStmt = "source.lang.swift.stmt.repeatwhile"
        /// source.lang.swift.stmt.switch
        public static let `switch`: SourceLangSwiftStmt = "source.lang.swift.stmt.switch"
        /// source.lang.swift.stmt.while
        public static let `while`: SourceLangSwiftStmt = "source.lang.swift.stmt.while"
    }
    public struct SourceLangSwiftStructureElem {
        public let uid: UID
        /// source.lang.swift.structure.elem.condition_expr
        public static let condition_expr: SourceLangSwiftStructureElem = "source.lang.swift.structure.elem.condition_expr"
        /// source.lang.swift.structure.elem.expr
        public static let expr: SourceLangSwiftStructureElem = "source.lang.swift.structure.elem.expr"
        /// source.lang.swift.structure.elem.id
        public static let id: SourceLangSwiftStructureElem = "source.lang.swift.structure.elem.id"
        /// source.lang.swift.structure.elem.init_expr
        public static let init_expr: SourceLangSwiftStructureElem = "source.lang.swift.structure.elem.init_expr"
        /// source.lang.swift.structure.elem.pattern
        public static let pattern: SourceLangSwiftStructureElem = "source.lang.swift.structure.elem.pattern"
        /// source.lang.swift.structure.elem.typeref
        public static let typeref: SourceLangSwiftStructureElem = "source.lang.swift.structure.elem.typeref"
    }
    public struct SourceLangSwiftSyntaxtype {
        public let uid: UID
        /// source.lang.swift.syntaxtype.argument
        public static let argument: SourceLangSwiftSyntaxtype = "source.lang.swift.syntaxtype.argument"
        /// source.lang.swift.syntaxtype.attribute.builtin
        public static let attributeBuiltin: SourceLangSwiftSyntaxtype = "source.lang.swift.syntaxtype.attribute.builtin"
        /// source.lang.swift.syntaxtype.attribute.id
        public static let attributeId: SourceLangSwiftSyntaxtype = "source.lang.swift.syntaxtype.attribute.id"
        /// source.lang.swift.syntaxtype.buildconfig.id
        public static let buildconfigId: SourceLangSwiftSyntaxtype = "source.lang.swift.syntaxtype.buildconfig.id"
        /// source.lang.swift.syntaxtype.buildconfig.keyword
        public static let buildconfigKeyword: SourceLangSwiftSyntaxtype = "source.lang.swift.syntaxtype.buildconfig.keyword"
        /// source.lang.swift.syntaxtype.comment
        public static let comment: SourceLangSwiftSyntaxtype = "source.lang.swift.syntaxtype.comment"
        /// source.lang.swift.syntaxtype.comment.mark
        public static let commentMark: SourceLangSwiftSyntaxtype = "source.lang.swift.syntaxtype.comment.mark"
        /// source.lang.swift.syntaxtype.comment.url
        public static let commentUrl: SourceLangSwiftSyntaxtype = "source.lang.swift.syntaxtype.comment.url"
        /// source.lang.swift.syntaxtype.doccomment
        public static let doccomment: SourceLangSwiftSyntaxtype = "source.lang.swift.syntaxtype.doccomment"
        /// source.lang.swift.syntaxtype.doccomment.field
        public static let doccommentField: SourceLangSwiftSyntaxtype = "source.lang.swift.syntaxtype.doccomment.field"
        /// source.lang.swift.syntaxtype.identifier
        public static let identifier: SourceLangSwiftSyntaxtype = "source.lang.swift.syntaxtype.identifier"
        /// source.lang.swift.syntaxtype.keyword
        public static let keyword: SourceLangSwiftSyntaxtype = "source.lang.swift.syntaxtype.keyword"
        /// source.lang.swift.syntaxtype.number
        public static let number: SourceLangSwiftSyntaxtype = "source.lang.swift.syntaxtype.number"
        /// source.lang.swift.syntaxtype.objectliteral
        public static let objectliteral: SourceLangSwiftSyntaxtype = "source.lang.swift.syntaxtype.objectliteral"
        /// source.lang.swift.syntaxtype.parameter
        public static let parameter: SourceLangSwiftSyntaxtype = "source.lang.swift.syntaxtype.parameter"
        /// source.lang.swift.syntaxtype.placeholder
        public static let placeholder: SourceLangSwiftSyntaxtype = "source.lang.swift.syntaxtype.placeholder"
        /// source.lang.swift.syntaxtype.string
        public static let string: SourceLangSwiftSyntaxtype = "source.lang.swift.syntaxtype.string"
        /// source.lang.swift.syntaxtype.string_interpolation_anchor
        public static let string_interpolation_anchor: SourceLangSwiftSyntaxtype = "source.lang.swift.syntaxtype.string_interpolation_anchor"
        /// source.lang.swift.syntaxtype.typeidentifier
        public static let typeidentifier: SourceLangSwiftSyntaxtype = "source.lang.swift.syntaxtype.typeidentifier"
    }
    public struct SourceNotification {
        public let uid: UID
        /// source.notification.editor.documentupdate
        public static let editorDocumentupdate: SourceNotification = "source.notification.editor.documentupdate"
        /// source.notification.sema_disabled
        public static let sema_disabled: SourceNotification = "source.notification.sema_disabled"
    }
    public struct SourceRequest {
        public let uid: UID
        /// source.request.buildsettings.register
        public static let buildsettingsRegister: SourceRequest = "source.request.buildsettings.register"
        /// source.request.codecomplete
        public static let codecomplete: SourceRequest = "source.request.codecomplete"
        /// source.request.codecomplete.cache.ondisk
        public static let codecompleteCacheOndisk: SourceRequest = "source.request.codecomplete.cache.ondisk"
        /// source.request.codecomplete.close
        public static let codecompleteClose: SourceRequest = "source.request.codecomplete.close"
        /// source.request.codecomplete.open
        public static let codecompleteOpen: SourceRequest = "source.request.codecomplete.open"
        /// source.request.codecomplete.setcustom
        public static let codecompleteSetcustom: SourceRequest = "source.request.codecomplete.setcustom"
        /// source.request.codecomplete.setpopularapi
        public static let codecompleteSetpopularapi: SourceRequest = "source.request.codecomplete.setpopularapi"
        /// source.request.codecomplete.update
        public static let codecompleteUpdate: SourceRequest = "source.request.codecomplete.update"
        /// source.request.crash_exit
        public static let crash_exit: SourceRequest = "source.request.crash_exit"
        /// source.request.cursorinfo
        public static let cursorinfo: SourceRequest = "source.request.cursorinfo"
        /// source.request.demangle
        public static let demangle: SourceRequest = "source.request.demangle"
        /// source.request.docinfo
        public static let docinfo: SourceRequest = "source.request.docinfo"
        /// source.request.editor.close
        public static let editorClose: SourceRequest = "source.request.editor.close"
        /// source.request.editor.expand_placeholder
        public static let editorExpand_Placeholder: SourceRequest = "source.request.editor.expand_placeholder"
        /// source.request.editor.extract.comment
        public static let editorExtractComment: SourceRequest = "source.request.editor.extract.comment"
        /// source.request.editor.find_interface_doc
        public static let editorFind_Interface_Doc: SourceRequest = "source.request.editor.find_interface_doc"
        /// source.request.editor.find_usr
        public static let editorFind_Usr: SourceRequest = "source.request.editor.find_usr"
        /// source.request.editor.formattext
        public static let editorFormattext: SourceRequest = "source.request.editor.formattext"
        /// source.request.editor.open
        public static let editorOpen: SourceRequest = "source.request.editor.open"
        /// source.request.editor.open.interface
        public static let editorOpenInterface: SourceRequest = "source.request.editor.open.interface"
        /// source.request.editor.open.interface.header
        public static let editorOpenInterfaceHeader: SourceRequest = "source.request.editor.open.interface.header"
        /// source.request.editor.open.interface.swiftsource
        public static let editorOpenInterfaceSwiftsource: SourceRequest = "source.request.editor.open.interface.swiftsource"
        /// source.request.editor.open.interface.swifttype
        public static let editorOpenInterfaceSwifttype: SourceRequest = "source.request.editor.open.interface.swifttype"
        /// source.request.editor.replacetext
        public static let editorReplacetext: SourceRequest = "source.request.editor.replacetext"
        /// source.request.indexsource
        public static let indexsource: SourceRequest = "source.request.indexsource"
        /// source.request.mangle_simple_class
        public static let mangle_simple_class: SourceRequest = "source.request.mangle_simple_class"
        /// source.request.module.groups
        public static let moduleGroups: SourceRequest = "source.request.module.groups"
        /// source.request.protocol_version
        public static let protocol_version: SourceRequest = "source.request.protocol_version"
        /// source.request.rangeinfo
        public static let rangeinfo: SourceRequest = "source.request.rangeinfo"
        /// source.request.relatedidents
        public static let relatedidents: SourceRequest = "source.request.relatedidents"
    }
}

extension UID.Key: UIDNamespace {
    public static let __uid_prefix = "key"
    public static func == (lhs: UID.Key, rhs: UID.Key) -> Bool { return lhs.uid == rhs.uid }
    public static func != (lhs: UID.Key, rhs: UID.Key) -> Bool { return lhs.uid != rhs.uid }
    public static func == (lhs: UID, rhs: UID.Key) -> Bool { return lhs == rhs.uid }
    public static func != (lhs: UID, rhs: UID.Key) -> Bool { return lhs != rhs.uid }
    public static func == (lhs: UID.Key, rhs: UID) -> Bool { return lhs.uid == rhs }
    public static func != (lhs: UID.Key, rhs: UID) -> Bool { return lhs.uid != rhs }
    public static func == (lhs: UID?, rhs: UID.Key) -> Bool { return lhs.map { $0 == rhs.uid } ?? false }
    public static func != (lhs: UID?, rhs: UID.Key) -> Bool { return lhs.map { $0 != rhs.uid } ?? true }
    public static func == (lhs: UID.Key, rhs: UID?) -> Bool { return rhs.map { lhs.uid == $0 } ?? false }
    public static func != (lhs: UID.Key, rhs: UID?) -> Bool { return rhs.map { lhs.uid != $0 } ?? true }
    public init(stringLiteral value: String) { self.init(uid: type(of: self)._inferUID(from: value)) }
    public init(unicodeScalarLiteral value: String) { self.init(uid: type(of: self)._inferUID(from: value)) }
    public init(extendedGraphemeClusterLiteral value: String) { self.init(uid: type(of: self)._inferUID(from: value)) }
}
extension UID.SourceAvailabilityPlatform: UIDNamespace {
    public static let __uid_prefix = "source.availability.platform"
    public static func == (lhs: UID.SourceAvailabilityPlatform, rhs: UID.SourceAvailabilityPlatform) -> Bool { return lhs.uid == rhs.uid }
    public static func != (lhs: UID.SourceAvailabilityPlatform, rhs: UID.SourceAvailabilityPlatform) -> Bool { return lhs.uid != rhs.uid }
    public static func == (lhs: UID, rhs: UID.SourceAvailabilityPlatform) -> Bool { return lhs == rhs.uid }
    public static func != (lhs: UID, rhs: UID.SourceAvailabilityPlatform) -> Bool { return lhs != rhs.uid }
    public static func == (lhs: UID.SourceAvailabilityPlatform, rhs: UID) -> Bool { return lhs.uid == rhs }
    public static func != (lhs: UID.SourceAvailabilityPlatform, rhs: UID) -> Bool { return lhs.uid != rhs }
    public static func == (lhs: UID?, rhs: UID.SourceAvailabilityPlatform) -> Bool { return lhs.map { $0 == rhs.uid } ?? false }
    public static func != (lhs: UID?, rhs: UID.SourceAvailabilityPlatform) -> Bool { return lhs.map { $0 != rhs.uid } ?? true }
    public static func == (lhs: UID.SourceAvailabilityPlatform, rhs: UID?) -> Bool { return rhs.map { lhs.uid == $0 } ?? false }
    public static func != (lhs: UID.SourceAvailabilityPlatform, rhs: UID?) -> Bool { return rhs.map { lhs.uid != $0 } ?? true }
    public init(stringLiteral value: String) { self.init(uid: type(of: self)._inferUID(from: value)) }
    public init(unicodeScalarLiteral value: String) { self.init(uid: type(of: self)._inferUID(from: value)) }
    public init(extendedGraphemeClusterLiteral value: String) { self.init(uid: type(of: self)._inferUID(from: value)) }
}
extension UID.SourceCodecompletion: UIDNamespace {
    public static let __uid_prefix = "source.codecompletion"
    public static func == (lhs: UID.SourceCodecompletion, rhs: UID.SourceCodecompletion) -> Bool { return lhs.uid == rhs.uid }
    public static func != (lhs: UID.SourceCodecompletion, rhs: UID.SourceCodecompletion) -> Bool { return lhs.uid != rhs.uid }
    public static func == (lhs: UID, rhs: UID.SourceCodecompletion) -> Bool { return lhs == rhs.uid }
    public static func != (lhs: UID, rhs: UID.SourceCodecompletion) -> Bool { return lhs != rhs.uid }
    public static func == (lhs: UID.SourceCodecompletion, rhs: UID) -> Bool { return lhs.uid == rhs }
    public static func != (lhs: UID.SourceCodecompletion, rhs: UID) -> Bool { return lhs.uid != rhs }
    public static func == (lhs: UID?, rhs: UID.SourceCodecompletion) -> Bool { return lhs.map { $0 == rhs.uid } ?? false }
    public static func != (lhs: UID?, rhs: UID.SourceCodecompletion) -> Bool { return lhs.map { $0 != rhs.uid } ?? true }
    public static func == (lhs: UID.SourceCodecompletion, rhs: UID?) -> Bool { return rhs.map { lhs.uid == $0 } ?? false }
    public static func != (lhs: UID.SourceCodecompletion, rhs: UID?) -> Bool { return rhs.map { lhs.uid != $0 } ?? true }
    public init(stringLiteral value: String) { self.init(uid: type(of: self)._inferUID(from: value)) }
    public init(unicodeScalarLiteral value: String) { self.init(uid: type(of: self)._inferUID(from: value)) }
    public init(extendedGraphemeClusterLiteral value: String) { self.init(uid: type(of: self)._inferUID(from: value)) }
}
extension UID.SourceDeclAttribute: UIDNamespace {
    public static let __uid_prefix = "source.decl.attribute"
    public static func == (lhs: UID.SourceDeclAttribute, rhs: UID.SourceDeclAttribute) -> Bool { return lhs.uid == rhs.uid }
    public static func != (lhs: UID.SourceDeclAttribute, rhs: UID.SourceDeclAttribute) -> Bool { return lhs.uid != rhs.uid }
    public static func == (lhs: UID, rhs: UID.SourceDeclAttribute) -> Bool { return lhs == rhs.uid }
    public static func != (lhs: UID, rhs: UID.SourceDeclAttribute) -> Bool { return lhs != rhs.uid }
    public static func == (lhs: UID.SourceDeclAttribute, rhs: UID) -> Bool { return lhs.uid == rhs }
    public static func != (lhs: UID.SourceDeclAttribute, rhs: UID) -> Bool { return lhs.uid != rhs }
    public static func == (lhs: UID?, rhs: UID.SourceDeclAttribute) -> Bool { return lhs.map { $0 == rhs.uid } ?? false }
    public static func != (lhs: UID?, rhs: UID.SourceDeclAttribute) -> Bool { return lhs.map { $0 != rhs.uid } ?? true }
    public static func == (lhs: UID.SourceDeclAttribute, rhs: UID?) -> Bool { return rhs.map { lhs.uid == $0 } ?? false }
    public static func != (lhs: UID.SourceDeclAttribute, rhs: UID?) -> Bool { return rhs.map { lhs.uid != $0 } ?? true }
    public init(stringLiteral value: String) { self.init(uid: type(of: self)._inferUID(from: value)) }
    public init(unicodeScalarLiteral value: String) { self.init(uid: type(of: self)._inferUID(from: value)) }
    public init(extendedGraphemeClusterLiteral value: String) { self.init(uid: type(of: self)._inferUID(from: value)) }
}
extension UID.SourceDiagnosticSeverity: UIDNamespace {
    public static let __uid_prefix = "source.diagnostic.severity"
    public static func == (lhs: UID.SourceDiagnosticSeverity, rhs: UID.SourceDiagnosticSeverity) -> Bool { return lhs.uid == rhs.uid }
    public static func != (lhs: UID.SourceDiagnosticSeverity, rhs: UID.SourceDiagnosticSeverity) -> Bool { return lhs.uid != rhs.uid }
    public static func == (lhs: UID, rhs: UID.SourceDiagnosticSeverity) -> Bool { return lhs == rhs.uid }
    public static func != (lhs: UID, rhs: UID.SourceDiagnosticSeverity) -> Bool { return lhs != rhs.uid }
    public static func == (lhs: UID.SourceDiagnosticSeverity, rhs: UID) -> Bool { return lhs.uid == rhs }
    public static func != (lhs: UID.SourceDiagnosticSeverity, rhs: UID) -> Bool { return lhs.uid != rhs }
    public static func == (lhs: UID?, rhs: UID.SourceDiagnosticSeverity) -> Bool { return lhs.map { $0 == rhs.uid } ?? false }
    public static func != (lhs: UID?, rhs: UID.SourceDiagnosticSeverity) -> Bool { return lhs.map { $0 != rhs.uid } ?? true }
    public static func == (lhs: UID.SourceDiagnosticSeverity, rhs: UID?) -> Bool { return rhs.map { lhs.uid == $0 } ?? false }
    public static func != (lhs: UID.SourceDiagnosticSeverity, rhs: UID?) -> Bool { return rhs.map { lhs.uid != $0 } ?? true }
    public init(stringLiteral value: String) { self.init(uid: type(of: self)._inferUID(from: value)) }
    public init(unicodeScalarLiteral value: String) { self.init(uid: type(of: self)._inferUID(from: value)) }
    public init(extendedGraphemeClusterLiteral value: String) { self.init(uid: type(of: self)._inferUID(from: value)) }
}
extension UID.SourceDiagnosticStageSwift: UIDNamespace {
    public static let __uid_prefix = "source.diagnostic.stage.swift"
    public static func == (lhs: UID.SourceDiagnosticStageSwift, rhs: UID.SourceDiagnosticStageSwift) -> Bool { return lhs.uid == rhs.uid }
    public static func != (lhs: UID.SourceDiagnosticStageSwift, rhs: UID.SourceDiagnosticStageSwift) -> Bool { return lhs.uid != rhs.uid }
    public static func == (lhs: UID, rhs: UID.SourceDiagnosticStageSwift) -> Bool { return lhs == rhs.uid }
    public static func != (lhs: UID, rhs: UID.SourceDiagnosticStageSwift) -> Bool { return lhs != rhs.uid }
    public static func == (lhs: UID.SourceDiagnosticStageSwift, rhs: UID) -> Bool { return lhs.uid == rhs }
    public static func != (lhs: UID.SourceDiagnosticStageSwift, rhs: UID) -> Bool { return lhs.uid != rhs }
    public static func == (lhs: UID?, rhs: UID.SourceDiagnosticStageSwift) -> Bool { return lhs.map { $0 == rhs.uid } ?? false }
    public static func != (lhs: UID?, rhs: UID.SourceDiagnosticStageSwift) -> Bool { return lhs.map { $0 != rhs.uid } ?? true }
    public static func == (lhs: UID.SourceDiagnosticStageSwift, rhs: UID?) -> Bool { return rhs.map { lhs.uid == $0 } ?? false }
    public static func != (lhs: UID.SourceDiagnosticStageSwift, rhs: UID?) -> Bool { return rhs.map { lhs.uid != $0 } ?? true }
    public init(stringLiteral value: String) { self.init(uid: type(of: self)._inferUID(from: value)) }
    public init(unicodeScalarLiteral value: String) { self.init(uid: type(of: self)._inferUID(from: value)) }
    public init(extendedGraphemeClusterLiteral value: String) { self.init(uid: type(of: self)._inferUID(from: value)) }
}
extension UID.SourceLangSwift: UIDNamespace {
    public static let __uid_prefix = "source.lang.swift"
    public static func == (lhs: UID.SourceLangSwift, rhs: UID.SourceLangSwift) -> Bool { return lhs.uid == rhs.uid }
    public static func != (lhs: UID.SourceLangSwift, rhs: UID.SourceLangSwift) -> Bool { return lhs.uid != rhs.uid }
    public static func == (lhs: UID, rhs: UID.SourceLangSwift) -> Bool { return lhs == rhs.uid }
    public static func != (lhs: UID, rhs: UID.SourceLangSwift) -> Bool { return lhs != rhs.uid }
    public static func == (lhs: UID.SourceLangSwift, rhs: UID) -> Bool { return lhs.uid == rhs }
    public static func != (lhs: UID.SourceLangSwift, rhs: UID) -> Bool { return lhs.uid != rhs }
    public static func == (lhs: UID?, rhs: UID.SourceLangSwift) -> Bool { return lhs.map { $0 == rhs.uid } ?? false }
    public static func != (lhs: UID?, rhs: UID.SourceLangSwift) -> Bool { return lhs.map { $0 != rhs.uid } ?? true }
    public static func == (lhs: UID.SourceLangSwift, rhs: UID?) -> Bool { return rhs.map { lhs.uid == $0 } ?? false }
    public static func != (lhs: UID.SourceLangSwift, rhs: UID?) -> Bool { return rhs.map { lhs.uid != $0 } ?? true }
    public init(stringLiteral value: String) { self.init(uid: type(of: self)._inferUID(from: value)) }
    public init(unicodeScalarLiteral value: String) { self.init(uid: type(of: self)._inferUID(from: value)) }
    public init(extendedGraphemeClusterLiteral value: String) { self.init(uid: type(of: self)._inferUID(from: value)) }
}
extension UID.SourceLangSwiftAccessibility: UIDNamespace {
    public static let __uid_prefix = "source.lang.swift.accessibility"
    public static func == (lhs: UID.SourceLangSwiftAccessibility, rhs: UID.SourceLangSwiftAccessibility) -> Bool { return lhs.uid == rhs.uid }
    public static func != (lhs: UID.SourceLangSwiftAccessibility, rhs: UID.SourceLangSwiftAccessibility) -> Bool { return lhs.uid != rhs.uid }
    public static func == (lhs: UID, rhs: UID.SourceLangSwiftAccessibility) -> Bool { return lhs == rhs.uid }
    public static func != (lhs: UID, rhs: UID.SourceLangSwiftAccessibility) -> Bool { return lhs != rhs.uid }
    public static func == (lhs: UID.SourceLangSwiftAccessibility, rhs: UID) -> Bool { return lhs.uid == rhs }
    public static func != (lhs: UID.SourceLangSwiftAccessibility, rhs: UID) -> Bool { return lhs.uid != rhs }
    public static func == (lhs: UID?, rhs: UID.SourceLangSwiftAccessibility) -> Bool { return lhs.map { $0 == rhs.uid } ?? false }
    public static func != (lhs: UID?, rhs: UID.SourceLangSwiftAccessibility) -> Bool { return lhs.map { $0 != rhs.uid } ?? true }
    public static func == (lhs: UID.SourceLangSwiftAccessibility, rhs: UID?) -> Bool { return rhs.map { lhs.uid == $0 } ?? false }
    public static func != (lhs: UID.SourceLangSwiftAccessibility, rhs: UID?) -> Bool { return rhs.map { lhs.uid != $0 } ?? true }
    public init(stringLiteral value: String) { self.init(uid: type(of: self)._inferUID(from: value)) }
    public init(unicodeScalarLiteral value: String) { self.init(uid: type(of: self)._inferUID(from: value)) }
    public init(extendedGraphemeClusterLiteral value: String) { self.init(uid: type(of: self)._inferUID(from: value)) }
}
extension UID.SourceLangSwiftAttribute: UIDNamespace {
    public static let __uid_prefix = "source.lang.swift.attribute"
    public static func == (lhs: UID.SourceLangSwiftAttribute, rhs: UID.SourceLangSwiftAttribute) -> Bool { return lhs.uid == rhs.uid }
    public static func != (lhs: UID.SourceLangSwiftAttribute, rhs: UID.SourceLangSwiftAttribute) -> Bool { return lhs.uid != rhs.uid }
    public static func == (lhs: UID, rhs: UID.SourceLangSwiftAttribute) -> Bool { return lhs == rhs.uid }
    public static func != (lhs: UID, rhs: UID.SourceLangSwiftAttribute) -> Bool { return lhs != rhs.uid }
    public static func == (lhs: UID.SourceLangSwiftAttribute, rhs: UID) -> Bool { return lhs.uid == rhs }
    public static func != (lhs: UID.SourceLangSwiftAttribute, rhs: UID) -> Bool { return lhs.uid != rhs }
    public static func == (lhs: UID?, rhs: UID.SourceLangSwiftAttribute) -> Bool { return lhs.map { $0 == rhs.uid } ?? false }
    public static func != (lhs: UID?, rhs: UID.SourceLangSwiftAttribute) -> Bool { return lhs.map { $0 != rhs.uid } ?? true }
    public static func == (lhs: UID.SourceLangSwiftAttribute, rhs: UID?) -> Bool { return rhs.map { lhs.uid == $0 } ?? false }
    public static func != (lhs: UID.SourceLangSwiftAttribute, rhs: UID?) -> Bool { return rhs.map { lhs.uid != $0 } ?? true }
    public init(stringLiteral value: String) { self.init(uid: type(of: self)._inferUID(from: value)) }
    public init(unicodeScalarLiteral value: String) { self.init(uid: type(of: self)._inferUID(from: value)) }
    public init(extendedGraphemeClusterLiteral value: String) { self.init(uid: type(of: self)._inferUID(from: value)) }
}
extension UID.SourceLangSwiftCodecomplete: UIDNamespace {
    public static let __uid_prefix = "source.lang.swift.codecomplete"
    public static func == (lhs: UID.SourceLangSwiftCodecomplete, rhs: UID.SourceLangSwiftCodecomplete) -> Bool { return lhs.uid == rhs.uid }
    public static func != (lhs: UID.SourceLangSwiftCodecomplete, rhs: UID.SourceLangSwiftCodecomplete) -> Bool { return lhs.uid != rhs.uid }
    public static func == (lhs: UID, rhs: UID.SourceLangSwiftCodecomplete) -> Bool { return lhs == rhs.uid }
    public static func != (lhs: UID, rhs: UID.SourceLangSwiftCodecomplete) -> Bool { return lhs != rhs.uid }
    public static func == (lhs: UID.SourceLangSwiftCodecomplete, rhs: UID) -> Bool { return lhs.uid == rhs }
    public static func != (lhs: UID.SourceLangSwiftCodecomplete, rhs: UID) -> Bool { return lhs.uid != rhs }
    public static func == (lhs: UID?, rhs: UID.SourceLangSwiftCodecomplete) -> Bool { return lhs.map { $0 == rhs.uid } ?? false }
    public static func != (lhs: UID?, rhs: UID.SourceLangSwiftCodecomplete) -> Bool { return lhs.map { $0 != rhs.uid } ?? true }
    public static func == (lhs: UID.SourceLangSwiftCodecomplete, rhs: UID?) -> Bool { return rhs.map { lhs.uid == $0 } ?? false }
    public static func != (lhs: UID.SourceLangSwiftCodecomplete, rhs: UID?) -> Bool { return rhs.map { lhs.uid != $0 } ?? true }
    public init(stringLiteral value: String) { self.init(uid: type(of: self)._inferUID(from: value)) }
    public init(unicodeScalarLiteral value: String) { self.init(uid: type(of: self)._inferUID(from: value)) }
    public init(extendedGraphemeClusterLiteral value: String) { self.init(uid: type(of: self)._inferUID(from: value)) }
}
extension UID.SourceLangSwiftDecl: UIDNamespace {
    public static let __uid_prefix = "source.lang.swift.decl"
    public static func == (lhs: UID.SourceLangSwiftDecl, rhs: UID.SourceLangSwiftDecl) -> Bool { return lhs.uid == rhs.uid }
    public static func != (lhs: UID.SourceLangSwiftDecl, rhs: UID.SourceLangSwiftDecl) -> Bool { return lhs.uid != rhs.uid }
    public static func == (lhs: UID, rhs: UID.SourceLangSwiftDecl) -> Bool { return lhs == rhs.uid }
    public static func != (lhs: UID, rhs: UID.SourceLangSwiftDecl) -> Bool { return lhs != rhs.uid }
    public static func == (lhs: UID.SourceLangSwiftDecl, rhs: UID) -> Bool { return lhs.uid == rhs }
    public static func != (lhs: UID.SourceLangSwiftDecl, rhs: UID) -> Bool { return lhs.uid != rhs }
    public static func == (lhs: UID?, rhs: UID.SourceLangSwiftDecl) -> Bool { return lhs.map { $0 == rhs.uid } ?? false }
    public static func != (lhs: UID?, rhs: UID.SourceLangSwiftDecl) -> Bool { return lhs.map { $0 != rhs.uid } ?? true }
    public static func == (lhs: UID.SourceLangSwiftDecl, rhs: UID?) -> Bool { return rhs.map { lhs.uid == $0 } ?? false }
    public static func != (lhs: UID.SourceLangSwiftDecl, rhs: UID?) -> Bool { return rhs.map { lhs.uid != $0 } ?? true }
    public init(stringLiteral value: String) { self.init(uid: type(of: self)._inferUID(from: value)) }
    public init(unicodeScalarLiteral value: String) { self.init(uid: type(of: self)._inferUID(from: value)) }
    public init(extendedGraphemeClusterLiteral value: String) { self.init(uid: type(of: self)._inferUID(from: value)) }
}
extension UID.SourceLangSwiftExpr: UIDNamespace {
    public static let __uid_prefix = "source.lang.swift.expr"
    public static func == (lhs: UID.SourceLangSwiftExpr, rhs: UID.SourceLangSwiftExpr) -> Bool { return lhs.uid == rhs.uid }
    public static func != (lhs: UID.SourceLangSwiftExpr, rhs: UID.SourceLangSwiftExpr) -> Bool { return lhs.uid != rhs.uid }
    public static func == (lhs: UID, rhs: UID.SourceLangSwiftExpr) -> Bool { return lhs == rhs.uid }
    public static func != (lhs: UID, rhs: UID.SourceLangSwiftExpr) -> Bool { return lhs != rhs.uid }
    public static func == (lhs: UID.SourceLangSwiftExpr, rhs: UID) -> Bool { return lhs.uid == rhs }
    public static func != (lhs: UID.SourceLangSwiftExpr, rhs: UID) -> Bool { return lhs.uid != rhs }
    public static func == (lhs: UID?, rhs: UID.SourceLangSwiftExpr) -> Bool { return lhs.map { $0 == rhs.uid } ?? false }
    public static func != (lhs: UID?, rhs: UID.SourceLangSwiftExpr) -> Bool { return lhs.map { $0 != rhs.uid } ?? true }
    public static func == (lhs: UID.SourceLangSwiftExpr, rhs: UID?) -> Bool { return rhs.map { lhs.uid == $0 } ?? false }
    public static func != (lhs: UID.SourceLangSwiftExpr, rhs: UID?) -> Bool { return rhs.map { lhs.uid != $0 } ?? true }
    public init(stringLiteral value: String) { self.init(uid: type(of: self)._inferUID(from: value)) }
    public init(unicodeScalarLiteral value: String) { self.init(uid: type(of: self)._inferUID(from: value)) }
    public init(extendedGraphemeClusterLiteral value: String) { self.init(uid: type(of: self)._inferUID(from: value)) }
}
extension UID.SourceLangSwiftImportModule: UIDNamespace {
    public static let __uid_prefix = "source.lang.swift.import.module"
    public static func == (lhs: UID.SourceLangSwiftImportModule, rhs: UID.SourceLangSwiftImportModule) -> Bool { return lhs.uid == rhs.uid }
    public static func != (lhs: UID.SourceLangSwiftImportModule, rhs: UID.SourceLangSwiftImportModule) -> Bool { return lhs.uid != rhs.uid }
    public static func == (lhs: UID, rhs: UID.SourceLangSwiftImportModule) -> Bool { return lhs == rhs.uid }
    public static func != (lhs: UID, rhs: UID.SourceLangSwiftImportModule) -> Bool { return lhs != rhs.uid }
    public static func == (lhs: UID.SourceLangSwiftImportModule, rhs: UID) -> Bool { return lhs.uid == rhs }
    public static func != (lhs: UID.SourceLangSwiftImportModule, rhs: UID) -> Bool { return lhs.uid != rhs }
    public static func == (lhs: UID?, rhs: UID.SourceLangSwiftImportModule) -> Bool { return lhs.map { $0 == rhs.uid } ?? false }
    public static func != (lhs: UID?, rhs: UID.SourceLangSwiftImportModule) -> Bool { return lhs.map { $0 != rhs.uid } ?? true }
    public static func == (lhs: UID.SourceLangSwiftImportModule, rhs: UID?) -> Bool { return rhs.map { lhs.uid == $0 } ?? false }
    public static func != (lhs: UID.SourceLangSwiftImportModule, rhs: UID?) -> Bool { return rhs.map { lhs.uid != $0 } ?? true }
    public init(stringLiteral value: String) { self.init(uid: type(of: self)._inferUID(from: value)) }
    public init(unicodeScalarLiteral value: String) { self.init(uid: type(of: self)._inferUID(from: value)) }
    public init(extendedGraphemeClusterLiteral value: String) { self.init(uid: type(of: self)._inferUID(from: value)) }
}
extension UID.SourceLangSwiftKeyword: UIDNamespace {
    public static let __uid_prefix = "source.lang.swift.keyword"
    public static func == (lhs: UID.SourceLangSwiftKeyword, rhs: UID.SourceLangSwiftKeyword) -> Bool { return lhs.uid == rhs.uid }
    public static func != (lhs: UID.SourceLangSwiftKeyword, rhs: UID.SourceLangSwiftKeyword) -> Bool { return lhs.uid != rhs.uid }
    public static func == (lhs: UID, rhs: UID.SourceLangSwiftKeyword) -> Bool { return lhs == rhs.uid }
    public static func != (lhs: UID, rhs: UID.SourceLangSwiftKeyword) -> Bool { return lhs != rhs.uid }
    public static func == (lhs: UID.SourceLangSwiftKeyword, rhs: UID) -> Bool { return lhs.uid == rhs }
    public static func != (lhs: UID.SourceLangSwiftKeyword, rhs: UID) -> Bool { return lhs.uid != rhs }
    public static func == (lhs: UID?, rhs: UID.SourceLangSwiftKeyword) -> Bool { return lhs.map { $0 == rhs.uid } ?? false }
    public static func != (lhs: UID?, rhs: UID.SourceLangSwiftKeyword) -> Bool { return lhs.map { $0 != rhs.uid } ?? true }
    public static func == (lhs: UID.SourceLangSwiftKeyword, rhs: UID?) -> Bool { return rhs.map { lhs.uid == $0 } ?? false }
    public static func != (lhs: UID.SourceLangSwiftKeyword, rhs: UID?) -> Bool { return rhs.map { lhs.uid != $0 } ?? true }
    public init(stringLiteral value: String) { self.init(uid: type(of: self)._inferUID(from: value)) }
    public init(unicodeScalarLiteral value: String) { self.init(uid: type(of: self)._inferUID(from: value)) }
    public init(extendedGraphemeClusterLiteral value: String) { self.init(uid: type(of: self)._inferUID(from: value)) }
}
extension UID.SourceLangSwiftLiteral: UIDNamespace {
    public static let __uid_prefix = "source.lang.swift.literal"
    public static func == (lhs: UID.SourceLangSwiftLiteral, rhs: UID.SourceLangSwiftLiteral) -> Bool { return lhs.uid == rhs.uid }
    public static func != (lhs: UID.SourceLangSwiftLiteral, rhs: UID.SourceLangSwiftLiteral) -> Bool { return lhs.uid != rhs.uid }
    public static func == (lhs: UID, rhs: UID.SourceLangSwiftLiteral) -> Bool { return lhs == rhs.uid }
    public static func != (lhs: UID, rhs: UID.SourceLangSwiftLiteral) -> Bool { return lhs != rhs.uid }
    public static func == (lhs: UID.SourceLangSwiftLiteral, rhs: UID) -> Bool { return lhs.uid == rhs }
    public static func != (lhs: UID.SourceLangSwiftLiteral, rhs: UID) -> Bool { return lhs.uid != rhs }
    public static func == (lhs: UID?, rhs: UID.SourceLangSwiftLiteral) -> Bool { return lhs.map { $0 == rhs.uid } ?? false }
    public static func != (lhs: UID?, rhs: UID.SourceLangSwiftLiteral) -> Bool { return lhs.map { $0 != rhs.uid } ?? true }
    public static func == (lhs: UID.SourceLangSwiftLiteral, rhs: UID?) -> Bool { return rhs.map { lhs.uid == $0 } ?? false }
    public static func != (lhs: UID.SourceLangSwiftLiteral, rhs: UID?) -> Bool { return rhs.map { lhs.uid != $0 } ?? true }
    public init(stringLiteral value: String) { self.init(uid: type(of: self)._inferUID(from: value)) }
    public init(unicodeScalarLiteral value: String) { self.init(uid: type(of: self)._inferUID(from: value)) }
    public init(extendedGraphemeClusterLiteral value: String) { self.init(uid: type(of: self)._inferUID(from: value)) }
}
extension UID.SourceLangSwiftRef: UIDNamespace {
    public static let __uid_prefix = "source.lang.swift.ref"
    public static func == (lhs: UID.SourceLangSwiftRef, rhs: UID.SourceLangSwiftRef) -> Bool { return lhs.uid == rhs.uid }
    public static func != (lhs: UID.SourceLangSwiftRef, rhs: UID.SourceLangSwiftRef) -> Bool { return lhs.uid != rhs.uid }
    public static func == (lhs: UID, rhs: UID.SourceLangSwiftRef) -> Bool { return lhs == rhs.uid }
    public static func != (lhs: UID, rhs: UID.SourceLangSwiftRef) -> Bool { return lhs != rhs.uid }
    public static func == (lhs: UID.SourceLangSwiftRef, rhs: UID) -> Bool { return lhs.uid == rhs }
    public static func != (lhs: UID.SourceLangSwiftRef, rhs: UID) -> Bool { return lhs.uid != rhs }
    public static func == (lhs: UID?, rhs: UID.SourceLangSwiftRef) -> Bool { return lhs.map { $0 == rhs.uid } ?? false }
    public static func != (lhs: UID?, rhs: UID.SourceLangSwiftRef) -> Bool { return lhs.map { $0 != rhs.uid } ?? true }
    public static func == (lhs: UID.SourceLangSwiftRef, rhs: UID?) -> Bool { return rhs.map { lhs.uid == $0 } ?? false }
    public static func != (lhs: UID.SourceLangSwiftRef, rhs: UID?) -> Bool { return rhs.map { lhs.uid != $0 } ?? true }
    public init(stringLiteral value: String) { self.init(uid: type(of: self)._inferUID(from: value)) }
    public init(unicodeScalarLiteral value: String) { self.init(uid: type(of: self)._inferUID(from: value)) }
    public init(extendedGraphemeClusterLiteral value: String) { self.init(uid: type(of: self)._inferUID(from: value)) }
}
extension UID.SourceLangSwiftStmt: UIDNamespace {
    public static let __uid_prefix = "source.lang.swift.stmt"
    public static func == (lhs: UID.SourceLangSwiftStmt, rhs: UID.SourceLangSwiftStmt) -> Bool { return lhs.uid == rhs.uid }
    public static func != (lhs: UID.SourceLangSwiftStmt, rhs: UID.SourceLangSwiftStmt) -> Bool { return lhs.uid != rhs.uid }
    public static func == (lhs: UID, rhs: UID.SourceLangSwiftStmt) -> Bool { return lhs == rhs.uid }
    public static func != (lhs: UID, rhs: UID.SourceLangSwiftStmt) -> Bool { return lhs != rhs.uid }
    public static func == (lhs: UID.SourceLangSwiftStmt, rhs: UID) -> Bool { return lhs.uid == rhs }
    public static func != (lhs: UID.SourceLangSwiftStmt, rhs: UID) -> Bool { return lhs.uid != rhs }
    public static func == (lhs: UID?, rhs: UID.SourceLangSwiftStmt) -> Bool { return lhs.map { $0 == rhs.uid } ?? false }
    public static func != (lhs: UID?, rhs: UID.SourceLangSwiftStmt) -> Bool { return lhs.map { $0 != rhs.uid } ?? true }
    public static func == (lhs: UID.SourceLangSwiftStmt, rhs: UID?) -> Bool { return rhs.map { lhs.uid == $0 } ?? false }
    public static func != (lhs: UID.SourceLangSwiftStmt, rhs: UID?) -> Bool { return rhs.map { lhs.uid != $0 } ?? true }
    public init(stringLiteral value: String) { self.init(uid: type(of: self)._inferUID(from: value)) }
    public init(unicodeScalarLiteral value: String) { self.init(uid: type(of: self)._inferUID(from: value)) }
    public init(extendedGraphemeClusterLiteral value: String) { self.init(uid: type(of: self)._inferUID(from: value)) }
}
extension UID.SourceLangSwiftStructureElem: UIDNamespace {
    public static let __uid_prefix = "source.lang.swift.structure.elem"
    public static func == (lhs: UID.SourceLangSwiftStructureElem, rhs: UID.SourceLangSwiftStructureElem) -> Bool { return lhs.uid == rhs.uid }
    public static func != (lhs: UID.SourceLangSwiftStructureElem, rhs: UID.SourceLangSwiftStructureElem) -> Bool { return lhs.uid != rhs.uid }
    public static func == (lhs: UID, rhs: UID.SourceLangSwiftStructureElem) -> Bool { return lhs == rhs.uid }
    public static func != (lhs: UID, rhs: UID.SourceLangSwiftStructureElem) -> Bool { return lhs != rhs.uid }
    public static func == (lhs: UID.SourceLangSwiftStructureElem, rhs: UID) -> Bool { return lhs.uid == rhs }
    public static func != (lhs: UID.SourceLangSwiftStructureElem, rhs: UID) -> Bool { return lhs.uid != rhs }
    public static func == (lhs: UID?, rhs: UID.SourceLangSwiftStructureElem) -> Bool { return lhs.map { $0 == rhs.uid } ?? false }
    public static func != (lhs: UID?, rhs: UID.SourceLangSwiftStructureElem) -> Bool { return lhs.map { $0 != rhs.uid } ?? true }
    public static func == (lhs: UID.SourceLangSwiftStructureElem, rhs: UID?) -> Bool { return rhs.map { lhs.uid == $0 } ?? false }
    public static func != (lhs: UID.SourceLangSwiftStructureElem, rhs: UID?) -> Bool { return rhs.map { lhs.uid != $0 } ?? true }
    public init(stringLiteral value: String) { self.init(uid: type(of: self)._inferUID(from: value)) }
    public init(unicodeScalarLiteral value: String) { self.init(uid: type(of: self)._inferUID(from: value)) }
    public init(extendedGraphemeClusterLiteral value: String) { self.init(uid: type(of: self)._inferUID(from: value)) }
}
extension UID.SourceLangSwiftSyntaxtype: UIDNamespace {
    public static let __uid_prefix = "source.lang.swift.syntaxtype"
    public static func == (lhs: UID.SourceLangSwiftSyntaxtype, rhs: UID.SourceLangSwiftSyntaxtype) -> Bool { return lhs.uid == rhs.uid }
    public static func != (lhs: UID.SourceLangSwiftSyntaxtype, rhs: UID.SourceLangSwiftSyntaxtype) -> Bool { return lhs.uid != rhs.uid }
    public static func == (lhs: UID, rhs: UID.SourceLangSwiftSyntaxtype) -> Bool { return lhs == rhs.uid }
    public static func != (lhs: UID, rhs: UID.SourceLangSwiftSyntaxtype) -> Bool { return lhs != rhs.uid }
    public static func == (lhs: UID.SourceLangSwiftSyntaxtype, rhs: UID) -> Bool { return lhs.uid == rhs }
    public static func != (lhs: UID.SourceLangSwiftSyntaxtype, rhs: UID) -> Bool { return lhs.uid != rhs }
    public static func == (lhs: UID?, rhs: UID.SourceLangSwiftSyntaxtype) -> Bool { return lhs.map { $0 == rhs.uid } ?? false }
    public static func != (lhs: UID?, rhs: UID.SourceLangSwiftSyntaxtype) -> Bool { return lhs.map { $0 != rhs.uid } ?? true }
    public static func == (lhs: UID.SourceLangSwiftSyntaxtype, rhs: UID?) -> Bool { return rhs.map { lhs.uid == $0 } ?? false }
    public static func != (lhs: UID.SourceLangSwiftSyntaxtype, rhs: UID?) -> Bool { return rhs.map { lhs.uid != $0 } ?? true }
    public init(stringLiteral value: String) { self.init(uid: type(of: self)._inferUID(from: value)) }
    public init(unicodeScalarLiteral value: String) { self.init(uid: type(of: self)._inferUID(from: value)) }
    public init(extendedGraphemeClusterLiteral value: String) { self.init(uid: type(of: self)._inferUID(from: value)) }
}
extension UID.SourceNotification: UIDNamespace {
    public static let __uid_prefix = "source.notification"
    public static func == (lhs: UID.SourceNotification, rhs: UID.SourceNotification) -> Bool { return lhs.uid == rhs.uid }
    public static func != (lhs: UID.SourceNotification, rhs: UID.SourceNotification) -> Bool { return lhs.uid != rhs.uid }
    public static func == (lhs: UID, rhs: UID.SourceNotification) -> Bool { return lhs == rhs.uid }
    public static func != (lhs: UID, rhs: UID.SourceNotification) -> Bool { return lhs != rhs.uid }
    public static func == (lhs: UID.SourceNotification, rhs: UID) -> Bool { return lhs.uid == rhs }
    public static func != (lhs: UID.SourceNotification, rhs: UID) -> Bool { return lhs.uid != rhs }
    public static func == (lhs: UID?, rhs: UID.SourceNotification) -> Bool { return lhs.map { $0 == rhs.uid } ?? false }
    public static func != (lhs: UID?, rhs: UID.SourceNotification) -> Bool { return lhs.map { $0 != rhs.uid } ?? true }
    public static func == (lhs: UID.SourceNotification, rhs: UID?) -> Bool { return rhs.map { lhs.uid == $0 } ?? false }
    public static func != (lhs: UID.SourceNotification, rhs: UID?) -> Bool { return rhs.map { lhs.uid != $0 } ?? true }
    public init(stringLiteral value: String) { self.init(uid: type(of: self)._inferUID(from: value)) }
    public init(unicodeScalarLiteral value: String) { self.init(uid: type(of: self)._inferUID(from: value)) }
    public init(extendedGraphemeClusterLiteral value: String) { self.init(uid: type(of: self)._inferUID(from: value)) }
}
extension UID.SourceRequest: UIDNamespace {
    public static let __uid_prefix = "source.request"
    public static func == (lhs: UID.SourceRequest, rhs: UID.SourceRequest) -> Bool { return lhs.uid == rhs.uid }
    public static func != (lhs: UID.SourceRequest, rhs: UID.SourceRequest) -> Bool { return lhs.uid != rhs.uid }
    public static func == (lhs: UID, rhs: UID.SourceRequest) -> Bool { return lhs == rhs.uid }
    public static func != (lhs: UID, rhs: UID.SourceRequest) -> Bool { return lhs != rhs.uid }
    public static func == (lhs: UID.SourceRequest, rhs: UID) -> Bool { return lhs.uid == rhs }
    public static func != (lhs: UID.SourceRequest, rhs: UID) -> Bool { return lhs.uid != rhs }
    public static func == (lhs: UID?, rhs: UID.SourceRequest) -> Bool { return lhs.map { $0 == rhs.uid } ?? false }
    public static func != (lhs: UID?, rhs: UID.SourceRequest) -> Bool { return lhs.map { $0 != rhs.uid } ?? true }
    public static func == (lhs: UID.SourceRequest, rhs: UID?) -> Bool { return rhs.map { lhs.uid == $0 } ?? false }
    public static func != (lhs: UID.SourceRequest, rhs: UID?) -> Bool { return rhs.map { lhs.uid != $0 } ?? true }
    public init(stringLiteral value: String) { self.init(uid: type(of: self)._inferUID(from: value)) }
    public init(unicodeScalarLiteral value: String) { self.init(uid: type(of: self)._inferUID(from: value)) }
    public init(extendedGraphemeClusterLiteral value: String) { self.init(uid: type(of: self)._inferUID(from: value)) }
}
extension UID {
    public var isMemberOfKey: Bool { return knownUIDsOfKey.contains(self) }
    public var isMemberOfSourceAvailabilityPlatform: Bool { return knownUIDsOfSourceAvailabilityPlatform.contains(self) }
    public var isMemberOfSourceCodecompletion: Bool { return knownUIDsOfSourceCodecompletion.contains(self) }
    public var isMemberOfSourceDeclAttribute: Bool { return knownUIDsOfSourceDeclAttribute.contains(self) }
    public var isMemberOfSourceDiagnosticSeverity: Bool { return knownUIDsOfSourceDiagnosticSeverity.contains(self) }
    public var isMemberOfSourceDiagnosticStageSwift: Bool { return knownUIDsOfSourceDiagnosticStageSwift.contains(self) }
    public var isMemberOfSourceLangSwift: Bool { return knownUIDsOfSourceLangSwift.contains(self) }
    public var isMemberOfSourceLangSwiftAccessibility: Bool { return knownUIDsOfSourceLangSwiftAccessibility.contains(self) }
    public var isMemberOfSourceLangSwiftAttribute: Bool { return knownUIDsOfSourceLangSwiftAttribute.contains(self) }
    public var isMemberOfSourceLangSwiftCodecomplete: Bool { return knownUIDsOfSourceLangSwiftCodecomplete.contains(self) }
    public var isMemberOfSourceLangSwiftDecl: Bool { return knownUIDsOfSourceLangSwiftDecl.contains(self) }
    public var isMemberOfSourceLangSwiftExpr: Bool { return knownUIDsOfSourceLangSwiftExpr.contains(self) }
    public var isMemberOfSourceLangSwiftImportModule: Bool { return knownUIDsOfSourceLangSwiftImportModule.contains(self) }
    public var isMemberOfSourceLangSwiftKeyword: Bool { return knownUIDsOfSourceLangSwiftKeyword.contains(self) }
    public var isMemberOfSourceLangSwiftLiteral: Bool { return knownUIDsOfSourceLangSwiftLiteral.contains(self) }
    public var isMemberOfSourceLangSwiftRef: Bool { return knownUIDsOfSourceLangSwiftRef.contains(self) }
    public var isMemberOfSourceLangSwiftStmt: Bool { return knownUIDsOfSourceLangSwiftStmt.contains(self) }
    public var isMemberOfSourceLangSwiftStructureElem: Bool { return knownUIDsOfSourceLangSwiftStructureElem.contains(self) }
    public var isMemberOfSourceLangSwiftSyntaxtype: Bool { return knownUIDsOfSourceLangSwiftSyntaxtype.contains(self) }
    public var isMemberOfSourceNotification: Bool { return knownUIDsOfSourceNotification.contains(self) }
    public var isMemberOfSourceRequest: Bool { return knownUIDsOfSourceRequest.contains(self) }
}
fileprivate let knownUIDsOfKey: Set<UID> = [
    UID.Key.accessibility.uid,
    UID.Key.actionable.uid,
    UID.Key.actionname.uid,
    UID.Key.annotated_decl.uid,
    UID.Key.annotations.uid,
    UID.Key.associated_usrs.uid,
    UID.Key.attribute.uid,
    UID.Key.attributes.uid,
    UID.Key.bodylength.uid,
    UID.Key.bodyoffset.uid,
    UID.Key.codecompleteAddinitstotoplevel.uid,
    UID.Key.codecompleteAddinneroperators.uid,
    UID.Key.codecompleteAddinnerresults.uid,
    UID.Key.codecompleteFilterrules.uid,
    UID.Key.codecompleteFiltertext.uid,
    UID.Key.codecompleteFuzzymatching.uid,
    UID.Key.codecompleteGroupOverloads.uid,
    UID.Key.codecompleteGroupStems.uid,
    UID.Key.codecompleteHidebyname.uid,
    UID.Key.codecompleteHidelowpriority.uid,
    UID.Key.codecompleteHideunderscores.uid,
    UID.Key.codecompleteIncludeexactmatch.uid,
    UID.Key.codecompleteOptions.uid,
    UID.Key.codecompleteRequestlimit.uid,
    UID.Key.codecompleteRequeststart.uid,
    UID.Key.codecompleteShowtopnonliteralresults.uid,
    UID.Key.codecompleteSortByname.uid,
    UID.Key.codecompleteSortContextweight.uid,
    UID.Key.codecompleteSortFuzzyweight.uid,
    UID.Key.codecompleteSortPopularitybonus.uid,
    UID.Key.codecompleteSortUseimportdepth.uid,
    UID.Key.column.uid,
    UID.Key.compilerargs.uid,
    UID.Key.conforms.uid,
    UID.Key.containertypeusr.uid,
    UID.Key.context.uid,
    UID.Key.default_implementation_of.uid,
    UID.Key.dependencies.uid,
    UID.Key.deprecated.uid,
    UID.Key.description.uid,
    UID.Key.diagnostic_stage.uid,
    UID.Key.diagnostics.uid,
    UID.Key.docBrief.uid,
    UID.Key.docFull_As_Xml.uid,
    UID.Key.duration.uid,
    UID.Key.editorFormatIndentwidth.uid,
    UID.Key.editorFormatOptions.uid,
    UID.Key.editorFormatTabwidth.uid,
    UID.Key.editorFormatUsetabs.uid,
    UID.Key.elements.uid,
    UID.Key.enablediagnostics.uid,
    UID.Key.enablesubstructure.uid,
    UID.Key.enablesyntaxmap.uid,
    UID.Key.entities.uid,
    UID.Key.extends.uid,
    UID.Key.filepath.uid,
    UID.Key.fixits.uid,
    UID.Key.fully_annotated_decl.uid,
    UID.Key.generic_params.uid,
    UID.Key.generic_requirements.uid,
    UID.Key.groupname.uid,
    UID.Key.hash.uid,
    UID.Key.hide.uid,
    UID.Key.inheritedtypes.uid,
    UID.Key.inherits.uid,
    UID.Key.interested_usr.uid,
    UID.Key.introduced.uid,
    UID.Key.is_deprecated.uid,
    UID.Key.is_dynamic.uid,
    UID.Key.is_local.uid,
    UID.Key.is_optional.uid,
    UID.Key.is_system.uid,
    UID.Key.is_test_candidate.uid,
    UID.Key.is_unavailable.uid,
    UID.Key.keyword.uid,
    UID.Key.kind.uid,
    UID.Key.length.uid,
    UID.Key.line.uid,
    UID.Key.message.uid,
    UID.Key.module_interface_name.uid,
    UID.Key.modulegroups.uid,
    UID.Key.moduleimportdepth.uid,
    UID.Key.modulename.uid,
    UID.Key.name.uid,
    UID.Key.namelength.uid,
    UID.Key.nameoffset.uid,
    UID.Key.names.uid,
    UID.Key.nextrequeststart.uid,
    UID.Key.not_recommended.uid,
    UID.Key.notification.uid,
    UID.Key.num_bytes_to_erase.uid,
    UID.Key.obsoleted.uid,
    UID.Key.offset.uid,
    UID.Key.original_usr.uid,
    UID.Key.overrides.uid,
    UID.Key.platform.uid,
    UID.Key.popular.uid,
    UID.Key.rangecontent.uid,
    UID.Key.ranges.uid,
    UID.Key.receiver_usr.uid,
    UID.Key.related.uid,
    UID.Key.related_decls.uid,
    UID.Key.removecache.uid,
    UID.Key.request.uid,
    UID.Key.results.uid,
    UID.Key.runtime_name.uid,
    UID.Key.selector_name.uid,
    UID.Key.setter_accessibility.uid,
    UID.Key.severity.uid,
    UID.Key.simplified.uid,
    UID.Key.sourcefile.uid,
    UID.Key.sourcetext.uid,
    UID.Key.substructure.uid,
    UID.Key.syntactic_only.uid,
    UID.Key.syntaxmap.uid,
    UID.Key.synthesizedextensions.uid,
    UID.Key.throwlength.uid,
    UID.Key.throwoffset.uid,
    UID.Key.typeinterface.uid,
    UID.Key.typename.uid,
    UID.Key.typeusr.uid,
    UID.Key.uids.uid,
    UID.Key.unpopular.uid,
    UID.Key.usr.uid,
    UID.Key.version_major.uid,
    UID.Key.version_minor.uid,
]
fileprivate let knownUIDsOfSourceAvailabilityPlatform: Set<UID> = [
    UID.SourceAvailabilityPlatform.ios.uid,
    UID.SourceAvailabilityPlatform.ios_app_extension.uid,
    UID.SourceAvailabilityPlatform.osx.uid,
    UID.SourceAvailabilityPlatform.osx_app_extension.uid,
    UID.SourceAvailabilityPlatform.tvos.uid,
    UID.SourceAvailabilityPlatform.tvos_app_extension.uid,
    UID.SourceAvailabilityPlatform.watchos.uid,
    UID.SourceAvailabilityPlatform.watchos_app_extension.uid,
]
fileprivate let knownUIDsOfSourceCodecompletion: Set<UID> = [
    UID.SourceCodecompletion.contextExprspecific.uid,
    UID.SourceCodecompletion.contextLocal.uid,
    UID.SourceCodecompletion.contextNone.uid,
    UID.SourceCodecompletion.contextOtherclass.uid,
    UID.SourceCodecompletion.contextOthermodule.uid,
    UID.SourceCodecompletion.contextSuperclass.uid,
    UID.SourceCodecompletion.contextThisclass.uid,
    UID.SourceCodecompletion.contextThismodule.uid,
    UID.SourceCodecompletion.custom.uid,
    UID.SourceCodecompletion.everything.uid,
    UID.SourceCodecompletion.identifier.uid,
    UID.SourceCodecompletion.keyword.uid,
    UID.SourceCodecompletion.literal.uid,
    UID.SourceCodecompletion.module.uid,
]
fileprivate let knownUIDsOfSourceDeclAttribute: Set<UID> = [
    UID.SourceDeclAttribute.LLDBDebuggerFunction.uid,
    UID.SourceDeclAttribute.NSApplicationMain.uid,
    UID.SourceDeclAttribute.NSCopying.uid,
    UID.SourceDeclAttribute.NSManaged.uid,
    UID.SourceDeclAttribute.UIApplicationMain.uid,
    UID.SourceDeclAttribute.__objc_bridged.uid,
    UID.SourceDeclAttribute.__synthesized_protocol.uid,
    UID.SourceDeclAttribute._alignment.uid,
    UID.SourceDeclAttribute._cdecl.uid,
    UID.SourceDeclAttribute._exported.uid,
    UID.SourceDeclAttribute._fixed_layout.uid,
    UID.SourceDeclAttribute._inlineable.uid,
    UID.SourceDeclAttribute._semantics.uid,
    UID.SourceDeclAttribute._silgen_name.uid,
    UID.SourceDeclAttribute._specialize.uid,
    UID.SourceDeclAttribute._swift_native_objc_runtime_base.uid,
    UID.SourceDeclAttribute._transparent.uid,
    UID.SourceDeclAttribute._versioned.uid,
    UID.SourceDeclAttribute.autoclosure.uid,
    UID.SourceDeclAttribute.available.uid,
    UID.SourceDeclAttribute.convenience.uid,
    UID.SourceDeclAttribute.discardableResult.uid,
    UID.SourceDeclAttribute.dynamic.uid,
    UID.SourceDeclAttribute.effects.uid,
    UID.SourceDeclAttribute.final.uid,
    UID.SourceDeclAttribute.gkinspectable.uid,
    UID.SourceDeclAttribute.ibaction.uid,
    UID.SourceDeclAttribute.ibdesignable.uid,
    UID.SourceDeclAttribute.ibinspectable.uid,
    UID.SourceDeclAttribute.iboutlet.uid,
    UID.SourceDeclAttribute.indirect.uid,
    UID.SourceDeclAttribute.infix.uid,
    UID.SourceDeclAttribute.inline.uid,
    UID.SourceDeclAttribute.lazy.uid,
    UID.SourceDeclAttribute.mutating.uid,
    UID.SourceDeclAttribute.noescape.uid,
    UID.SourceDeclAttribute.nonmutating.uid,
    UID.SourceDeclAttribute.nonobjc.uid,
    UID.SourceDeclAttribute.noreturn.uid,
    UID.SourceDeclAttribute.objc.uid,
    UID.SourceDeclAttribute.objcName.uid,
    UID.SourceDeclAttribute.objc_non_lazy_realization.uid,
    UID.SourceDeclAttribute.optional.uid,
    UID.SourceDeclAttribute.override.uid,
    UID.SourceDeclAttribute.postfix.uid,
    UID.SourceDeclAttribute.prefix.uid,
    UID.SourceDeclAttribute.required.uid,
    UID.SourceDeclAttribute.requires_stored_property_inits.uid,
    UID.SourceDeclAttribute.`rethrows`.uid,
    UID.SourceDeclAttribute.sil_stored.uid,
    UID.SourceDeclAttribute.testable.uid,
    UID.SourceDeclAttribute.unsafe_no_objc_tagged_pointer.uid,
    UID.SourceDeclAttribute.warn_unqualified_access.uid,
    UID.SourceDeclAttribute.weak.uid,
]
fileprivate let knownUIDsOfSourceDiagnosticSeverity: Set<UID> = [
    UID.SourceDiagnosticSeverity.error.uid,
    UID.SourceDiagnosticSeverity.note.uid,
    UID.SourceDiagnosticSeverity.warning.uid,
]
fileprivate let knownUIDsOfSourceDiagnosticStageSwift: Set<UID> = [
    UID.SourceDiagnosticStageSwift.parse.uid,
    UID.SourceDiagnosticStageSwift.sema.uid,
]
fileprivate let knownUIDsOfSourceLangSwift: Set<UID> = [
    UID.SourceLangSwift.expr.uid,
    UID.SourceLangSwift.keyword.uid,
    UID.SourceLangSwift.pattern.uid,
    UID.SourceLangSwift.rangeInvalid.uid,
    UID.SourceLangSwift.rangeMultistatement.uid,
    UID.SourceLangSwift.rangeSingledeclaration.uid,
    UID.SourceLangSwift.rangeSingleexpression.uid,
    UID.SourceLangSwift.rangeSinglestatement.uid,
    UID.SourceLangSwift.stmt.uid,
    UID.SourceLangSwift.type.uid,
]
fileprivate let knownUIDsOfSourceLangSwiftAccessibility: Set<UID> = [
    UID.SourceLangSwiftAccessibility.`fileprivate`.uid,
    UID.SourceLangSwiftAccessibility.`internal`.uid,
    UID.SourceLangSwiftAccessibility.open.uid,
    UID.SourceLangSwiftAccessibility.`private`.uid,
    UID.SourceLangSwiftAccessibility.`public`.uid,
]
fileprivate let knownUIDsOfSourceLangSwiftAttribute: Set<UID> = [
    UID.SourceLangSwiftAttribute.availability.uid,
]
fileprivate let knownUIDsOfSourceLangSwiftCodecomplete: Set<UID> = [
    UID.SourceLangSwiftCodecomplete.group.uid,
]
fileprivate let knownUIDsOfSourceLangSwiftDecl: Set<UID> = [
    UID.SourceLangSwiftDecl.`associatedtype`.uid,
    UID.SourceLangSwiftDecl.`class`.uid,
    UID.SourceLangSwiftDecl.`enum`.uid,
    UID.SourceLangSwiftDecl.enumcase.uid,
    UID.SourceLangSwiftDecl.enumelement.uid,
    UID.SourceLangSwiftDecl.`extension`.uid,
    UID.SourceLangSwiftDecl.extensionClass.uid,
    UID.SourceLangSwiftDecl.extensionEnum.uid,
    UID.SourceLangSwiftDecl.extensionProtocol.uid,
    UID.SourceLangSwiftDecl.extensionStruct.uid,
    UID.SourceLangSwiftDecl.functionAccessorAddress.uid,
    UID.SourceLangSwiftDecl.functionAccessorDidset.uid,
    UID.SourceLangSwiftDecl.functionAccessorGetter.uid,
    UID.SourceLangSwiftDecl.functionAccessorMutableaddress.uid,
    UID.SourceLangSwiftDecl.functionAccessorSetter.uid,
    UID.SourceLangSwiftDecl.functionAccessorWillset.uid,
    UID.SourceLangSwiftDecl.functionConstructor.uid,
    UID.SourceLangSwiftDecl.functionDestructor.uid,
    UID.SourceLangSwiftDecl.functionFree.uid,
    UID.SourceLangSwiftDecl.functionMethodClass.uid,
    UID.SourceLangSwiftDecl.functionMethodInstance.uid,
    UID.SourceLangSwiftDecl.functionMethodStatic.uid,
    UID.SourceLangSwiftDecl.functionOperatorInfix.uid,
    UID.SourceLangSwiftDecl.functionOperatorPostfix.uid,
    UID.SourceLangSwiftDecl.functionOperatorPrefix.uid,
    UID.SourceLangSwiftDecl.functionSubscript.uid,
    UID.SourceLangSwiftDecl.generic_type_param.uid,
    UID.SourceLangSwiftDecl.module.uid,
    UID.SourceLangSwiftDecl.`precedencegroup`.uid,
    UID.SourceLangSwiftDecl.`protocol`.uid,
    UID.SourceLangSwiftDecl.`struct`.uid,
    UID.SourceLangSwiftDecl.`typealias`.uid,
    UID.SourceLangSwiftDecl.varClass.uid,
    UID.SourceLangSwiftDecl.varGlobal.uid,
    UID.SourceLangSwiftDecl.varInstance.uid,
    UID.SourceLangSwiftDecl.varLocal.uid,
    UID.SourceLangSwiftDecl.varParameter.uid,
    UID.SourceLangSwiftDecl.varStatic.uid,
]
fileprivate let knownUIDsOfSourceLangSwiftExpr: Set<UID> = [
    UID.SourceLangSwiftExpr.argument.uid,
    UID.SourceLangSwiftExpr.array.uid,
    UID.SourceLangSwiftExpr.call.uid,
    UID.SourceLangSwiftExpr.dictionary.uid,
    UID.SourceLangSwiftExpr.object_literal.uid,
]
fileprivate let knownUIDsOfSourceLangSwiftImportModule: Set<UID> = [
    UID.SourceLangSwiftImportModule.clang.uid,
    UID.SourceLangSwiftImportModule.swift.uid,
]
fileprivate let knownUIDsOfSourceLangSwiftKeyword: Set<UID> = [
    UID.SourceLangSwiftKeyword.`Any`.uid,
    UID.SourceLangSwiftKeyword.`Self`.uid,
    UID.SourceLangSwiftKeyword.`_`.uid,
    UID.SourceLangSwiftKeyword.`__COLUMN__`.uid,
    UID.SourceLangSwiftKeyword.`__DSO_HANDLE__`.uid,
    UID.SourceLangSwiftKeyword.`__FILE__`.uid,
    UID.SourceLangSwiftKeyword.`__FUNCTION__`.uid,
    UID.SourceLangSwiftKeyword.`__LINE__`.uid,
    UID.SourceLangSwiftKeyword.`as`.uid,
    UID.SourceLangSwiftKeyword.`associatedtype`.uid,
    UID.SourceLangSwiftKeyword.`break`.uid,
    UID.SourceLangSwiftKeyword.`case`.uid,
    UID.SourceLangSwiftKeyword.`catch`.uid,
    UID.SourceLangSwiftKeyword.`class`.uid,
    UID.SourceLangSwiftKeyword.`continue`.uid,
    UID.SourceLangSwiftKeyword.`default`.uid,
    UID.SourceLangSwiftKeyword.`defer`.uid,
    UID.SourceLangSwiftKeyword.`deinit`.uid,
    UID.SourceLangSwiftKeyword.`do`.uid,
    UID.SourceLangSwiftKeyword.`else`.uid,
    UID.SourceLangSwiftKeyword.`enum`.uid,
    UID.SourceLangSwiftKeyword.`extension`.uid,
    UID.SourceLangSwiftKeyword.`fallthrough`.uid,
    UID.SourceLangSwiftKeyword.`false`.uid,
    UID.SourceLangSwiftKeyword.`fileprivate`.uid,
    UID.SourceLangSwiftKeyword.`for`.uid,
    UID.SourceLangSwiftKeyword.`func`.uid,
    UID.SourceLangSwiftKeyword.`guard`.uid,
    UID.SourceLangSwiftKeyword.`if`.uid,
    UID.SourceLangSwiftKeyword.`import`.uid,
    UID.SourceLangSwiftKeyword.`in`.uid,
    UID.SourceLangSwiftKeyword.`init`.uid,
    UID.SourceLangSwiftKeyword.`inout`.uid,
    UID.SourceLangSwiftKeyword.`internal`.uid,
    UID.SourceLangSwiftKeyword.`is`.uid,
    UID.SourceLangSwiftKeyword.`let`.uid,
    UID.SourceLangSwiftKeyword.`nil`.uid,
    UID.SourceLangSwiftKeyword.`operator`.uid,
    UID.SourceLangSwiftKeyword.`precedencegroup`.uid,
    UID.SourceLangSwiftKeyword.`private`.uid,
    UID.SourceLangSwiftKeyword.`protocol`.uid,
    UID.SourceLangSwiftKeyword.`public`.uid,
    UID.SourceLangSwiftKeyword.`repeat`.uid,
    UID.SourceLangSwiftKeyword.`rethrows`.uid,
    UID.SourceLangSwiftKeyword.`return`.uid,
    UID.SourceLangSwiftKeyword.`self`.uid,
    UID.SourceLangSwiftKeyword.`static`.uid,
    UID.SourceLangSwiftKeyword.`struct`.uid,
    UID.SourceLangSwiftKeyword.`subscript`.uid,
    UID.SourceLangSwiftKeyword.`super`.uid,
    UID.SourceLangSwiftKeyword.`switch`.uid,
    UID.SourceLangSwiftKeyword.`throw`.uid,
    UID.SourceLangSwiftKeyword.`throws`.uid,
    UID.SourceLangSwiftKeyword.`true`.uid,
    UID.SourceLangSwiftKeyword.`try`.uid,
    UID.SourceLangSwiftKeyword.`typealias`.uid,
    UID.SourceLangSwiftKeyword.`var`.uid,
    UID.SourceLangSwiftKeyword.`where`.uid,
    UID.SourceLangSwiftKeyword.`while`.uid,
]
fileprivate let knownUIDsOfSourceLangSwiftLiteral: Set<UID> = [
    UID.SourceLangSwiftLiteral.array.uid,
    UID.SourceLangSwiftLiteral.boolean.uid,
    UID.SourceLangSwiftLiteral.color.uid,
    UID.SourceLangSwiftLiteral.dictionary.uid,
    UID.SourceLangSwiftLiteral.image.uid,
    UID.SourceLangSwiftLiteral.integer.uid,
    UID.SourceLangSwiftLiteral.`nil`.uid,
    UID.SourceLangSwiftLiteral.string.uid,
    UID.SourceLangSwiftLiteral.tuple.uid,
]
fileprivate let knownUIDsOfSourceLangSwiftRef: Set<UID> = [
    UID.SourceLangSwiftRef.`associatedtype`.uid,
    UID.SourceLangSwiftRef.`class`.uid,
    UID.SourceLangSwiftRef.`enum`.uid,
    UID.SourceLangSwiftRef.enumelement.uid,
    UID.SourceLangSwiftRef.functionAccessorAddress.uid,
    UID.SourceLangSwiftRef.functionAccessorDidset.uid,
    UID.SourceLangSwiftRef.functionAccessorGetter.uid,
    UID.SourceLangSwiftRef.functionAccessorMutableaddress.uid,
    UID.SourceLangSwiftRef.functionAccessorSetter.uid,
    UID.SourceLangSwiftRef.functionAccessorWillset.uid,
    UID.SourceLangSwiftRef.functionConstructor.uid,
    UID.SourceLangSwiftRef.functionDestructor.uid,
    UID.SourceLangSwiftRef.functionFree.uid,
    UID.SourceLangSwiftRef.functionMethodClass.uid,
    UID.SourceLangSwiftRef.functionMethodInstance.uid,
    UID.SourceLangSwiftRef.functionMethodStatic.uid,
    UID.SourceLangSwiftRef.functionOperatorInfix.uid,
    UID.SourceLangSwiftRef.functionOperatorPostfix.uid,
    UID.SourceLangSwiftRef.functionOperatorPrefix.uid,
    UID.SourceLangSwiftRef.functionSubscript.uid,
    UID.SourceLangSwiftRef.generic_type_param.uid,
    UID.SourceLangSwiftRef.module.uid,
    UID.SourceLangSwiftRef.`precedencegroup`.uid,
    UID.SourceLangSwiftRef.`protocol`.uid,
    UID.SourceLangSwiftRef.`struct`.uid,
    UID.SourceLangSwiftRef.`typealias`.uid,
    UID.SourceLangSwiftRef.varClass.uid,
    UID.SourceLangSwiftRef.varGlobal.uid,
    UID.SourceLangSwiftRef.varInstance.uid,
    UID.SourceLangSwiftRef.varLocal.uid,
    UID.SourceLangSwiftRef.varStatic.uid,
]
fileprivate let knownUIDsOfSourceLangSwiftStmt: Set<UID> = [
    UID.SourceLangSwiftStmt.brace.uid,
    UID.SourceLangSwiftStmt.`case`.uid,
    UID.SourceLangSwiftStmt.`for`.uid,
    UID.SourceLangSwiftStmt.foreach.uid,
    UID.SourceLangSwiftStmt.`guard`.uid,
    UID.SourceLangSwiftStmt.`if`.uid,
    UID.SourceLangSwiftStmt.repeatwhile.uid,
    UID.SourceLangSwiftStmt.`switch`.uid,
    UID.SourceLangSwiftStmt.`while`.uid,
]
fileprivate let knownUIDsOfSourceLangSwiftStructureElem: Set<UID> = [
    UID.SourceLangSwiftStructureElem.condition_expr.uid,
    UID.SourceLangSwiftStructureElem.expr.uid,
    UID.SourceLangSwiftStructureElem.id.uid,
    UID.SourceLangSwiftStructureElem.init_expr.uid,
    UID.SourceLangSwiftStructureElem.pattern.uid,
    UID.SourceLangSwiftStructureElem.typeref.uid,
]
fileprivate let knownUIDsOfSourceLangSwiftSyntaxtype: Set<UID> = [
    UID.SourceLangSwiftSyntaxtype.argument.uid,
    UID.SourceLangSwiftSyntaxtype.attributeBuiltin.uid,
    UID.SourceLangSwiftSyntaxtype.attributeId.uid,
    UID.SourceLangSwiftSyntaxtype.buildconfigId.uid,
    UID.SourceLangSwiftSyntaxtype.buildconfigKeyword.uid,
    UID.SourceLangSwiftSyntaxtype.comment.uid,
    UID.SourceLangSwiftSyntaxtype.commentMark.uid,
    UID.SourceLangSwiftSyntaxtype.commentUrl.uid,
    UID.SourceLangSwiftSyntaxtype.doccomment.uid,
    UID.SourceLangSwiftSyntaxtype.doccommentField.uid,
    UID.SourceLangSwiftSyntaxtype.identifier.uid,
    UID.SourceLangSwiftSyntaxtype.keyword.uid,
    UID.SourceLangSwiftSyntaxtype.number.uid,
    UID.SourceLangSwiftSyntaxtype.objectliteral.uid,
    UID.SourceLangSwiftSyntaxtype.parameter.uid,
    UID.SourceLangSwiftSyntaxtype.placeholder.uid,
    UID.SourceLangSwiftSyntaxtype.string.uid,
    UID.SourceLangSwiftSyntaxtype.string_interpolation_anchor.uid,
    UID.SourceLangSwiftSyntaxtype.typeidentifier.uid,
]
fileprivate let knownUIDsOfSourceNotification: Set<UID> = [
    UID.SourceNotification.editorDocumentupdate.uid,
    UID.SourceNotification.sema_disabled.uid,
]
fileprivate let knownUIDsOfSourceRequest: Set<UID> = [
    UID.SourceRequest.buildsettingsRegister.uid,
    UID.SourceRequest.codecomplete.uid,
    UID.SourceRequest.codecompleteCacheOndisk.uid,
    UID.SourceRequest.codecompleteClose.uid,
    UID.SourceRequest.codecompleteOpen.uid,
    UID.SourceRequest.codecompleteSetcustom.uid,
    UID.SourceRequest.codecompleteSetpopularapi.uid,
    UID.SourceRequest.codecompleteUpdate.uid,
    UID.SourceRequest.crash_exit.uid,
    UID.SourceRequest.cursorinfo.uid,
    UID.SourceRequest.demangle.uid,
    UID.SourceRequest.docinfo.uid,
    UID.SourceRequest.editorClose.uid,
    UID.SourceRequest.editorExpand_Placeholder.uid,
    UID.SourceRequest.editorExtractComment.uid,
    UID.SourceRequest.editorFind_Interface_Doc.uid,
    UID.SourceRequest.editorFind_Usr.uid,
    UID.SourceRequest.editorFormattext.uid,
    UID.SourceRequest.editorOpen.uid,
    UID.SourceRequest.editorOpenInterface.uid,
    UID.SourceRequest.editorOpenInterfaceHeader.uid,
    UID.SourceRequest.editorOpenInterfaceSwiftsource.uid,
    UID.SourceRequest.editorOpenInterfaceSwifttype.uid,
    UID.SourceRequest.editorReplacetext.uid,
    UID.SourceRequest.indexsource.uid,
    UID.SourceRequest.mangle_simple_class.uid,
    UID.SourceRequest.moduleGroups.uid,
    UID.SourceRequest.protocol_version.uid,
    UID.SourceRequest.rangeinfo.uid,
    UID.SourceRequest.relatedidents.uid,
]
let knownUIDsSets: [Set<UID>] = [
    knownUIDsOfKey,
    knownUIDsOfSourceAvailabilityPlatform,
    knownUIDsOfSourceCodecompletion,
    knownUIDsOfSourceDeclAttribute,
    knownUIDsOfSourceDiagnosticSeverity,
    knownUIDsOfSourceDiagnosticStageSwift,
    knownUIDsOfSourceLangSwift,
    knownUIDsOfSourceLangSwiftAccessibility,
    knownUIDsOfSourceLangSwiftAttribute,
    knownUIDsOfSourceLangSwiftCodecomplete,
    knownUIDsOfSourceLangSwiftDecl,
    knownUIDsOfSourceLangSwiftExpr,
    knownUIDsOfSourceLangSwiftImportModule,
    knownUIDsOfSourceLangSwiftKeyword,
    knownUIDsOfSourceLangSwiftLiteral,
    knownUIDsOfSourceLangSwiftRef,
    knownUIDsOfSourceLangSwiftStmt,
    knownUIDsOfSourceLangSwiftStructureElem,
    knownUIDsOfSourceLangSwiftSyntaxtype,
    knownUIDsOfSourceNotification,
    knownUIDsOfSourceRequest,
    knownUIDsOfCustomKey,
]
