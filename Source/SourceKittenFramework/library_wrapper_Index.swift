// this file is generated by `convert_generated_interface_to_wrapper.py`
#if SWIFT_PACKAGE
import Clang_C
#endif
private let library = toolchainLoader.load("libclang.dylib")
// swiftlint:disable file_length
// swiftlint:disable force_unwrapping
// swiftlint:disable function_parameter_count
// swiftlint:disable missing_docs
// swiftlint:disable trailing_newline
// swiftlint:disable variable_name
// swiftlint:disable valid_docs

/*===-- clang-c/Index.h - Indexing Public C Interface -------------*- C -*-===*\
|*                                                                            *|
|*                     The LLVM Compiler Infrastructure                       *|
|*                                                                            *|
|* This file is distributed under the University of Illinois Open Source      *|
|* License. See LICENSE.TXT for details.                                      *|
|*                                                                            *|
|*===----------------------------------------------------------------------===*|
|*                                                                            *|
|* This header provides a public inferface to a Clang library for extracting  *|
|* high-level symbol information from source files without exposing the full  *|
|* Clang C++ API.                                                             *|
|*                                                                            *|
\*===----------------------------------------------------------------------===*/

/**
 * \brief The version constants for the libclang API.
 * CINDEX_VERSION_MINOR should increase when there are API additions.
 * CINDEX_VERSION_MAJOR is intended for "major" source/ABI breaking changes.
 *
 * The policy about the libclang API was always to keep it source and ABI
 * compatible, thus CINDEX_VERSION_MAJOR is expected to remain stable.
 */
// public var CINDEX_VERSION_MAJOR: Int32 { get }
// public var CINDEX_VERSION_MINOR: Int32 { get }

/** \defgroup CINDEX libclang: C Interface to Clang
 *
 * The C Interface to Clang provides a relatively small API that exposes
 * facilities for parsing source code into an abstract syntax tree (AST),
 * loading already-parsed ASTs, traversing the AST, associating
 * physical source locations with elements within the AST, and other
 * facilities that support Clang-based development tools.
 *
 * This C interface to Clang will never provide all of the information
 * representation stored in Clang's C++ AST, nor should it: the intent is to
 * maintain an API that is relatively stable from one release to the next,
 * providing only the basic functionality needed to support development tools.
 *
 * To avoid namespace pollution, data types are prefixed with "CX" and
 * functions are prefixed with "clang_".
 *
 * @{
 */

/**
 * \brief An "index" that consists of a set of translation units that would
 * typically be linked together into an executable or library.
 */
// public typealias CXIndex = UnsafeMutablePointer<Void>

/**
 * \brief A single translation unit, which resides in an index.
 */
// public typealias CXTranslationUnit = COpaquePointer

/**
 * \brief Opaque pointer representing client data that will be passed through
 * to various callbacks and visitors.
 */
// public typealias CXClientData = UnsafeMutablePointer<Void>

/**
 * \brief Provides the contents of a file that has not yet been saved to disk.
 *
 * Each CXUnsavedFile instance provides the name of a file on the
 * system along with the current contents of that file that have not
 * yet been saved to disk.
 */
/*
public struct CXUnsavedFile {
    /**
     * \brief The file whose contents have not yet been saved.
     *
     * This file must already exist in the file system.
     */
    public var Filename: UnsafePointer<Int8>
    
    /**
     * \brief A buffer containing the unsaved contents of this file.
     */
    public var Contents: UnsafePointer<Int8>
    
    /**
     * \brief The length of the unsaved contents of this buffer.
     */
    public var Length: UInt
    public init()
    public init(Filename: UnsafePointer<Int8>, Contents: UnsafePointer<Int8>, Length: UInt)
}
*/

/**
 * \brief Describes the availability of a particular entity, which indicates
 * whether the use of this entity will result in a warning or error due to
 * it being deprecated or unavailable.
 */
/*
public struct CXAvailabilityKind : RawRepresentable, Equatable {
    public init(_ rawValue: UInt32)
    public init(rawValue: UInt32)
    public var rawValue: UInt32
}
*/

/**
 * \brief The entity is available.
 */
// public var CXAvailability_Available: CXAvailabilityKind { get }
/**
 * \brief The entity is available, but has been deprecated (and its use is
 * not recommended).
 */
// public var CXAvailability_Deprecated: CXAvailabilityKind { get }
/**
 * \brief The entity is not available; any use of it will be an error.
 */
// public var CXAvailability_NotAvailable: CXAvailabilityKind { get }
/**
 * \brief The entity is available, but not accessible; any use of it will be
 * an error.
 */
// public var CXAvailability_NotAccessible: CXAvailabilityKind { get }

/**
 * \brief Describes a version number of the form major.minor.subminor.
 */
/*
public struct CXVersion {
    /**
     * \brief The major version number, e.g., the '10' in '10.7.3'. A negative
     * value indicates that there is no version number at all.
     */
    public var Major: Int32
    /**
     * \brief The minor version number, e.g., the '7' in '10.7.3'. This value
     * will be negative if no minor version number was provided, e.g., for 
     * version '10'.
     */
    public var Minor: Int32
    /**
     * \brief The subminor version number, e.g., the '3' in '10.7.3'. This value
     * will be negative if no minor or subminor version number was provided,
     * e.g., in version '10' or '10.7'.
     */
    public var Subminor: Int32
    public init()
    public init(Major: Int32, Minor: Int32, Subminor: Int32)
}
*/

/**
 * \brief Provides a shared context for creating translation units.
 *
 * It provides two options:
 *
 * - excludeDeclarationsFromPCH: When non-zero, allows enumeration of "local"
 * declarations (when loading any new translation units). A "local" declaration
 * is one that belongs in the translation unit itself and not in a precompiled
 * header that was used by the translation unit. If zero, all declarations
 * will be enumerated.
 *
 * Here is an example:
 *
 * \code
 *   // excludeDeclsFromPCH = 1, displayDiagnostics=1
 *   Idx = clang_createIndex(1, 1);
 *
 *   // IndexTest.pch was produced with the following command:
 *   // "clang -x c IndexTest.h -emit-ast -o IndexTest.pch"
 *   TU = clang_createTranslationUnit(Idx, "IndexTest.pch");
 *
 *   // This will load all the symbols from 'IndexTest.pch'
 *   clang_visitChildren(clang_getTranslationUnitCursor(TU),
 *                       TranslationUnitVisitor, 0);
 *   clang_disposeTranslationUnit(TU);
 *
 *   // This will load all the symbols from 'IndexTest.c', excluding symbols
 *   // from 'IndexTest.pch'.
 *   char *args[] = { "-Xclang", "-include-pch=IndexTest.pch" };
 *   TU = clang_createTranslationUnitFromSourceFile(Idx, "IndexTest.c", 2, args,
 *                                                  0, 0);
 *   clang_visitChildren(clang_getTranslationUnitCursor(TU),
 *                       TranslationUnitVisitor, 0);
 *   clang_disposeTranslationUnit(TU);
 * \endcode
 *
 * This process of creating the 'pch', loading it separately, and using it (via
 * -include-pch) allows 'excludeDeclsFromPCH' to remove redundant callbacks
 * (which gives the indexer the same performance benefit as the compiler).
 */
public func clang_createIndex(excludeDeclarationsFromPCH: Int32, _ displayDiagnostics: Int32) -> CXIndex {
    return _clang_createIndex(excludeDeclarationsFromPCH: excludeDeclarationsFromPCH, displayDiagnostics: displayDiagnostics)
}
private let _clang_createIndex: @convention(c) (excludeDeclarationsFromPCH: Int32, displayDiagnostics: Int32) -> CXIndex = library.loadSymbol("clang_createIndex")


/**
 * \brief Destroy the given index.
 *
 * The index must not be destroyed until all of the translation units created
 * within that index have been destroyed.
 */
public func clang_disposeIndex(index: CXIndex) {
    return _clang_disposeIndex(index: index)
}
private let _clang_disposeIndex: @convention(c) (index: CXIndex) -> () = library.loadSymbol("clang_disposeIndex")


/*
public struct CXGlobalOptFlags : RawRepresentable, Equatable {
    public init(_ rawValue: UInt32)
    public init(rawValue: UInt32)
    public var rawValue: UInt32
}
*/

/**
 * \brief Used to indicate that no special CXIndex options are needed.
 */
// public var CXGlobalOpt_None: CXGlobalOptFlags { get }

/**
 * \brief Used to indicate that threads that libclang creates for indexing
 * purposes should use background priority.
 *
 * Affects #clang_indexSourceFile, #clang_indexTranslationUnit,
 * #clang_parseTranslationUnit, #clang_saveTranslationUnit.
 */
// public var CXGlobalOpt_ThreadBackgroundPriorityForIndexing: CXGlobalOptFlags { get }

/**
 * \brief Used to indicate that threads that libclang creates for editing
 * purposes should use background priority.
 *
 * Affects #clang_reparseTranslationUnit, #clang_codeCompleteAt,
 * #clang_annotateTokens
 */
// public var CXGlobalOpt_ThreadBackgroundPriorityForEditing: CXGlobalOptFlags { get }

/**
 * \brief Used to indicate that all threads that libclang creates should use
 * background priority.
 */
// public var CXGlobalOpt_ThreadBackgroundPriorityForAll: CXGlobalOptFlags { get }

/**
 * \brief Sets general options associated with a CXIndex.
 *
 * For example:
 * \code
 * CXIndex idx = ...;
 * clang_CXIndex_setGlobalOptions(idx,
 *     clang_CXIndex_getGlobalOptions(idx) |
 *     CXGlobalOpt_ThreadBackgroundPriorityForIndexing);
 * \endcode
 *
 * \param options A bitmask of options, a bitwise OR of CXGlobalOpt_XXX flags.
 */
public func clang_CXIndex_setGlobalOptions(unnamed1: CXIndex, _ options: UInt32) {
    return _clang_CXIndex_setGlobalOptions(unnamed1, options: options)
}
private let _clang_CXIndex_setGlobalOptions: @convention(c) (_: CXIndex, options: UInt32) -> () = library.loadSymbol("clang_CXIndex_setGlobalOptions")


/**
 * \brief Gets the general options associated with a CXIndex.
 *
 * \returns A bitmask of options, a bitwise OR of CXGlobalOpt_XXX flags that
 * are associated with the given CXIndex object.
 */
public func clang_CXIndex_getGlobalOptions(unnamed1: CXIndex) -> UInt32 {
    return _clang_CXIndex_getGlobalOptions(unnamed1)
}
private let _clang_CXIndex_getGlobalOptions: @convention(c) (_: CXIndex) -> UInt32 = library.loadSymbol("clang_CXIndex_getGlobalOptions")


/**
 * \defgroup CINDEX_FILES File manipulation routines
 *
 * @{
 */

/**
 * \brief A particular source file that is part of a translation unit.
 */
// public typealias CXFile = UnsafeMutablePointer<Void>

/**
 * \brief Retrieve the complete file and path name of the given file.
 */
public func clang_getFileName(SFile: CXFile) -> CXString {
    return _clang_getFileName(SFile: SFile)
}
private let _clang_getFileName: @convention(c) (SFile: CXFile) -> CXString = library.loadSymbol("clang_getFileName")


/**
 * \brief Retrieve the last modification time of the given file.
 */
public func clang_getFileTime(SFile: CXFile) -> time_t {
    return _clang_getFileTime(SFile: SFile)
}
private let _clang_getFileTime: @convention(c) (SFile: CXFile) -> time_t = library.loadSymbol("clang_getFileTime")


/**
 * \brief Uniquely identifies a CXFile, that refers to the same underlying file,
 * across an indexing session.
 */
/*
public struct CXFileUniqueID {
    public var data: (UInt64, UInt64, UInt64)
    public init()
    public init(data: (UInt64, UInt64, UInt64))
}
*/

/**
 * \brief Retrieve the unique ID for the given \c file.
 *
 * \param file the file to get the ID for.
 * \param outID stores the returned CXFileUniqueID.
 * \returns If there was a failure getting the unique ID, returns non-zero,
 * otherwise returns 0.
*/
public func clang_getFileUniqueID(file: CXFile, _ outID: UnsafeMutablePointer<CXFileUniqueID>) -> Int32 {
    return _clang_getFileUniqueID(file: file, outID: outID)
}
private let _clang_getFileUniqueID: @convention(c) (file: CXFile, outID: UnsafeMutablePointer<CXFileUniqueID>) -> Int32 = library.loadSymbol("clang_getFileUniqueID")


/**
 * \brief Determine whether the given header is guarded against
 * multiple inclusions, either with the conventional
 * \#ifndef/\#define/\#endif macro guards or with \#pragma once.
 */
public func clang_isFileMultipleIncludeGuarded(tu: CXTranslationUnit, _ file: CXFile) -> UInt32 {
    return _clang_isFileMultipleIncludeGuarded(tu: tu, file: file)
}
private let _clang_isFileMultipleIncludeGuarded: @convention(c) (tu: CXTranslationUnit, file: CXFile) -> UInt32 = library.loadSymbol("clang_isFileMultipleIncludeGuarded")


/**
 * \brief Retrieve a file handle within the given translation unit.
 *
 * \param tu the translation unit
 *
 * \param file_name the name of the file.
 *
 * \returns the file handle for the named file in the translation unit \p tu,
 * or a NULL file handle if the file was not a part of this translation unit.
 */
public func clang_getFile(tu: CXTranslationUnit, _ file_name: UnsafePointer<Int8>) -> CXFile {
    return _clang_getFile(tu: tu, file_name: file_name)
}
private let _clang_getFile: @convention(c) (tu: CXTranslationUnit, file_name: UnsafePointer<Int8>) -> CXFile = library.loadSymbol("clang_getFile")


/**
 * \brief Returns non-zero if the \c file1 and \c file2 point to the same file,
 * or they are both NULL.
 */
public func clang_File_isEqual(file1: CXFile, _ file2: CXFile) -> Int32 {
    return _clang_File_isEqual(file1: file1, file2: file2)
}
private let _clang_File_isEqual: @convention(c) (file1: CXFile, file2: CXFile) -> Int32 = library.loadSymbol("clang_File_isEqual")


/**
 * @}
 */

/**
 * \defgroup CINDEX_LOCATIONS Physical source locations
 *
 * Clang represents physical source locations in its abstract syntax tree in
 * great detail, with file, line, and column information for the majority of
 * the tokens parsed in the source code. These data types and functions are
 * used to represent source location information, either for a particular
 * point in the program or for a range of points in the program, and extract
 * specific location information from those data types.
 *
 * @{
 */

/**
 * \brief Identifies a specific source location within a translation
 * unit.
 *
 * Use clang_getExpansionLocation() or clang_getSpellingLocation()
 * to map a source location to a particular file, line, and column.
 */
/*
public struct CXSourceLocation {
    public var ptr_data: (UnsafePointer<Void>, UnsafePointer<Void>)
    public var int_data: UInt32
    public init()
    public init(ptr_data: (UnsafePointer<Void>, UnsafePointer<Void>), int_data: UInt32)
}
*/

/**
 * \brief Identifies a half-open character range in the source code.
 *
 * Use clang_getRangeStart() and clang_getRangeEnd() to retrieve the
 * starting and end locations from a source range, respectively.
 */
/*
public struct CXSourceRange {
    public var ptr_data: (UnsafePointer<Void>, UnsafePointer<Void>)
    public var begin_int_data: UInt32
    public var end_int_data: UInt32
    public init()
    public init(ptr_data: (UnsafePointer<Void>, UnsafePointer<Void>), begin_int_data: UInt32, end_int_data: UInt32)
}
*/

/**
 * \brief Retrieve a NULL (invalid) source location.
 */
public func clang_getNullLocation() -> CXSourceLocation {
    return _clang_getNullLocation()
}
private let _clang_getNullLocation: @convention(c) () -> CXSourceLocation = library.loadSymbol("clang_getNullLocation")


/**
 * \brief Determine whether two source locations, which must refer into
 * the same translation unit, refer to exactly the same point in the source
 * code.
 *
 * \returns non-zero if the source locations refer to the same location, zero
 * if they refer to different locations.
 */
public func clang_equalLocations(loc1: CXSourceLocation, _ loc2: CXSourceLocation) -> UInt32 {
    return _clang_equalLocations(loc1: loc1, loc2: loc2)
}
private let _clang_equalLocations: @convention(c) (loc1: CXSourceLocation, loc2: CXSourceLocation) -> UInt32 = library.loadSymbol("clang_equalLocations")


/**
 * \brief Retrieves the source location associated with a given file/line/column
 * in a particular translation unit.
 */
public func clang_getLocation(tu: CXTranslationUnit, _ file: CXFile, _ line: UInt32, _ column: UInt32) -> CXSourceLocation {
    return _clang_getLocation(tu: tu, file: file, line: line, column: column)
}
private let _clang_getLocation: @convention(c) (tu: CXTranslationUnit, file: CXFile, line: UInt32, column: UInt32) -> CXSourceLocation = library.loadSymbol("clang_getLocation")

/**
 * \brief Retrieves the source location associated with a given character offset
 * in a particular translation unit.
 */
public func clang_getLocationForOffset(tu: CXTranslationUnit, _ file: CXFile, _ offset: UInt32) -> CXSourceLocation {
    return _clang_getLocationForOffset(tu: tu, file: file, offset: offset)
}
private let _clang_getLocationForOffset: @convention(c) (tu: CXTranslationUnit, file: CXFile, offset: UInt32) -> CXSourceLocation = library.loadSymbol("clang_getLocationForOffset")


/**
 * \brief Returns non-zero if the given source location is in a system header.
 */
public func clang_Location_isInSystemHeader(location: CXSourceLocation) -> Int32 {
    return _clang_Location_isInSystemHeader(location: location)
}
private let _clang_Location_isInSystemHeader: @convention(c) (location: CXSourceLocation) -> Int32 = library.loadSymbol("clang_Location_isInSystemHeader")


/**
 * \brief Returns non-zero if the given source location is in the main file of
 * the corresponding translation unit.
 */
public func clang_Location_isFromMainFile(location: CXSourceLocation) -> Int32 {
    return _clang_Location_isFromMainFile(location: location)
}
private let _clang_Location_isFromMainFile: @convention(c) (location: CXSourceLocation) -> Int32 = library.loadSymbol("clang_Location_isFromMainFile")


/**
 * \brief Retrieve a NULL (invalid) source range.
 */
public func clang_getNullRange() -> CXSourceRange {
    return _clang_getNullRange()
}
private let _clang_getNullRange: @convention(c) () -> CXSourceRange = library.loadSymbol("clang_getNullRange")


/**
 * \brief Retrieve a source range given the beginning and ending source
 * locations.
 */
public func clang_getRange(begin: CXSourceLocation, _ end: CXSourceLocation) -> CXSourceRange {
    return _clang_getRange(begin: begin, end: end)
}
private let _clang_getRange: @convention(c) (begin: CXSourceLocation, end: CXSourceLocation) -> CXSourceRange = library.loadSymbol("clang_getRange")


/**
 * \brief Determine whether two ranges are equivalent.
 *
 * \returns non-zero if the ranges are the same, zero if they differ.
 */
public func clang_equalRanges(range1: CXSourceRange, _ range2: CXSourceRange) -> UInt32 {
    return _clang_equalRanges(range1: range1, range2: range2)
}
private let _clang_equalRanges: @convention(c) (range1: CXSourceRange, range2: CXSourceRange) -> UInt32 = library.loadSymbol("clang_equalRanges")


/**
 * \brief Returns non-zero if \p range is null.
 */
public func clang_Range_isNull(range: CXSourceRange) -> Int32 {
    return _clang_Range_isNull(range: range)
}
private let _clang_Range_isNull: @convention(c) (range: CXSourceRange) -> Int32 = library.loadSymbol("clang_Range_isNull")


/**
 * \brief Retrieve the file, line, column, and offset represented by
 * the given source location.
 *
 * If the location refers into a macro expansion, retrieves the
 * location of the macro expansion.
 *
 * \param location the location within a source file that will be decomposed
 * into its parts.
 *
 * \param file [out] if non-NULL, will be set to the file to which the given
 * source location points.
 *
 * \param line [out] if non-NULL, will be set to the line to which the given
 * source location points.
 *
 * \param column [out] if non-NULL, will be set to the column to which the given
 * source location points.
 *
 * \param offset [out] if non-NULL, will be set to the offset into the
 * buffer to which the given source location points.
 */
public func clang_getExpansionLocation(location: CXSourceLocation, _ file: UnsafeMutablePointer<CXFile>, _ line: UnsafeMutablePointer<UInt32>, _ column: UnsafeMutablePointer<UInt32>, _ offset: UnsafeMutablePointer<UInt32>) {
    return _clang_getExpansionLocation(location: location, file: file, line: line, column: column, offset: offset)
}
private let _clang_getExpansionLocation: @convention(c) (location: CXSourceLocation, file: UnsafeMutablePointer<CXFile>, line: UnsafeMutablePointer<UInt32>, column: UnsafeMutablePointer<UInt32>, offset: UnsafeMutablePointer<UInt32>) -> () = library.loadSymbol("clang_getExpansionLocation")


/**
 * \brief Retrieve the file, line, column, and offset represented by
 * the given source location, as specified in a # line directive.
 *
 * Example: given the following source code in a file somefile.c
 *
 * \code
 * #123 "dummy.c" 1
 *
 * static int func(void)
 * {
 *     return 0;
 * }
 * \endcode
 *
 * the location information returned by this function would be
 *
 * File: dummy.c Line: 124 Column: 12
 *
 * whereas clang_getExpansionLocation would have returned
 *
 * File: somefile.c Line: 3 Column: 12
 *
 * \param location the location within a source file that will be decomposed
 * into its parts.
 *
 * \param filename [out] if non-NULL, will be set to the filename of the
 * source location. Note that filenames returned will be for "virtual" files,
 * which don't necessarily exist on the machine running clang - e.g. when
 * parsing preprocessed output obtained from a different environment. If
 * a non-NULL value is passed in, remember to dispose of the returned value
 * using \c clang_disposeString() once you've finished with it. For an invalid
 * source location, an empty string is returned.
 *
 * \param line [out] if non-NULL, will be set to the line number of the
 * source location. For an invalid source location, zero is returned.
 *
 * \param column [out] if non-NULL, will be set to the column number of the
 * source location. For an invalid source location, zero is returned.
 */
public func clang_getPresumedLocation(location: CXSourceLocation, _ filename: UnsafeMutablePointer<CXString>, _ line: UnsafeMutablePointer<UInt32>, _ column: UnsafeMutablePointer<UInt32>) {
    return _clang_getPresumedLocation(location: location, filename: filename, line: line, column: column)
}
private let _clang_getPresumedLocation: @convention(c) (location: CXSourceLocation, filename: UnsafeMutablePointer<CXString>, line: UnsafeMutablePointer<UInt32>, column: UnsafeMutablePointer<UInt32>) -> () = library.loadSymbol("clang_getPresumedLocation")


/**
 * \brief Legacy API to retrieve the file, line, column, and offset represented
 * by the given source location.
 *
 * This interface has been replaced by the newer interface
 * #clang_getExpansionLocation(). See that interface's documentation for
 * details.
 */
public func clang_getInstantiationLocation(location: CXSourceLocation, _ file: UnsafeMutablePointer<CXFile>, _ line: UnsafeMutablePointer<UInt32>, _ column: UnsafeMutablePointer<UInt32>, _ offset: UnsafeMutablePointer<UInt32>) {
    return _clang_getInstantiationLocation(location: location, file: file, line: line, column: column, offset: offset)
}
private let _clang_getInstantiationLocation: @convention(c) (location: CXSourceLocation, file: UnsafeMutablePointer<CXFile>, line: UnsafeMutablePointer<UInt32>, column: UnsafeMutablePointer<UInt32>, offset: UnsafeMutablePointer<UInt32>) -> () = library.loadSymbol("clang_getInstantiationLocation")


/**
 * \brief Retrieve the file, line, column, and offset represented by
 * the given source location.
 *
 * If the location refers into a macro instantiation, return where the
 * location was originally spelled in the source file.
 *
 * \param location the location within a source file that will be decomposed
 * into its parts.
 *
 * \param file [out] if non-NULL, will be set to the file to which the given
 * source location points.
 *
 * \param line [out] if non-NULL, will be set to the line to which the given
 * source location points.
 *
 * \param column [out] if non-NULL, will be set to the column to which the given
 * source location points.
 *
 * \param offset [out] if non-NULL, will be set to the offset into the
 * buffer to which the given source location points.
 */
public func clang_getSpellingLocation(location: CXSourceLocation, _ file: UnsafeMutablePointer<CXFile>, _ line: UnsafeMutablePointer<UInt32>, _ column: UnsafeMutablePointer<UInt32>, _ offset: UnsafeMutablePointer<UInt32>) {
    return _clang_getSpellingLocation(location: location, file: file, line: line, column: column, offset: offset)
}
private let _clang_getSpellingLocation: @convention(c) (location: CXSourceLocation, file: UnsafeMutablePointer<CXFile>, line: UnsafeMutablePointer<UInt32>, column: UnsafeMutablePointer<UInt32>, offset: UnsafeMutablePointer<UInt32>) -> () = library.loadSymbol("clang_getSpellingLocation")


/**
 * \brief Retrieve the file, line, column, and offset represented by
 * the given source location.
 *
 * If the location refers into a macro expansion, return where the macro was
 * expanded or where the macro argument was written, if the location points at
 * a macro argument.
 *
 * \param location the location within a source file that will be decomposed
 * into its parts.
 *
 * \param file [out] if non-NULL, will be set to the file to which the given
 * source location points.
 *
 * \param line [out] if non-NULL, will be set to the line to which the given
 * source location points.
 *
 * \param column [out] if non-NULL, will be set to the column to which the given
 * source location points.
 *
 * \param offset [out] if non-NULL, will be set to the offset into the
 * buffer to which the given source location points.
 */
public func clang_getFileLocation(location: CXSourceLocation, _ file: UnsafeMutablePointer<CXFile>, _ line: UnsafeMutablePointer<UInt32>, _ column: UnsafeMutablePointer<UInt32>, _ offset: UnsafeMutablePointer<UInt32>) {
    return _clang_getFileLocation(location: location, file: file, line: line, column: column, offset: offset)
}
private let _clang_getFileLocation: @convention(c) (location: CXSourceLocation, file: UnsafeMutablePointer<CXFile>, line: UnsafeMutablePointer<UInt32>, column: UnsafeMutablePointer<UInt32>, offset: UnsafeMutablePointer<UInt32>) -> () = library.loadSymbol("clang_getFileLocation")


/**
 * \brief Retrieve a source location representing the first character within a
 * source range.
 */
public func clang_getRangeStart(range: CXSourceRange) -> CXSourceLocation {
    return _clang_getRangeStart(range: range)
}
private let _clang_getRangeStart: @convention(c) (range: CXSourceRange) -> CXSourceLocation = library.loadSymbol("clang_getRangeStart")


/**
 * \brief Retrieve a source location representing the last character within a
 * source range.
 */
public func clang_getRangeEnd(range: CXSourceRange) -> CXSourceLocation {
    return _clang_getRangeEnd(range: range)
}
private let _clang_getRangeEnd: @convention(c) (range: CXSourceRange) -> CXSourceLocation = library.loadSymbol("clang_getRangeEnd")


/**
 * \brief Identifies an array of ranges.
 */
/*
public struct CXSourceRangeList {
    /** \brief The number of ranges in the \c ranges array. */
    public var count: UInt32
    /**
     * \brief An array of \c CXSourceRanges.
     */
    public var ranges: UnsafeMutablePointer<CXSourceRange>
    public init()
    public init(count: UInt32, ranges: UnsafeMutablePointer<CXSourceRange>)
}
*/

/**
 * \brief Retrieve all ranges that were skipped by the preprocessor.
 *
 * The preprocessor will skip lines when they are surrounded by an
 * if/ifdef/ifndef directive whose condition does not evaluate to true.
 */
public func clang_getSkippedRanges(tu: CXTranslationUnit, _ file: CXFile) -> UnsafeMutablePointer<CXSourceRangeList> {
    return _clang_getSkippedRanges(tu: tu, file: file)
}
private let _clang_getSkippedRanges: @convention(c) (tu: CXTranslationUnit, file: CXFile) -> UnsafeMutablePointer<CXSourceRangeList> = library.loadSymbol("clang_getSkippedRanges")


/**
 * \brief Destroy the given \c CXSourceRangeList.
 */
public func clang_disposeSourceRangeList(ranges: UnsafeMutablePointer<CXSourceRangeList>) {
    return _clang_disposeSourceRangeList(ranges: ranges)
}
private let _clang_disposeSourceRangeList: @convention(c) (ranges: UnsafeMutablePointer<CXSourceRangeList>) -> () = library.loadSymbol("clang_disposeSourceRangeList")


/**
 * @}
 */

/**
 * \defgroup CINDEX_DIAG Diagnostic reporting
 *
 * @{
 */

/**
 * \brief Describes the severity of a particular diagnostic.
 */
/*
public struct CXDiagnosticSeverity : RawRepresentable, Equatable {
    public init(_ rawValue: UInt32)
    public init(rawValue: UInt32)
    public var rawValue: UInt32
}
*/

/**
 * \brief A diagnostic that has been suppressed, e.g., by a command-line
 * option.
 */
// public var CXDiagnostic_Ignored: CXDiagnosticSeverity { get }

/**
 * \brief This diagnostic is a note that should be attached to the
 * previous (non-note) diagnostic.
 */
// public var CXDiagnostic_Note: CXDiagnosticSeverity { get }

/**
 * \brief This diagnostic indicates suspicious code that may not be
 * wrong.
 */
// public var CXDiagnostic_Warning: CXDiagnosticSeverity { get }

/**
 * \brief This diagnostic indicates that the code is ill-formed.
 */
// public var CXDiagnostic_Error: CXDiagnosticSeverity { get }

/**
 * \brief This diagnostic indicates that the code is ill-formed such
 * that future parser recovery is unlikely to produce useful
 * results.
 */
// public var CXDiagnostic_Fatal: CXDiagnosticSeverity { get }

/**
 * \brief A single diagnostic, containing the diagnostic's severity,
 * location, text, source ranges, and fix-it hints.
 */
// public typealias CXDiagnostic = UnsafeMutablePointer<Void>

/**
 * \brief A group of CXDiagnostics.
 */
// public typealias CXDiagnosticSet = UnsafeMutablePointer<Void>

/**
 * \brief Determine the number of diagnostics in a CXDiagnosticSet.
 */
public func clang_getNumDiagnosticsInSet(Diags: CXDiagnosticSet) -> UInt32 {
    return _clang_getNumDiagnosticsInSet(Diags: Diags)
}
private let _clang_getNumDiagnosticsInSet: @convention(c) (Diags: CXDiagnosticSet) -> UInt32 = library.loadSymbol("clang_getNumDiagnosticsInSet")


/**
 * \brief Retrieve a diagnostic associated with the given CXDiagnosticSet.
 *
 * \param Diags the CXDiagnosticSet to query.
 * \param Index the zero-based diagnostic number to retrieve.
 *
 * \returns the requested diagnostic. This diagnostic must be freed
 * via a call to \c clang_disposeDiagnostic().
 */
public func clang_getDiagnosticInSet(Diags: CXDiagnosticSet, _ Index: UInt32) -> CXDiagnostic {
    return _clang_getDiagnosticInSet(Diags: Diags, Index: Index)
}
private let _clang_getDiagnosticInSet: @convention(c) (Diags: CXDiagnosticSet, Index: UInt32) -> CXDiagnostic = library.loadSymbol("clang_getDiagnosticInSet")


/**
 * \brief Describes the kind of error that occurred (if any) in a call to
 * \c clang_loadDiagnostics.
 */
/*
public struct CXLoadDiag_Error : RawRepresentable, Equatable {
    public init(_ rawValue: UInt32)
    public init(rawValue: UInt32)
    public var rawValue: UInt32
}
*/

/**
 * \brief Indicates that no error occurred.
 */
// public var CXLoadDiag_None: CXLoadDiag_Error { get }

/**
 * \brief Indicates that an unknown error occurred while attempting to
 * deserialize diagnostics.
 */
// public var CXLoadDiag_Unknown: CXLoadDiag_Error { get }

/**
 * \brief Indicates that the file containing the serialized diagnostics
 * could not be opened.
 */
// public var CXLoadDiag_CannotLoad: CXLoadDiag_Error { get }

/**
 * \brief Indicates that the serialized diagnostics file is invalid or
 * corrupt.
 */
// public var CXLoadDiag_InvalidFile: CXLoadDiag_Error { get }

/**
 * \brief Deserialize a set of diagnostics from a Clang diagnostics bitcode
 * file.
 *
 * \param file The name of the file to deserialize.
 * \param error A pointer to a enum value recording if there was a problem
 *        deserializing the diagnostics.
 * \param errorString A pointer to a CXString for recording the error string
 *        if the file was not successfully loaded.
 *
 * \returns A loaded CXDiagnosticSet if successful, and NULL otherwise.  These
 * diagnostics should be released using clang_disposeDiagnosticSet().
 */
public func clang_loadDiagnostics(file: UnsafePointer<Int8>, _ error: UnsafeMutablePointer<CXLoadDiag_Error>, _ errorString: UnsafeMutablePointer<CXString>) -> CXDiagnosticSet {
    return _clang_loadDiagnostics(file: file, error: error, errorString: errorString)
}
private let _clang_loadDiagnostics: @convention(c) (file: UnsafePointer<Int8>, error: UnsafeMutablePointer<CXLoadDiag_Error>, errorString: UnsafeMutablePointer<CXString>) -> CXDiagnosticSet = library.loadSymbol("clang_loadDiagnostics")


/**
 * \brief Release a CXDiagnosticSet and all of its contained diagnostics.
 */
public func clang_disposeDiagnosticSet(Diags: CXDiagnosticSet) {
    return _clang_disposeDiagnosticSet(Diags: Diags)
}
private let _clang_disposeDiagnosticSet: @convention(c) (Diags: CXDiagnosticSet) -> () = library.loadSymbol("clang_disposeDiagnosticSet")


/**
 * \brief Retrieve the child diagnostics of a CXDiagnostic. 
 *
 * This CXDiagnosticSet does not need to be released by
 * clang_disposeDiagnosticSet.
 */
public func clang_getChildDiagnostics(D: CXDiagnostic) -> CXDiagnosticSet {
    return _clang_getChildDiagnostics(D: D)
}
private let _clang_getChildDiagnostics: @convention(c) (D: CXDiagnostic) -> CXDiagnosticSet = library.loadSymbol("clang_getChildDiagnostics")


/**
 * \brief Determine the number of diagnostics produced for the given
 * translation unit.
 */
public func clang_getNumDiagnostics(Unit: CXTranslationUnit) -> UInt32 {
    return _clang_getNumDiagnostics(Unit: Unit)
}
private let _clang_getNumDiagnostics: @convention(c) (Unit: CXTranslationUnit) -> UInt32 = library.loadSymbol("clang_getNumDiagnostics")


/**
 * \brief Retrieve a diagnostic associated with the given translation unit.
 *
 * \param Unit the translation unit to query.
 * \param Index the zero-based diagnostic number to retrieve.
 *
 * \returns the requested diagnostic. This diagnostic must be freed
 * via a call to \c clang_disposeDiagnostic().
 */
public func clang_getDiagnostic(Unit: CXTranslationUnit, _ Index: UInt32) -> CXDiagnostic {
    return _clang_getDiagnostic(Unit: Unit, Index: Index)
}
private let _clang_getDiagnostic: @convention(c) (Unit: CXTranslationUnit, Index: UInt32) -> CXDiagnostic = library.loadSymbol("clang_getDiagnostic")


/**
 * \brief Retrieve the complete set of diagnostics associated with a
 *        translation unit.
 *
 * \param Unit the translation unit to query.
 */
public func clang_getDiagnosticSetFromTU(Unit: CXTranslationUnit) -> CXDiagnosticSet {
    return _clang_getDiagnosticSetFromTU(Unit: Unit)
}
private let _clang_getDiagnosticSetFromTU: @convention(c) (Unit: CXTranslationUnit) -> CXDiagnosticSet = library.loadSymbol("clang_getDiagnosticSetFromTU")


/**
 * \brief Destroy a diagnostic.
 */
public func clang_disposeDiagnostic(Diagnostic: CXDiagnostic) {
    return _clang_disposeDiagnostic(Diagnostic: Diagnostic)
}
private let _clang_disposeDiagnostic: @convention(c) (Diagnostic: CXDiagnostic) -> () = library.loadSymbol("clang_disposeDiagnostic")


/**
 * \brief Options to control the display of diagnostics.
 *
 * The values in this enum are meant to be combined to customize the
 * behavior of \c clang_formatDiagnostic().
 */
/*
public struct CXDiagnosticDisplayOptions : RawRepresentable, Equatable {
    public init(_ rawValue: UInt32)
    public init(rawValue: UInt32)
    public var rawValue: UInt32
}
*/

/**
 * \brief Display the source-location information where the
 * diagnostic was located.
 *
 * When set, diagnostics will be prefixed by the file, line, and
 * (optionally) column to which the diagnostic refers. For example,
 *
 * \code
 * test.c:28: warning: extra tokens at end of #endif directive
 * \endcode
 *
 * This option corresponds to the clang flag \c -fshow-source-location.
 */
// public var CXDiagnostic_DisplaySourceLocation: CXDiagnosticDisplayOptions { get }

/**
 * \brief If displaying the source-location information of the
 * diagnostic, also include the column number.
 *
 * This option corresponds to the clang flag \c -fshow-column.
 */
// public var CXDiagnostic_DisplayColumn: CXDiagnosticDisplayOptions { get }

/**
 * \brief If displaying the source-location information of the
 * diagnostic, also include information about source ranges in a
 * machine-parsable format.
 *
 * This option corresponds to the clang flag
 * \c -fdiagnostics-print-source-range-info.
 */
// public var CXDiagnostic_DisplaySourceRanges: CXDiagnosticDisplayOptions { get }

/**
 * \brief Display the option name associated with this diagnostic, if any.
 *
 * The option name displayed (e.g., -Wconversion) will be placed in brackets
 * after the diagnostic text. This option corresponds to the clang flag
 * \c -fdiagnostics-show-option.
 */
// public var CXDiagnostic_DisplayOption: CXDiagnosticDisplayOptions { get }

/**
 * \brief Display the category number associated with this diagnostic, if any.
 *
 * The category number is displayed within brackets after the diagnostic text.
 * This option corresponds to the clang flag 
 * \c -fdiagnostics-show-category=id.
 */
// public var CXDiagnostic_DisplayCategoryId: CXDiagnosticDisplayOptions { get }

/**
 * \brief Display the category name associated with this diagnostic, if any.
 *
 * The category name is displayed within brackets after the diagnostic text.
 * This option corresponds to the clang flag 
 * \c -fdiagnostics-show-category=name.
 */
// public var CXDiagnostic_DisplayCategoryName: CXDiagnosticDisplayOptions { get }

/**
 * \brief Format the given diagnostic in a manner that is suitable for display.
 *
 * This routine will format the given diagnostic to a string, rendering
 * the diagnostic according to the various options given. The
 * \c clang_defaultDiagnosticDisplayOptions() function returns the set of
 * options that most closely mimics the behavior of the clang compiler.
 *
 * \param Diagnostic The diagnostic to print.
 *
 * \param Options A set of options that control the diagnostic display,
 * created by combining \c CXDiagnosticDisplayOptions values.
 *
 * \returns A new string containing for formatted diagnostic.
 */
public func clang_formatDiagnostic(Diagnostic: CXDiagnostic, _ Options: UInt32) -> CXString {
    return _clang_formatDiagnostic(Diagnostic: Diagnostic, Options: Options)
}
private let _clang_formatDiagnostic: @convention(c) (Diagnostic: CXDiagnostic, Options: UInt32) -> CXString = library.loadSymbol("clang_formatDiagnostic")


/**
 * \brief Retrieve the set of display options most similar to the
 * default behavior of the clang compiler.
 *
 * \returns A set of display options suitable for use with \c
 * clang_formatDiagnostic().
 */
public func clang_defaultDiagnosticDisplayOptions() -> UInt32 {
    return _clang_defaultDiagnosticDisplayOptions()
}
private let _clang_defaultDiagnosticDisplayOptions: @convention(c) () -> UInt32 = library.loadSymbol("clang_defaultDiagnosticDisplayOptions")


/**
 * \brief Determine the severity of the given diagnostic.
 */
public func clang_getDiagnosticSeverity(unnamed1: CXDiagnostic) -> CXDiagnosticSeverity {
    return _clang_getDiagnosticSeverity(unnamed1)
}
private let _clang_getDiagnosticSeverity: @convention(c) (_: CXDiagnostic) -> CXDiagnosticSeverity = library.loadSymbol("clang_getDiagnosticSeverity")


/**
 * \brief Retrieve the source location of the given diagnostic.
 *
 * This location is where Clang would print the caret ('^') when
 * displaying the diagnostic on the command line.
 */
public func clang_getDiagnosticLocation(unnamed1: CXDiagnostic) -> CXSourceLocation {
    return _clang_getDiagnosticLocation(unnamed1)
}
private let _clang_getDiagnosticLocation: @convention(c) (_: CXDiagnostic) -> CXSourceLocation = library.loadSymbol("clang_getDiagnosticLocation")


/**
 * \brief Retrieve the text of the given diagnostic.
 */
public func clang_getDiagnosticSpelling(unnamed1: CXDiagnostic) -> CXString {
    return _clang_getDiagnosticSpelling(unnamed1)
}
private let _clang_getDiagnosticSpelling: @convention(c) (_: CXDiagnostic) -> CXString = library.loadSymbol("clang_getDiagnosticSpelling")


/**
 * \brief Retrieve the name of the command-line option that enabled this
 * diagnostic.
 *
 * \param Diag The diagnostic to be queried.
 *
 * \param Disable If non-NULL, will be set to the option that disables this
 * diagnostic (if any).
 *
 * \returns A string that contains the command-line option used to enable this
 * warning, such as "-Wconversion" or "-pedantic". 
 */
public func clang_getDiagnosticOption(Diag: CXDiagnostic, _ Disable: UnsafeMutablePointer<CXString>) -> CXString {
    return _clang_getDiagnosticOption(Diag: Diag, Disable: Disable)
}
private let _clang_getDiagnosticOption: @convention(c) (Diag: CXDiagnostic, Disable: UnsafeMutablePointer<CXString>) -> CXString = library.loadSymbol("clang_getDiagnosticOption")


/**
 * \brief Retrieve the category number for this diagnostic.
 *
 * Diagnostics can be categorized into groups along with other, related
 * diagnostics (e.g., diagnostics under the same warning flag). This routine 
 * retrieves the category number for the given diagnostic.
 *
 * \returns The number of the category that contains this diagnostic, or zero
 * if this diagnostic is uncategorized.
 */
public func clang_getDiagnosticCategory(unnamed1: CXDiagnostic) -> UInt32 {
    return _clang_getDiagnosticCategory(unnamed1)
}
private let _clang_getDiagnosticCategory: @convention(c) (_: CXDiagnostic) -> UInt32 = library.loadSymbol("clang_getDiagnosticCategory")


/**
 * \brief Retrieve the name of a particular diagnostic category.  This
 *  is now deprecated.  Use clang_getDiagnosticCategoryText()
 *  instead.
 *
 * \param Category A diagnostic category number, as returned by 
 * \c clang_getDiagnosticCategory().
 *
 * \returns The name of the given diagnostic category.
 */
@available(*, deprecated)
public func clang_getDiagnosticCategoryName(Category: UInt32) -> CXString {
    return _clang_getDiagnosticCategoryName(Category: Category)
}
private let _clang_getDiagnosticCategoryName: @convention(c) (Category: UInt32) -> CXString = library.loadSymbol("clang_getDiagnosticCategoryName")


/**
 * \brief Retrieve the diagnostic category text for a given diagnostic.
 *
 * \returns The text of the given diagnostic category.
 */
public func clang_getDiagnosticCategoryText(unnamed1: CXDiagnostic) -> CXString {
    return _clang_getDiagnosticCategoryText(unnamed1)
}
private let _clang_getDiagnosticCategoryText: @convention(c) (_: CXDiagnostic) -> CXString = library.loadSymbol("clang_getDiagnosticCategoryText")


/**
 * \brief Determine the number of source ranges associated with the given
 * diagnostic.
 */
public func clang_getDiagnosticNumRanges(unnamed1: CXDiagnostic) -> UInt32 {
    return _clang_getDiagnosticNumRanges(unnamed1)
}
private let _clang_getDiagnosticNumRanges: @convention(c) (_: CXDiagnostic) -> UInt32 = library.loadSymbol("clang_getDiagnosticNumRanges")


/**
 * \brief Retrieve a source range associated with the diagnostic.
 *
 * A diagnostic's source ranges highlight important elements in the source
 * code. On the command line, Clang displays source ranges by
 * underlining them with '~' characters.
 *
 * \param Diagnostic the diagnostic whose range is being extracted.
 *
 * \param Range the zero-based index specifying which range to
 *
 * \returns the requested source range.
 */
public func clang_getDiagnosticRange(Diagnostic: CXDiagnostic, _ Range: UInt32) -> CXSourceRange {
    return _clang_getDiagnosticRange(Diagnostic: Diagnostic, Range: Range)
}
private let _clang_getDiagnosticRange: @convention(c) (Diagnostic: CXDiagnostic, Range: UInt32) -> CXSourceRange = library.loadSymbol("clang_getDiagnosticRange")


/**
 * \brief Determine the number of fix-it hints associated with the
 * given diagnostic.
 */
public func clang_getDiagnosticNumFixIts(Diagnostic: CXDiagnostic) -> UInt32 {
    return _clang_getDiagnosticNumFixIts(Diagnostic: Diagnostic)
}
private let _clang_getDiagnosticNumFixIts: @convention(c) (Diagnostic: CXDiagnostic) -> UInt32 = library.loadSymbol("clang_getDiagnosticNumFixIts")


/**
 * \brief Retrieve the replacement information for a given fix-it.
 *
 * Fix-its are described in terms of a source range whose contents
 * should be replaced by a string. This approach generalizes over
 * three kinds of operations: removal of source code (the range covers
 * the code to be removed and the replacement string is empty),
 * replacement of source code (the range covers the code to be
 * replaced and the replacement string provides the new code), and
 * insertion (both the start and end of the range point at the
 * insertion location, and the replacement string provides the text to
 * insert).
 *
 * \param Diagnostic The diagnostic whose fix-its are being queried.
 *
 * \param FixIt The zero-based index of the fix-it.
 *
 * \param ReplacementRange The source range whose contents will be
 * replaced with the returned replacement string. Note that source
 * ranges are half-open ranges [a, b), so the source code should be
 * replaced from a and up to (but not including) b.
 *
 * \returns A string containing text that should be replace the source
 * code indicated by the \c ReplacementRange.
 */
public func clang_getDiagnosticFixIt(Diagnostic: CXDiagnostic, _ FixIt: UInt32, _ ReplacementRange: UnsafeMutablePointer<CXSourceRange>) -> CXString {
    return _clang_getDiagnosticFixIt(Diagnostic: Diagnostic, FixIt: FixIt, ReplacementRange: ReplacementRange)
}
private let _clang_getDiagnosticFixIt: @convention(c) (Diagnostic: CXDiagnostic, FixIt: UInt32, ReplacementRange: UnsafeMutablePointer<CXSourceRange>) -> CXString = library.loadSymbol("clang_getDiagnosticFixIt")


/**
 * @}
 */

/**
 * \defgroup CINDEX_TRANSLATION_UNIT Translation unit manipulation
 *
 * The routines in this group provide the ability to create and destroy
 * translation units from files, either by parsing the contents of the files or
 * by reading in a serialized representation of a translation unit.
 *
 * @{
 */

/**
 * \brief Get the original translation unit source file name.
 */
public func clang_getTranslationUnitSpelling(CTUnit: CXTranslationUnit) -> CXString {
    return _clang_getTranslationUnitSpelling(CTUnit: CTUnit)
}
private let _clang_getTranslationUnitSpelling: @convention(c) (CTUnit: CXTranslationUnit) -> CXString = library.loadSymbol("clang_getTranslationUnitSpelling")


/**
 * \brief Return the CXTranslationUnit for a given source file and the provided
 * command line arguments one would pass to the compiler.
 *
 * Note: The 'source_filename' argument is optional.  If the caller provides a
 * NULL pointer, the name of the source file is expected to reside in the
 * specified command line arguments.
 *
 * Note: When encountered in 'clang_command_line_args', the following options
 * are ignored:
 *
 *   '-c'
 *   '-emit-ast'
 *   '-fsyntax-only'
 *   '-o \<output file>'  (both '-o' and '\<output file>' are ignored)
 *
 * \param CIdx The index object with which the translation unit will be
 * associated.
 *
 * \param source_filename The name of the source file to load, or NULL if the
 * source file is included in \p clang_command_line_args.
 *
 * \param num_clang_command_line_args The number of command-line arguments in
 * \p clang_command_line_args.
 *
 * \param clang_command_line_args The command-line arguments that would be
 * passed to the \c clang executable if it were being invoked out-of-process.
 * These command-line options will be parsed and will affect how the translation
 * unit is parsed. Note that the following options are ignored: '-c',
 * '-emit-ast', '-fsyntax-only' (which is the default), and '-o \<output file>'.
 *
 * \param num_unsaved_files the number of unsaved file entries in \p
 * unsaved_files.
 *
 * \param unsaved_files the files that have not yet been saved to disk
 * but may be required for code completion, including the contents of
 * those files.  The contents and name of these files (as specified by
 * CXUnsavedFile) are copied when necessary, so the client only needs to
 * guarantee their validity until the call to this function returns.
 */
public func clang_createTranslationUnitFromSourceFile(CIdx: CXIndex, _ source_filename: UnsafePointer<Int8>, _ num_clang_command_line_args: Int32, _ clang_command_line_args: UnsafePointer<UnsafePointer<Int8>>, _ num_unsaved_files: UInt32, _ unsaved_files: UnsafeMutablePointer<CXUnsavedFile>) -> CXTranslationUnit {
    return _clang_createTranslationUnitFromSourceFile(CIdx: CIdx, source_filename: source_filename, num_clang_command_line_args: num_clang_command_line_args, clang_command_line_args: clang_command_line_args, num_unsaved_files: num_unsaved_files, unsaved_files: unsaved_files)
}
private let _clang_createTranslationUnitFromSourceFile: @convention(c) (CIdx: CXIndex, source_filename: UnsafePointer<Int8>, num_clang_command_line_args: Int32, clang_command_line_args: UnsafePointer<UnsafePointer<Int8>>, num_unsaved_files: UInt32, unsaved_files: UnsafeMutablePointer<CXUnsavedFile>) -> CXTranslationUnit = library.loadSymbol("clang_createTranslationUnitFromSourceFile")


/**
 * \brief Same as \c clang_createTranslationUnit2, but returns
 * the \c CXTranslationUnit instead of an error code.  In case of an error this
 * routine returns a \c NULL \c CXTranslationUnit, without further detailed
 * error codes.
 */
public func clang_createTranslationUnit(CIdx: CXIndex, _ ast_filename: UnsafePointer<Int8>) -> CXTranslationUnit {
    return _clang_createTranslationUnit(CIdx: CIdx, ast_filename: ast_filename)
}
private let _clang_createTranslationUnit: @convention(c) (CIdx: CXIndex, ast_filename: UnsafePointer<Int8>) -> CXTranslationUnit = library.loadSymbol("clang_createTranslationUnit")


/**
 * \brief Create a translation unit from an AST file (\c -emit-ast).
 *
 * \param[out] out_TU A non-NULL pointer to store the created
 * \c CXTranslationUnit.
 *
 * \returns Zero on success, otherwise returns an error code.
 */
public func clang_createTranslationUnit2(CIdx: CXIndex, _ ast_filename: UnsafePointer<Int8>, _ out_TU: UnsafeMutablePointer<CXTranslationUnit>) -> CXErrorCode {
    return _clang_createTranslationUnit2(CIdx: CIdx, ast_filename: ast_filename, out_TU: out_TU)
}
private let _clang_createTranslationUnit2: @convention(c) (CIdx: CXIndex, ast_filename: UnsafePointer<Int8>, out_TU: UnsafeMutablePointer<CXTranslationUnit>) -> CXErrorCode = library.loadSymbol("clang_createTranslationUnit2")


/**
 * \brief Flags that control the creation of translation units.
 *
 * The enumerators in this enumeration type are meant to be bitwise
 * ORed together to specify which options should be used when
 * constructing the translation unit.
 */
/*
public struct CXTranslationUnit_Flags : RawRepresentable, Equatable {
    public init(_ rawValue: UInt32)
    public init(rawValue: UInt32)
    public var rawValue: UInt32
}
*/

/**
 * \brief Used to indicate that no special translation-unit options are
 * needed.
 */
// public var CXTranslationUnit_None: CXTranslationUnit_Flags { get }

/**
 * \brief Used to indicate that the parser should construct a "detailed"
 * preprocessing record, including all macro definitions and instantiations.
 *
 * Constructing a detailed preprocessing record requires more memory
 * and time to parse, since the information contained in the record
 * is usually not retained. However, it can be useful for
 * applications that require more detailed information about the
 * behavior of the preprocessor.
 */
// public var CXTranslationUnit_DetailedPreprocessingRecord: CXTranslationUnit_Flags { get }

/**
 * \brief Used to indicate that the translation unit is incomplete.
 *
 * When a translation unit is considered "incomplete", semantic
 * analysis that is typically performed at the end of the
 * translation unit will be suppressed. For example, this suppresses
 * the completion of tentative declarations in C and of
 * instantiation of implicitly-instantiation function templates in
 * C++. This option is typically used when parsing a header with the
 * intent of producing a precompiled header.
 */
// public var CXTranslationUnit_Incomplete: CXTranslationUnit_Flags { get }

/**
 * \brief Used to indicate that the translation unit should be built with an 
 * implicit precompiled header for the preamble.
 *
 * An implicit precompiled header is used as an optimization when a
 * particular translation unit is likely to be reparsed many times
 * when the sources aren't changing that often. In this case, an
 * implicit precompiled header will be built containing all of the
 * initial includes at the top of the main file (what we refer to as
 * the "preamble" of the file). In subsequent parses, if the
 * preamble or the files in it have not changed, \c
 * clang_reparseTranslationUnit() will re-use the implicit
 * precompiled header to improve parsing performance.
 */
// public var CXTranslationUnit_PrecompiledPreamble: CXTranslationUnit_Flags { get }

/**
 * \brief Used to indicate that the translation unit should cache some
 * code-completion results with each reparse of the source file.
 *
 * Caching of code-completion results is a performance optimization that
 * introduces some overhead to reparsing but improves the performance of
 * code-completion operations.
 */
// public var CXTranslationUnit_CacheCompletionResults: CXTranslationUnit_Flags { get }

/**
 * \brief Used to indicate that the translation unit will be serialized with
 * \c clang_saveTranslationUnit.
 *
 * This option is typically used when parsing a header with the intent of
 * producing a precompiled header.
 */
// public var CXTranslationUnit_ForSerialization: CXTranslationUnit_Flags { get }

/**
 * \brief DEPRECATED: Enabled chained precompiled preambles in C++.
 *
 * Note: this is a *temporary* option that is available only while
 * we are testing C++ precompiled preamble support. It is deprecated.
 */
// public var CXTranslationUnit_CXXChainedPCH: CXTranslationUnit_Flags { get }

/**
 * \brief Used to indicate that function/method bodies should be skipped while
 * parsing.
 *
 * This option can be used to search for declarations/definitions while
 * ignoring the usages.
 */
// public var CXTranslationUnit_SkipFunctionBodies: CXTranslationUnit_Flags { get }

/**
 * \brief Used to indicate that brief documentation comments should be
 * included into the set of code completions returned from this translation
 * unit.
 */
// public var CXTranslationUnit_IncludeBriefCommentsInCodeCompletion: CXTranslationUnit_Flags { get }

/**
 * \brief Returns the set of flags that is suitable for parsing a translation
 * unit that is being edited.
 *
 * The set of flags returned provide options for \c clang_parseTranslationUnit()
 * to indicate that the translation unit is likely to be reparsed many times,
 * either explicitly (via \c clang_reparseTranslationUnit()) or implicitly
 * (e.g., by code completion (\c clang_codeCompletionAt())). The returned flag
 * set contains an unspecified set of optimizations (e.g., the precompiled 
 * preamble) geared toward improving the performance of these routines. The
 * set of optimizations enabled may change from one version to the next.
 */
public func clang_defaultEditingTranslationUnitOptions() -> UInt32 {
    return _clang_defaultEditingTranslationUnitOptions()
}
private let _clang_defaultEditingTranslationUnitOptions: @convention(c) () -> UInt32 = library.loadSymbol("clang_defaultEditingTranslationUnitOptions")


/**
 * \brief Same as \c clang_parseTranslationUnit2, but returns
 * the \c CXTranslationUnit instead of an error code.  In case of an error this
 * routine returns a \c NULL \c CXTranslationUnit, without further detailed
 * error codes.
 */
public func clang_parseTranslationUnit(CIdx: CXIndex, _ source_filename: UnsafePointer<Int8>, _ command_line_args: UnsafePointer<UnsafePointer<Int8>>, _ num_command_line_args: Int32, _ unsaved_files: UnsafeMutablePointer<CXUnsavedFile>, _ num_unsaved_files: UInt32, _ options: UInt32) -> CXTranslationUnit {
    return _clang_parseTranslationUnit(CIdx: CIdx, source_filename: source_filename, command_line_args: command_line_args, num_command_line_args: num_command_line_args, unsaved_files: unsaved_files, num_unsaved_files: num_unsaved_files, options: options)
}
private let _clang_parseTranslationUnit: @convention(c) (CIdx: CXIndex, source_filename: UnsafePointer<Int8>, command_line_args: UnsafePointer<UnsafePointer<Int8>>, num_command_line_args: Int32, unsaved_files: UnsafeMutablePointer<CXUnsavedFile>, num_unsaved_files: UInt32, options: UInt32) -> CXTranslationUnit = library.loadSymbol("clang_parseTranslationUnit")


/**
 * \brief Parse the given source file and the translation unit corresponding
 * to that file.
 *
 * This routine is the main entry point for the Clang C API, providing the
 * ability to parse a source file into a translation unit that can then be
 * queried by other functions in the API. This routine accepts a set of
 * command-line arguments so that the compilation can be configured in the same
 * way that the compiler is configured on the command line.
 *
 * \param CIdx The index object with which the translation unit will be 
 * associated.
 *
 * \param source_filename The name of the source file to load, or NULL if the
 * source file is included in \c command_line_args.
 *
 * \param command_line_args The command-line arguments that would be
 * passed to the \c clang executable if it were being invoked out-of-process.
 * These command-line options will be parsed and will affect how the translation
 * unit is parsed. Note that the following options are ignored: '-c', 
 * '-emit-ast', '-fsyntax-only' (which is the default), and '-o \<output file>'.
 *
 * \param num_command_line_args The number of command-line arguments in
 * \c command_line_args.
 *
 * \param unsaved_files the files that have not yet been saved to disk
 * but may be required for parsing, including the contents of
 * those files.  The contents and name of these files (as specified by
 * CXUnsavedFile) are copied when necessary, so the client only needs to
 * guarantee their validity until the call to this function returns.
 *
 * \param num_unsaved_files the number of unsaved file entries in \p
 * unsaved_files.
 *
 * \param options A bitmask of options that affects how the translation unit
 * is managed but not its compilation. This should be a bitwise OR of the
 * CXTranslationUnit_XXX flags.
 *
 * \param[out] out_TU A non-NULL pointer to store the created
 * \c CXTranslationUnit, describing the parsed code and containing any
 * diagnostics produced by the compiler.
 *
 * \returns Zero on success, otherwise returns an error code.
 */
public func clang_parseTranslationUnit2(CIdx: CXIndex, _ source_filename: UnsafePointer<Int8>, _ command_line_args: UnsafePointer<UnsafePointer<Int8>>, _ num_command_line_args: Int32, _ unsaved_files: UnsafeMutablePointer<CXUnsavedFile>, _ num_unsaved_files: UInt32, _ options: UInt32, _ out_TU: UnsafeMutablePointer<CXTranslationUnit>) -> CXErrorCode {
    return _clang_parseTranslationUnit2(CIdx: CIdx, source_filename: source_filename, command_line_args: command_line_args, num_command_line_args: num_command_line_args, unsaved_files: unsaved_files, num_unsaved_files: num_unsaved_files, options: options, out_TU: out_TU)
}
private let _clang_parseTranslationUnit2: @convention(c) (CIdx: CXIndex, source_filename: UnsafePointer<Int8>, command_line_args: UnsafePointer<UnsafePointer<Int8>>, num_command_line_args: Int32, unsaved_files: UnsafeMutablePointer<CXUnsavedFile>, num_unsaved_files: UInt32, options: UInt32, out_TU: UnsafeMutablePointer<CXTranslationUnit>) -> CXErrorCode = library.loadSymbol("clang_parseTranslationUnit2")


/**
 * \brief Flags that control how translation units are saved.
 *
 * The enumerators in this enumeration type are meant to be bitwise
 * ORed together to specify which options should be used when
 * saving the translation unit.
 */
/*
public struct CXSaveTranslationUnit_Flags : RawRepresentable, Equatable {
    public init(_ rawValue: UInt32)
    public init(rawValue: UInt32)
    public var rawValue: UInt32
}
*/

/**
 * \brief Used to indicate that no special saving options are needed.
 */
// public var CXSaveTranslationUnit_None: CXSaveTranslationUnit_Flags { get }

/**
 * \brief Returns the set of flags that is suitable for saving a translation
 * unit.
 *
 * The set of flags returned provide options for
 * \c clang_saveTranslationUnit() by default. The returned flag
 * set contains an unspecified set of options that save translation units with
 * the most commonly-requested data.
 */
public func clang_defaultSaveOptions(TU: CXTranslationUnit) -> UInt32 {
    return _clang_defaultSaveOptions(TU: TU)
}
private let _clang_defaultSaveOptions: @convention(c) (TU: CXTranslationUnit) -> UInt32 = library.loadSymbol("clang_defaultSaveOptions")


/**
 * \brief Describes the kind of error that occurred (if any) in a call to
 * \c clang_saveTranslationUnit().
 */
/*
public struct CXSaveError : RawRepresentable, Equatable {
    public init(_ rawValue: UInt32)
    public init(rawValue: UInt32)
    public var rawValue: UInt32
}
*/

/**
 * \brief Indicates that no error occurred while saving a translation unit.
 */
// public var CXSaveError_None: CXSaveError { get }

/**
 * \brief Indicates that an unknown error occurred while attempting to save
 * the file.
 *
 * This error typically indicates that file I/O failed when attempting to 
 * write the file.
 */
// public var CXSaveError_Unknown: CXSaveError { get }

/**
 * \brief Indicates that errors during translation prevented this attempt
 * to save the translation unit.
 * 
 * Errors that prevent the translation unit from being saved can be
 * extracted using \c clang_getNumDiagnostics() and \c clang_getDiagnostic().
 */
// public var CXSaveError_TranslationErrors: CXSaveError { get }

/**
 * \brief Indicates that the translation unit to be saved was somehow
 * invalid (e.g., NULL).
 */
// public var CXSaveError_InvalidTU: CXSaveError { get }

/**
 * \brief Saves a translation unit into a serialized representation of
 * that translation unit on disk.
 *
 * Any translation unit that was parsed without error can be saved
 * into a file. The translation unit can then be deserialized into a
 * new \c CXTranslationUnit with \c clang_createTranslationUnit() or,
 * if it is an incomplete translation unit that corresponds to a
 * header, used as a precompiled header when parsing other translation
 * units.
 *
 * \param TU The translation unit to save.
 *
 * \param FileName The file to which the translation unit will be saved.
 *
 * \param options A bitmask of options that affects how the translation unit
 * is saved. This should be a bitwise OR of the
 * CXSaveTranslationUnit_XXX flags.
 *
 * \returns A value that will match one of the enumerators of the CXSaveError
 * enumeration. Zero (CXSaveError_None) indicates that the translation unit was 
 * saved successfully, while a non-zero value indicates that a problem occurred.
 */
public func clang_saveTranslationUnit(TU: CXTranslationUnit, _ FileName: UnsafePointer<Int8>, _ options: UInt32) -> Int32 {
    return _clang_saveTranslationUnit(TU: TU, FileName: FileName, options: options)
}
private let _clang_saveTranslationUnit: @convention(c) (TU: CXTranslationUnit, FileName: UnsafePointer<Int8>, options: UInt32) -> Int32 = library.loadSymbol("clang_saveTranslationUnit")


/**
 * \brief Destroy the specified CXTranslationUnit object.
 */
public func clang_disposeTranslationUnit(unnamed1: CXTranslationUnit) {
    return _clang_disposeTranslationUnit(unnamed1)
}
private let _clang_disposeTranslationUnit: @convention(c) (_: CXTranslationUnit) -> () = library.loadSymbol("clang_disposeTranslationUnit")


/**
 * \brief Flags that control the reparsing of translation units.
 *
 * The enumerators in this enumeration type are meant to be bitwise
 * ORed together to specify which options should be used when
 * reparsing the translation unit.
 */
/*
public struct CXReparse_Flags : RawRepresentable, Equatable {
    public init(_ rawValue: UInt32)
    public init(rawValue: UInt32)
    public var rawValue: UInt32
}
*/

/**
 * \brief Used to indicate that no special reparsing options are needed.
 */
// public var CXReparse_None: CXReparse_Flags { get }

/**
 * \brief Returns the set of flags that is suitable for reparsing a translation
 * unit.
 *
 * The set of flags returned provide options for
 * \c clang_reparseTranslationUnit() by default. The returned flag
 * set contains an unspecified set of optimizations geared toward common uses
 * of reparsing. The set of optimizations enabled may change from one version 
 * to the next.
 */
public func clang_defaultReparseOptions(TU: CXTranslationUnit) -> UInt32 {
    return _clang_defaultReparseOptions(TU: TU)
}
private let _clang_defaultReparseOptions: @convention(c) (TU: CXTranslationUnit) -> UInt32 = library.loadSymbol("clang_defaultReparseOptions")


/**
 * \brief Reparse the source files that produced this translation unit.
 *
 * This routine can be used to re-parse the source files that originally
 * created the given translation unit, for example because those source files
 * have changed (either on disk or as passed via \p unsaved_files). The
 * source code will be reparsed with the same command-line options as it
 * was originally parsed. 
 *
 * Reparsing a translation unit invalidates all cursors and source locations
 * that refer into that translation unit. This makes reparsing a translation
 * unit semantically equivalent to destroying the translation unit and then
 * creating a new translation unit with the same command-line arguments.
 * However, it may be more efficient to reparse a translation 
 * unit using this routine.
 *
 * \param TU The translation unit whose contents will be re-parsed. The
 * translation unit must originally have been built with 
 * \c clang_createTranslationUnitFromSourceFile().
 *
 * \param num_unsaved_files The number of unsaved file entries in \p
 * unsaved_files.
 *
 * \param unsaved_files The files that have not yet been saved to disk
 * but may be required for parsing, including the contents of
 * those files.  The contents and name of these files (as specified by
 * CXUnsavedFile) are copied when necessary, so the client only needs to
 * guarantee their validity until the call to this function returns.
 * 
 * \param options A bitset of options composed of the flags in CXReparse_Flags.
 * The function \c clang_defaultReparseOptions() produces a default set of
 * options recommended for most uses, based on the translation unit.
 *
 * \returns 0 if the sources could be reparsed.  A non-zero error code will be
 * returned if reparsing was impossible, such that the translation unit is
 * invalid. In such cases, the only valid call for \c TU is
 * \c clang_disposeTranslationUnit(TU).  The error codes returned by this
 * routine are described by the \c CXErrorCode enum.
 */
public func clang_reparseTranslationUnit(TU: CXTranslationUnit, _ num_unsaved_files: UInt32, _ unsaved_files: UnsafeMutablePointer<CXUnsavedFile>, _ options: UInt32) -> Int32 {
    return _clang_reparseTranslationUnit(TU: TU, num_unsaved_files: num_unsaved_files, unsaved_files: unsaved_files, options: options)
}
private let _clang_reparseTranslationUnit: @convention(c) (TU: CXTranslationUnit, num_unsaved_files: UInt32, unsaved_files: UnsafeMutablePointer<CXUnsavedFile>, options: UInt32) -> Int32 = library.loadSymbol("clang_reparseTranslationUnit")


/**
  * \brief Categorizes how memory is being used by a translation unit.
  */
/*
public struct CXTUResourceUsageKind : RawRepresentable, Equatable {
    public init(_ rawValue: UInt32)
    public init(rawValue: UInt32)
    public var rawValue: UInt32
}
*/
// public var CXTUResourceUsage_AST: CXTUResourceUsageKind { get }
// public var CXTUResourceUsage_Identifiers: CXTUResourceUsageKind { get }
// public var CXTUResourceUsage_Selectors: CXTUResourceUsageKind { get }
// public var CXTUResourceUsage_GlobalCompletionResults: CXTUResourceUsageKind { get }
// public var CXTUResourceUsage_SourceManagerContentCache: CXTUResourceUsageKind { get }
// public var CXTUResourceUsage_AST_SideTables: CXTUResourceUsageKind { get }
// public var CXTUResourceUsage_SourceManager_Membuffer_Malloc: CXTUResourceUsageKind { get }
// public var CXTUResourceUsage_SourceManager_Membuffer_MMap: CXTUResourceUsageKind { get }
// public var CXTUResourceUsage_ExternalASTSource_Membuffer_Malloc: CXTUResourceUsageKind { get }
// public var CXTUResourceUsage_ExternalASTSource_Membuffer_MMap: CXTUResourceUsageKind { get }
// public var CXTUResourceUsage_Preprocessor: CXTUResourceUsageKind { get }
// public var CXTUResourceUsage_PreprocessingRecord: CXTUResourceUsageKind { get }
// public var CXTUResourceUsage_SourceManager_DataStructures: CXTUResourceUsageKind { get }
// public var CXTUResourceUsage_Preprocessor_HeaderSearch: CXTUResourceUsageKind { get }
// public var CXTUResourceUsage_MEMORY_IN_BYTES_BEGIN: CXTUResourceUsageKind { get }
// public var CXTUResourceUsage_MEMORY_IN_BYTES_END: CXTUResourceUsageKind { get }
// public var CXTUResourceUsage_First: CXTUResourceUsageKind { get }
// public var CXTUResourceUsage_Last: CXTUResourceUsageKind { get }


/**
  * \brief Returns the human-readable null-terminated C string that represents
  *  the name of the memory category.  This string should never be freed.
  */
public func clang_getTUResourceUsageName(kind: CXTUResourceUsageKind) -> UnsafePointer<Int8> {
    return _clang_getTUResourceUsageName(kind: kind)
}
private let _clang_getTUResourceUsageName: @convention(c) (kind: CXTUResourceUsageKind) -> UnsafePointer<Int8> = library.loadSymbol("clang_getTUResourceUsageName")


/*
public struct CXTUResourceUsageEntry {
    /* \brief The memory usage category. */
    public var kind: CXTUResourceUsageKind
    /* \brief Amount of resources used. 
        The units will depend on the resource kind. */
    public var amount: UInt
    public init()
    public init(kind: CXTUResourceUsageKind, amount: UInt)
}
*/

/**
  * \brief The memory usage of a CXTranslationUnit, broken into categories.
  */
/*
public struct CXTUResourceUsage {
    /* \brief Private data member, used for queries. */
    public var data: UnsafeMutablePointer<Void>
    
    /* \brief The number of entries in the 'entries' array. */
    public var numEntries: UInt32
    
    /* \brief An array of key-value pairs, representing the breakdown of memory
              usage. */
    public var entries: UnsafeMutablePointer<CXTUResourceUsageEntry>
    public init()
    public init(data: UnsafeMutablePointer<Void>, numEntries: UInt32, entries: UnsafeMutablePointer<CXTUResourceUsageEntry>)
}
*/

/**
  * \brief Return the memory usage of a translation unit.  This object
  *  should be released with clang_disposeCXTUResourceUsage().
  */
public func clang_getCXTUResourceUsage(TU: CXTranslationUnit) -> CXTUResourceUsage {
    return _clang_getCXTUResourceUsage(TU: TU)
}
private let _clang_getCXTUResourceUsage: @convention(c) (TU: CXTranslationUnit) -> CXTUResourceUsage = library.loadSymbol("clang_getCXTUResourceUsage")


public func clang_disposeCXTUResourceUsage(usage: CXTUResourceUsage) {
    return _clang_disposeCXTUResourceUsage(usage: usage)
}
private let _clang_disposeCXTUResourceUsage: @convention(c) (usage: CXTUResourceUsage) -> () = library.loadSymbol("clang_disposeCXTUResourceUsage")


/**
 * @}
 */

/**
 * \brief Describes the kind of entity that a cursor refers to.
 */
/*
public struct CXCursorKind : RawRepresentable, Equatable {
    public init(_ rawValue: UInt32)
    public init(rawValue: UInt32)
    public var rawValue: UInt32
}
*/

/* Declarations */
/**
 * \brief A declaration whose specific kind is not exposed via this
 * interface.
 *
 * Unexposed declarations have the same operations as any other kind
 * of declaration; one can extract their location information,
 * spelling, find their definitions, etc. However, the specific kind
 * of the declaration is not reported.
 */
// public var CXCursor_UnexposedDecl: CXCursorKind { get }
/** \brief A C or C++ struct. */
// public var CXCursor_StructDecl: CXCursorKind { get }
/** \brief A C or C++ union. */
// public var CXCursor_UnionDecl: CXCursorKind { get }
/** \brief A C++ class. */
// public var CXCursor_ClassDecl: CXCursorKind { get }
/** \brief An enumeration. */
// public var CXCursor_EnumDecl: CXCursorKind { get }
/**
 * \brief A field (in C) or non-static data member (in C++) in a
 * struct, union, or C++ class.
 */
// public var CXCursor_FieldDecl: CXCursorKind { get }
/** \brief An enumerator constant. */
// public var CXCursor_EnumConstantDecl: CXCursorKind { get }
/** \brief A function. */
// public var CXCursor_FunctionDecl: CXCursorKind { get }
/** \brief A variable. */
// public var CXCursor_VarDecl: CXCursorKind { get }
/** \brief A function or method parameter. */
// public var CXCursor_ParmDecl: CXCursorKind { get }
/** \brief An Objective-C \@interface. */
// public var CXCursor_ObjCInterfaceDecl: CXCursorKind { get }
/** \brief An Objective-C \@interface for a category. */
// public var CXCursor_ObjCCategoryDecl: CXCursorKind { get }
/** \brief An Objective-C \@protocol declaration. */
// public var CXCursor_ObjCProtocolDecl: CXCursorKind { get }
/** \brief An Objective-C \@property declaration. */
// public var CXCursor_ObjCPropertyDecl: CXCursorKind { get }
/** \brief An Objective-C instance variable. */
// public var CXCursor_ObjCIvarDecl: CXCursorKind { get }
/** \brief An Objective-C instance method. */
// public var CXCursor_ObjCInstanceMethodDecl: CXCursorKind { get }
/** \brief An Objective-C class method. */
// public var CXCursor_ObjCClassMethodDecl: CXCursorKind { get }
/** \brief An Objective-C \@implementation. */
// public var CXCursor_ObjCImplementationDecl: CXCursorKind { get }
/** \brief An Objective-C \@implementation for a category. */
// public var CXCursor_ObjCCategoryImplDecl: CXCursorKind { get }
/** \brief A typedef. */
// public var CXCursor_TypedefDecl: CXCursorKind { get }
/** \brief A C++ class method. */
// public var CXCursor_CXXMethod: CXCursorKind { get }
/** \brief A C++ namespace. */
// public var CXCursor_Namespace: CXCursorKind { get }
/** \brief A linkage specification, e.g. 'extern "C"'. */
// public var CXCursor_LinkageSpec: CXCursorKind { get }
/** \brief A C++ constructor. */
// public var CXCursor_Constructor: CXCursorKind { get }
/** \brief A C++ destructor. */
// public var CXCursor_Destructor: CXCursorKind { get }
/** \brief A C++ conversion function. */
// public var CXCursor_ConversionFunction: CXCursorKind { get }
/** \brief A C++ template type parameter. */
// public var CXCursor_TemplateTypeParameter: CXCursorKind { get }
/** \brief A C++ non-type template parameter. */
// public var CXCursor_NonTypeTemplateParameter: CXCursorKind { get }
/** \brief A C++ template template parameter. */
// public var CXCursor_TemplateTemplateParameter: CXCursorKind { get }
/** \brief A C++ function template. */
// public var CXCursor_FunctionTemplate: CXCursorKind { get }
/** \brief A C++ class template. */
// public var CXCursor_ClassTemplate: CXCursorKind { get }
/** \brief A C++ class template partial specialization. */
// public var CXCursor_ClassTemplatePartialSpecialization: CXCursorKind { get }
/** \brief A C++ namespace alias declaration. */
// public var CXCursor_NamespaceAlias: CXCursorKind { get }
/** \brief A C++ using directive. */
// public var CXCursor_UsingDirective: CXCursorKind { get }
/** \brief A C++ using declaration. */
// public var CXCursor_UsingDeclaration: CXCursorKind { get }
/** \brief A C++ alias declaration */
// public var CXCursor_TypeAliasDecl: CXCursorKind { get }
/** \brief An Objective-C \@synthesize definition. */
// public var CXCursor_ObjCSynthesizeDecl: CXCursorKind { get }
/** \brief An Objective-C \@dynamic definition. */
// public var CXCursor_ObjCDynamicDecl: CXCursorKind { get }
/** \brief An access specifier. */
// public var CXCursor_CXXAccessSpecifier: CXCursorKind { get }

/** \brief An access specifier. */
// public var CXCursor_FirstDecl: CXCursorKind { get }
/** \brief An access specifier. */
// public var CXCursor_LastDecl: CXCursorKind { get }

/* References */
/** \brief An access specifier. */
// public var CXCursor_FirstRef: CXCursorKind { get } /* Decl references */
/** \brief An access specifier. */
// public var CXCursor_ObjCSuperClassRef: CXCursorKind { get }
/** \brief An access specifier. */
// public var CXCursor_ObjCProtocolRef: CXCursorKind { get }
/** \brief An access specifier. */
// public var CXCursor_ObjCClassRef: CXCursorKind { get }
/**
 * \brief A reference to a type declaration.
 *
 * A type reference occurs anywhere where a type is named but not
 * declared. For example, given:
 *
 * \code
 * typedef unsigned size_type;
 * size_type size;
 * \endcode
 *
 * The typedef is a declaration of size_type (CXCursor_TypedefDecl),
 * while the type of the variable "size" is referenced. The cursor
 * referenced by the type of size is the typedef for size_type.
 */
// public var CXCursor_TypeRef: CXCursorKind { get }
/**
 * \brief A reference to a type declaration.
 *
 * A type reference occurs anywhere where a type is named but not
 * declared. For example, given:
 *
 * \code
 * typedef unsigned size_type;
 * size_type size;
 * \endcode
 *
 * The typedef is a declaration of size_type (CXCursor_TypedefDecl),
 * while the type of the variable "size" is referenced. The cursor
 * referenced by the type of size is the typedef for size_type.
 */
// public var CXCursor_CXXBaseSpecifier: CXCursorKind { get }
/** 
 * \brief A reference to a class template, function template, template
 * template parameter, or class template partial specialization.
 */
// public var CXCursor_TemplateRef: CXCursorKind { get }
/**
 * \brief A reference to a namespace or namespace alias.
 */
// public var CXCursor_NamespaceRef: CXCursorKind { get }
/**
 * \brief A reference to a member of a struct, union, or class that occurs in 
 * some non-expression context, e.g., a designated initializer.
 */
// public var CXCursor_MemberRef: CXCursorKind { get }
/**
 * \brief A reference to a labeled statement.
 *
 * This cursor kind is used to describe the jump to "start_over" in the 
 * goto statement in the following example:
 *
 * \code
 *   start_over:
 *     ++counter;
 *
 *     goto start_over;
 * \endcode
 *
 * A label reference cursor refers to a label statement.
 */
// public var CXCursor_LabelRef: CXCursorKind { get }

/**
 * \brief A reference to a set of overloaded functions or function templates
 * that has not yet been resolved to a specific function or function template.
 *
 * An overloaded declaration reference cursor occurs in C++ templates where
 * a dependent name refers to a function. For example:
 *
 * \code
 * template<typename T> void swap(T&, T&);
 *
 * struct X { ... };
 * void swap(X&, X&);
 *
 * template<typename T>
 * void reverse(T* first, T* last) {
 *   while (first < last - 1) {
 *     swap(*first, *--last);
 *     ++first;
 *   }
 * }
 *
 * struct Y { };
 * void swap(Y&, Y&);
 * \endcode
 *
 * Here, the identifier "swap" is associated with an overloaded declaration
 * reference. In the template definition, "swap" refers to either of the two
 * "swap" functions declared above, so both results will be available. At
 * instantiation time, "swap" may also refer to other functions found via
 * argument-dependent lookup (e.g., the "swap" function at the end of the
 * example).
 *
 * The functions \c clang_getNumOverloadedDecls() and 
 * \c clang_getOverloadedDecl() can be used to retrieve the definitions
 * referenced by this cursor.
 */
// public var CXCursor_OverloadedDeclRef: CXCursorKind { get }

/**
 * \brief A reference to a variable that occurs in some non-expression 
 * context, e.g., a C++ lambda capture list.
 */
// public var CXCursor_VariableRef: CXCursorKind { get }

/**
 * \brief A reference to a variable that occurs in some non-expression 
 * context, e.g., a C++ lambda capture list.
 */
// public var CXCursor_LastRef: CXCursorKind { get }

/* Error conditions */
/**
 * \brief A reference to a variable that occurs in some non-expression 
 * context, e.g., a C++ lambda capture list.
 */
// public var CXCursor_FirstInvalid: CXCursorKind { get }
/**
 * \brief A reference to a variable that occurs in some non-expression 
 * context, e.g., a C++ lambda capture list.
 */
// public var CXCursor_InvalidFile: CXCursorKind { get }
/**
 * \brief A reference to a variable that occurs in some non-expression 
 * context, e.g., a C++ lambda capture list.
 */
// public var CXCursor_NoDeclFound: CXCursorKind { get }
/**
 * \brief A reference to a variable that occurs in some non-expression 
 * context, e.g., a C++ lambda capture list.
 */
// public var CXCursor_NotImplemented: CXCursorKind { get }
/**
 * \brief A reference to a variable that occurs in some non-expression 
 * context, e.g., a C++ lambda capture list.
 */
// public var CXCursor_InvalidCode: CXCursorKind { get }
/**
 * \brief A reference to a variable that occurs in some non-expression 
 * context, e.g., a C++ lambda capture list.
 */
// public var CXCursor_LastInvalid: CXCursorKind { get }

/* Expressions */
/**
 * \brief A reference to a variable that occurs in some non-expression 
 * context, e.g., a C++ lambda capture list.
 */
// public var CXCursor_FirstExpr: CXCursorKind { get }

/**
 * \brief An expression whose specific kind is not exposed via this
 * interface.
 *
 * Unexposed expressions have the same operations as any other kind
 * of expression; one can extract their location information,
 * spelling, children, etc. However, the specific kind of the
 * expression is not reported.
 */
// public var CXCursor_UnexposedExpr: CXCursorKind { get }

/**
 * \brief An expression that refers to some value declaration, such
 * as a function, variable, or enumerator.
 */
// public var CXCursor_DeclRefExpr: CXCursorKind { get }

/**
 * \brief An expression that refers to a member of a struct, union,
 * class, Objective-C class, etc.
 */
// public var CXCursor_MemberRefExpr: CXCursorKind { get }

/** \brief An expression that calls a function. */
// public var CXCursor_CallExpr: CXCursorKind { get }

/** \brief An expression that sends a message to an Objective-C
 object or class. */
// public var CXCursor_ObjCMessageExpr: CXCursorKind { get }

/** \brief An expression that represents a block literal. */
// public var CXCursor_BlockExpr: CXCursorKind { get }

/** \brief An integer literal.
 */
// public var CXCursor_IntegerLiteral: CXCursorKind { get }

/** \brief A floating point number literal.
 */
// public var CXCursor_FloatingLiteral: CXCursorKind { get }

/** \brief An imaginary number literal.
 */
// public var CXCursor_ImaginaryLiteral: CXCursorKind { get }

/** \brief A string literal.
 */
// public var CXCursor_StringLiteral: CXCursorKind { get }

/** \brief A character literal.
 */
// public var CXCursor_CharacterLiteral: CXCursorKind { get }

/** \brief A parenthesized expression, e.g. "(1)".
 *
 * This AST node is only formed if full location information is requested.
 */
// public var CXCursor_ParenExpr: CXCursorKind { get }

/** \brief This represents the unary-expression's (except sizeof and
 * alignof).
 */
// public var CXCursor_UnaryOperator: CXCursorKind { get }

/** \brief [C99 6.5.2.1] Array Subscripting.
 */
// public var CXCursor_ArraySubscriptExpr: CXCursorKind { get }

/** \brief A builtin binary operation expression such as "x + y" or
 * "x <= y".
 */
// public var CXCursor_BinaryOperator: CXCursorKind { get }

/** \brief Compound assignment such as "+=".
 */
// public var CXCursor_CompoundAssignOperator: CXCursorKind { get }

/** \brief The ?: ternary operator.
 */
// public var CXCursor_ConditionalOperator: CXCursorKind { get }

/** \brief An explicit cast in C (C99 6.5.4) or a C-style cast in C++
 * (C++ [expr.cast]), which uses the syntax (Type)expr.
 *
 * For example: (int)f.
 */
// public var CXCursor_CStyleCastExpr: CXCursorKind { get }

/** \brief [C99 6.5.2.5]
 */
// public var CXCursor_CompoundLiteralExpr: CXCursorKind { get }

/** \brief Describes an C or C++ initializer list.
 */
// public var CXCursor_InitListExpr: CXCursorKind { get }

/** \brief The GNU address of label extension, representing &&label.
 */
// public var CXCursor_AddrLabelExpr: CXCursorKind { get }

/** \brief This is the GNU Statement Expression extension: ({int X=4; X;})
 */
// public var CXCursor_StmtExpr: CXCursorKind { get }

/** \brief Represents a C11 generic selection.
 */
// public var CXCursor_GenericSelectionExpr: CXCursorKind { get }

/** \brief Implements the GNU __null extension, which is a name for a null
 * pointer constant that has integral type (e.g., int or long) and is the same
 * size and alignment as a pointer.
 *
 * The __null extension is typically only used by system headers, which define
 * NULL as __null in C++ rather than using 0 (which is an integer that may not
 * match the size of a pointer).
 */
// public var CXCursor_GNUNullExpr: CXCursorKind { get }

/** \brief C++'s static_cast<> expression.
 */
// public var CXCursor_CXXStaticCastExpr: CXCursorKind { get }

/** \brief C++'s dynamic_cast<> expression.
 */
// public var CXCursor_CXXDynamicCastExpr: CXCursorKind { get }

/** \brief C++'s reinterpret_cast<> expression.
 */
// public var CXCursor_CXXReinterpretCastExpr: CXCursorKind { get }

/** \brief C++'s const_cast<> expression.
 */
// public var CXCursor_CXXConstCastExpr: CXCursorKind { get }

/** \brief Represents an explicit C++ type conversion that uses "functional"
 * notion (C++ [expr.type.conv]).
 *
 * Example:
 * \code
 *   x = int(0.5);
 * \endcode
 */
// public var CXCursor_CXXFunctionalCastExpr: CXCursorKind { get }

/** \brief A C++ typeid expression (C++ [expr.typeid]).
 */
// public var CXCursor_CXXTypeidExpr: CXCursorKind { get }

/** \brief [C++ 2.13.5] C++ Boolean Literal.
 */
// public var CXCursor_CXXBoolLiteralExpr: CXCursorKind { get }

/** \brief [C++0x 2.14.7] C++ Pointer Literal.
 */
// public var CXCursor_CXXNullPtrLiteralExpr: CXCursorKind { get }

/** \brief Represents the "this" expression in C++
 */
// public var CXCursor_CXXThisExpr: CXCursorKind { get }

/** \brief [C++ 15] C++ Throw Expression.
 *
 * This handles 'throw' and 'throw' assignment-expression. When
 * assignment-expression isn't present, Op will be null.
 */
// public var CXCursor_CXXThrowExpr: CXCursorKind { get }

/** \brief A new expression for memory allocation and constructor calls, e.g:
 * "new CXXNewExpr(foo)".
 */
// public var CXCursor_CXXNewExpr: CXCursorKind { get }

/** \brief A delete expression for memory deallocation and destructor calls,
 * e.g. "delete[] pArray".
 */
// public var CXCursor_CXXDeleteExpr: CXCursorKind { get }

/** \brief A unary expression.
 */
// public var CXCursor_UnaryExpr: CXCursorKind { get }

/** \brief An Objective-C string literal i.e. @"foo".
 */
// public var CXCursor_ObjCStringLiteral: CXCursorKind { get }

/** \brief An Objective-C \@encode expression.
 */
// public var CXCursor_ObjCEncodeExpr: CXCursorKind { get }

/** \brief An Objective-C \@selector expression.
 */
// public var CXCursor_ObjCSelectorExpr: CXCursorKind { get }

/** \brief An Objective-C \@protocol expression.
 */
// public var CXCursor_ObjCProtocolExpr: CXCursorKind { get }

/** \brief An Objective-C "bridged" cast expression, which casts between
 * Objective-C pointers and C pointers, transferring ownership in the process.
 *
 * \code
 *   NSString *str = (__bridge_transfer NSString *)CFCreateString();
 * \endcode
 */
// public var CXCursor_ObjCBridgedCastExpr: CXCursorKind { get }

/** \brief Represents a C++0x pack expansion that produces a sequence of
 * expressions.
 *
 * A pack expansion expression contains a pattern (which itself is an
 * expression) followed by an ellipsis. For example:
 *
 * \code
 * template<typename F, typename ...Types>
 * void forward(F f, Types &&...args) {
 *  f(static_cast<Types&&>(args)...);
 * }
 * \endcode
 */
// public var CXCursor_PackExpansionExpr: CXCursorKind { get }

/** \brief Represents an expression that computes the length of a parameter
 * pack.
 *
 * \code
 * template<typename ...Types>
 * struct count {
 *   static const unsigned value = sizeof...(Types);
 * };
 * \endcode
 */
// public var CXCursor_SizeOfPackExpr: CXCursorKind { get }

/* \brief Represents a C++ lambda expression that produces a local function
 * object.
 *
 * \code
 * void abssort(float *x, unsigned N) {
 *   std::sort(x, x + N,
 *             [](float a, float b) {
 *               return std::abs(a) < std::abs(b);
 *             });
 * }
 * \endcode
 */
// public var CXCursor_LambdaExpr: CXCursorKind { get }

/** \brief Objective-c Boolean Literal.
 */
// public var CXCursor_ObjCBoolLiteralExpr: CXCursorKind { get }

/** \brief Represents the "self" expression in an Objective-C method.
 */
// public var CXCursor_ObjCSelfExpr: CXCursorKind { get }

/** \brief OpenMP 4.0 [2.4, Array Section].
 */
// public var CXCursor_OMPArraySectionExpr: CXCursorKind { get }

/** \brief OpenMP 4.0 [2.4, Array Section].
 */
// public var CXCursor_LastExpr: CXCursorKind { get }

/* Statements */
/** \brief OpenMP 4.0 [2.4, Array Section].
 */
// public var CXCursor_FirstStmt: CXCursorKind { get }
/**
 * \brief A statement whose specific kind is not exposed via this
 * interface.
 *
 * Unexposed statements have the same operations as any other kind of
 * statement; one can extract their location information, spelling,
 * children, etc. However, the specific kind of the statement is not
 * reported.
 */
// public var CXCursor_UnexposedStmt: CXCursorKind { get }

/** \brief A labelled statement in a function. 
 *
 * This cursor kind is used to describe the "start_over:" label statement in 
 * the following example:
 *
 * \code
 *   start_over:
 *     ++counter;
 * \endcode
 *
 */
// public var CXCursor_LabelStmt: CXCursorKind { get }

/** \brief A group of statements like { stmt stmt }.
 *
 * This cursor kind is used to describe compound statements, e.g. function
 * bodies.
 */
// public var CXCursor_CompoundStmt: CXCursorKind { get }

/** \brief A case statement.
 */
// public var CXCursor_CaseStmt: CXCursorKind { get }

/** \brief A default statement.
 */
// public var CXCursor_DefaultStmt: CXCursorKind { get }

/** \brief An if statement
 */
// public var CXCursor_IfStmt: CXCursorKind { get }

/** \brief A switch statement.
 */
// public var CXCursor_SwitchStmt: CXCursorKind { get }

/** \brief A while statement.
 */
// public var CXCursor_WhileStmt: CXCursorKind { get }

/** \brief A do statement.
 */
// public var CXCursor_DoStmt: CXCursorKind { get }

/** \brief A for statement.
 */
// public var CXCursor_ForStmt: CXCursorKind { get }

/** \brief A goto statement.
 */
// public var CXCursor_GotoStmt: CXCursorKind { get }

/** \brief An indirect goto statement.
 */
// public var CXCursor_IndirectGotoStmt: CXCursorKind { get }

/** \brief A continue statement.
 */
// public var CXCursor_ContinueStmt: CXCursorKind { get }

/** \brief A break statement.
 */
// public var CXCursor_BreakStmt: CXCursorKind { get }

/** \brief A return statement.
 */
// public var CXCursor_ReturnStmt: CXCursorKind { get }

/** \brief A GCC inline assembly statement extension.
 */
// public var CXCursor_GCCAsmStmt: CXCursorKind { get }
/** \brief A GCC inline assembly statement extension.
 */
// public var CXCursor_AsmStmt: CXCursorKind { get }

/** \brief Objective-C's overall \@try-\@catch-\@finally statement.
 */
// public var CXCursor_ObjCAtTryStmt: CXCursorKind { get }

/** \brief Objective-C's \@catch statement.
 */
// public var CXCursor_ObjCAtCatchStmt: CXCursorKind { get }

/** \brief Objective-C's \@finally statement.
 */
// public var CXCursor_ObjCAtFinallyStmt: CXCursorKind { get }

/** \brief Objective-C's \@throw statement.
 */
// public var CXCursor_ObjCAtThrowStmt: CXCursorKind { get }

/** \brief Objective-C's \@synchronized statement.
 */
// public var CXCursor_ObjCAtSynchronizedStmt: CXCursorKind { get }

/** \brief Objective-C's autorelease pool statement.
 */
// public var CXCursor_ObjCAutoreleasePoolStmt: CXCursorKind { get }

/** \brief Objective-C's collection statement.
 */
// public var CXCursor_ObjCForCollectionStmt: CXCursorKind { get }

/** \brief C++'s catch statement.
 */
// public var CXCursor_CXXCatchStmt: CXCursorKind { get }

/** \brief C++'s try statement.
 */
// public var CXCursor_CXXTryStmt: CXCursorKind { get }

/** \brief C++'s for (* : *) statement.
 */
// public var CXCursor_CXXForRangeStmt: CXCursorKind { get }

/** \brief Windows Structured Exception Handling's try statement.
 */
// public var CXCursor_SEHTryStmt: CXCursorKind { get }

/** \brief Windows Structured Exception Handling's except statement.
 */
// public var CXCursor_SEHExceptStmt: CXCursorKind { get }

/** \brief Windows Structured Exception Handling's finally statement.
 */
// public var CXCursor_SEHFinallyStmt: CXCursorKind { get }

/** \brief A MS inline assembly statement extension.
 */
// public var CXCursor_MSAsmStmt: CXCursorKind { get }

/** \brief The null statement ";": C99 6.8.3p3.
 *
 * This cursor kind is used to describe the null statement.
 */
// public var CXCursor_NullStmt: CXCursorKind { get }

/** \brief Adaptor class for mixing declarations with statements and
 * expressions.
 */
// public var CXCursor_DeclStmt: CXCursorKind { get }

/** \brief OpenMP parallel directive.
 */
// public var CXCursor_OMPParallelDirective: CXCursorKind { get }

/** \brief OpenMP SIMD directive.
 */
// public var CXCursor_OMPSimdDirective: CXCursorKind { get }

/** \brief OpenMP for directive.
 */
// public var CXCursor_OMPForDirective: CXCursorKind { get }

/** \brief OpenMP sections directive.
 */
// public var CXCursor_OMPSectionsDirective: CXCursorKind { get }

/** \brief OpenMP section directive.
 */
// public var CXCursor_OMPSectionDirective: CXCursorKind { get }

/** \brief OpenMP single directive.
 */
// public var CXCursor_OMPSingleDirective: CXCursorKind { get }

/** \brief OpenMP parallel for directive.
 */
// public var CXCursor_OMPParallelForDirective: CXCursorKind { get }

/** \brief OpenMP parallel sections directive.
 */
// public var CXCursor_OMPParallelSectionsDirective: CXCursorKind { get }

/** \brief OpenMP task directive.
 */
// public var CXCursor_OMPTaskDirective: CXCursorKind { get }

/** \brief OpenMP master directive.
 */
// public var CXCursor_OMPMasterDirective: CXCursorKind { get }

/** \brief OpenMP critical directive.
 */
// public var CXCursor_OMPCriticalDirective: CXCursorKind { get }

/** \brief OpenMP taskyield directive.
 */
// public var CXCursor_OMPTaskyieldDirective: CXCursorKind { get }

/** \brief OpenMP barrier directive.
 */
// public var CXCursor_OMPBarrierDirective: CXCursorKind { get }

/** \brief OpenMP taskwait directive.
 */
// public var CXCursor_OMPTaskwaitDirective: CXCursorKind { get }

/** \brief OpenMP flush directive.
 */
// public var CXCursor_OMPFlushDirective: CXCursorKind { get }

/** \brief Windows Structured Exception Handling's leave statement.
 */
// public var CXCursor_SEHLeaveStmt: CXCursorKind { get }

/** \brief OpenMP ordered directive.
 */
// public var CXCursor_OMPOrderedDirective: CXCursorKind { get }

/** \brief OpenMP atomic directive.
 */
// public var CXCursor_OMPAtomicDirective: CXCursorKind { get }

/** \brief OpenMP for SIMD directive.
 */
// public var CXCursor_OMPForSimdDirective: CXCursorKind { get }

/** \brief OpenMP parallel for SIMD directive.
 */
// public var CXCursor_OMPParallelForSimdDirective: CXCursorKind { get }

/** \brief OpenMP target directive.
 */
// public var CXCursor_OMPTargetDirective: CXCursorKind { get }

/** \brief OpenMP teams directive.
 */
// public var CXCursor_OMPTeamsDirective: CXCursorKind { get }

/** \brief OpenMP taskgroup directive.
 */
// public var CXCursor_OMPTaskgroupDirective: CXCursorKind { get }

/** \brief OpenMP cancellation point directive.
 */
// public var CXCursor_OMPCancellationPointDirective: CXCursorKind { get }

/** \brief OpenMP cancel directive.
 */
// public var CXCursor_OMPCancelDirective: CXCursorKind { get }

/** \brief OpenMP target data directive.
 */
// public var CXCursor_OMPTargetDataDirective: CXCursorKind { get }

/** \brief OpenMP target data directive.
 */
// public var CXCursor_LastStmt: CXCursorKind { get }

/**
 * \brief Cursor that represents the translation unit itself.
 *
 * The translation unit cursor exists primarily to act as the root
 * cursor for traversing the contents of a translation unit.
 */
// public var CXCursor_TranslationUnit: CXCursorKind { get }

/* Attributes */
/**
 * \brief Cursor that represents the translation unit itself.
 *
 * The translation unit cursor exists primarily to act as the root
 * cursor for traversing the contents of a translation unit.
 */
// public var CXCursor_FirstAttr: CXCursorKind { get }
/**
 * \brief An attribute whose specific kind is not exposed via this
 * interface.
 */
// public var CXCursor_UnexposedAttr: CXCursorKind { get }

/**
 * \brief An attribute whose specific kind is not exposed via this
 * interface.
 */
// public var CXCursor_IBActionAttr: CXCursorKind { get }
/**
 * \brief An attribute whose specific kind is not exposed via this
 * interface.
 */
// public var CXCursor_IBOutletAttr: CXCursorKind { get }
/**
 * \brief An attribute whose specific kind is not exposed via this
 * interface.
 */
// public var CXCursor_IBOutletCollectionAttr: CXCursorKind { get }
/**
 * \brief An attribute whose specific kind is not exposed via this
 * interface.
 */
// public var CXCursor_CXXFinalAttr: CXCursorKind { get }
/**
 * \brief An attribute whose specific kind is not exposed via this
 * interface.
 */
// public var CXCursor_CXXOverrideAttr: CXCursorKind { get }
/**
 * \brief An attribute whose specific kind is not exposed via this
 * interface.
 */
// public var CXCursor_AnnotateAttr: CXCursorKind { get }
/**
 * \brief An attribute whose specific kind is not exposed via this
 * interface.
 */
// public var CXCursor_AsmLabelAttr: CXCursorKind { get }
/**
 * \brief An attribute whose specific kind is not exposed via this
 * interface.
 */
// public var CXCursor_PackedAttr: CXCursorKind { get }
/**
 * \brief An attribute whose specific kind is not exposed via this
 * interface.
 */
// public var CXCursor_PureAttr: CXCursorKind { get }
/**
 * \brief An attribute whose specific kind is not exposed via this
 * interface.
 */
// public var CXCursor_ConstAttr: CXCursorKind { get }
/**
 * \brief An attribute whose specific kind is not exposed via this
 * interface.
 */
// public var CXCursor_NoDuplicateAttr: CXCursorKind { get }
/**
 * \brief An attribute whose specific kind is not exposed via this
 * interface.
 */
// public var CXCursor_CUDAConstantAttr: CXCursorKind { get }
/**
 * \brief An attribute whose specific kind is not exposed via this
 * interface.
 */
// public var CXCursor_CUDADeviceAttr: CXCursorKind { get }
/**
 * \brief An attribute whose specific kind is not exposed via this
 * interface.
 */
// public var CXCursor_CUDAGlobalAttr: CXCursorKind { get }
/**
 * \brief An attribute whose specific kind is not exposed via this
 * interface.
 */
// public var CXCursor_CUDAHostAttr: CXCursorKind { get }
/**
 * \brief An attribute whose specific kind is not exposed via this
 * interface.
 */
// public var CXCursor_CUDASharedAttr: CXCursorKind { get }
/**
 * \brief An attribute whose specific kind is not exposed via this
 * interface.
 */
// public var CXCursor_VisibilityAttr: CXCursorKind { get }
/**
 * \brief An attribute whose specific kind is not exposed via this
 * interface.
 */
// public var CXCursor_LastAttr: CXCursorKind { get }

/* Preprocessing */
/**
 * \brief An attribute whose specific kind is not exposed via this
 * interface.
 */
// public var CXCursor_PreprocessingDirective: CXCursorKind { get }
/**
 * \brief An attribute whose specific kind is not exposed via this
 * interface.
 */
// public var CXCursor_MacroDefinition: CXCursorKind { get }
/**
 * \brief An attribute whose specific kind is not exposed via this
 * interface.
 */
// public var CXCursor_MacroExpansion: CXCursorKind { get }
/**
 * \brief An attribute whose specific kind is not exposed via this
 * interface.
 */
// public var CXCursor_MacroInstantiation: CXCursorKind { get }
/**
 * \brief An attribute whose specific kind is not exposed via this
 * interface.
 */
// public var CXCursor_InclusionDirective: CXCursorKind { get }
/**
 * \brief An attribute whose specific kind is not exposed via this
 * interface.
 */
// public var CXCursor_FirstPreprocessing: CXCursorKind { get }
/**
 * \brief An attribute whose specific kind is not exposed via this
 * interface.
 */
// public var CXCursor_LastPreprocessing: CXCursorKind { get }

/* Extra Declarations */
/**
 * \brief A module import declaration.
 */
// public var CXCursor_ModuleImportDecl: CXCursorKind { get }
/**
 * \brief A module import declaration.
 */
// public var CXCursor_FirstExtraDecl: CXCursorKind { get }
/**
 * \brief A module import declaration.
 */
// public var CXCursor_LastExtraDecl: CXCursorKind { get }

/**
 * \brief A code completion overload candidate.
 */
// public var CXCursor_OverloadCandidate: CXCursorKind { get }

/**
 * \brief A cursor representing some element in the abstract syntax tree for
 * a translation unit.
 *
 * The cursor abstraction unifies the different kinds of entities in a
 * program--declaration, statements, expressions, references to declarations,
 * etc.--under a single "cursor" abstraction with a common set of operations.
 * Common operation for a cursor include: getting the physical location in
 * a source file where the cursor points, getting the name associated with a
 * cursor, and retrieving cursors for any child nodes of a particular cursor.
 *
 * Cursors can be produced in two specific ways.
 * clang_getTranslationUnitCursor() produces a cursor for a translation unit,
 * from which one can use clang_visitChildren() to explore the rest of the
 * translation unit. clang_getCursor() maps from a physical source location
 * to the entity that resides at that location, allowing one to map from the
 * source code into the AST.
 */
/*
public struct CXCursor {
    public var kind: CXCursorKind
    public var xdata: Int32
    public var data: (UnsafePointer<Void>, UnsafePointer<Void>, UnsafePointer<Void>)
    public init()
    public init(kind: CXCursorKind, xdata: Int32, data: (UnsafePointer<Void>, UnsafePointer<Void>, UnsafePointer<Void>))
}
*/

/**
 * \defgroup CINDEX_CURSOR_MANIP Cursor manipulations
 *
 * @{
 */

/**
 * \brief Retrieve the NULL cursor, which represents no entity.
 */
public func clang_getNullCursor() -> CXCursor {
    return _clang_getNullCursor()
}
private let _clang_getNullCursor: @convention(c) () -> CXCursor = library.loadSymbol("clang_getNullCursor")


/**
 * \brief Retrieve the cursor that represents the given translation unit.
 *
 * The translation unit cursor can be used to start traversing the
 * various declarations within the given translation unit.
 */
public func clang_getTranslationUnitCursor(unnamed1: CXTranslationUnit) -> CXCursor {
    return _clang_getTranslationUnitCursor(unnamed1)
}
private let _clang_getTranslationUnitCursor: @convention(c) (_: CXTranslationUnit) -> CXCursor = library.loadSymbol("clang_getTranslationUnitCursor")


/**
 * \brief Determine whether two cursors are equivalent.
 */
public func clang_equalCursors(unnamed1: CXCursor, _ unnamed2: CXCursor) -> UInt32 {
    return _clang_equalCursors(unnamed1, unnamed2)
}
private let _clang_equalCursors: @convention(c) (_: CXCursor, _: CXCursor) -> UInt32 = library.loadSymbol("clang_equalCursors")


/**
 * \brief Returns non-zero if \p cursor is null.
 */
public func clang_Cursor_isNull(cursor: CXCursor) -> Int32 {
    return _clang_Cursor_isNull(cursor: cursor)
}
private let _clang_Cursor_isNull: @convention(c) (cursor: CXCursor) -> Int32 = library.loadSymbol("clang_Cursor_isNull")


/**
 * \brief Compute a hash value for the given cursor.
 */
public func clang_hashCursor(unnamed1: CXCursor) -> UInt32 {
    return _clang_hashCursor(unnamed1)
}
private let _clang_hashCursor: @convention(c) (_: CXCursor) -> UInt32 = library.loadSymbol("clang_hashCursor")


/**
 * \brief Retrieve the kind of the given cursor.
 */
public func clang_getCursorKind(unnamed1: CXCursor) -> CXCursorKind {
    return _clang_getCursorKind(unnamed1)
}
private let _clang_getCursorKind: @convention(c) (_: CXCursor) -> CXCursorKind = library.loadSymbol("clang_getCursorKind")


/**
 * \brief Determine whether the given cursor kind represents a declaration.
 */
public func clang_isDeclaration(unnamed1: CXCursorKind) -> UInt32 {
    return _clang_isDeclaration(unnamed1)
}
private let _clang_isDeclaration: @convention(c) (_: CXCursorKind) -> UInt32 = library.loadSymbol("clang_isDeclaration")


/**
 * \brief Determine whether the given cursor kind represents a simple
 * reference.
 *
 * Note that other kinds of cursors (such as expressions) can also refer to
 * other cursors. Use clang_getCursorReferenced() to determine whether a
 * particular cursor refers to another entity.
 */
public func clang_isReference(unnamed1: CXCursorKind) -> UInt32 {
    return _clang_isReference(unnamed1)
}
private let _clang_isReference: @convention(c) (_: CXCursorKind) -> UInt32 = library.loadSymbol("clang_isReference")


/**
 * \brief Determine whether the given cursor kind represents an expression.
 */
public func clang_isExpression(unnamed1: CXCursorKind) -> UInt32 {
    return _clang_isExpression(unnamed1)
}
private let _clang_isExpression: @convention(c) (_: CXCursorKind) -> UInt32 = library.loadSymbol("clang_isExpression")


/**
 * \brief Determine whether the given cursor kind represents a statement.
 */
public func clang_isStatement(unnamed1: CXCursorKind) -> UInt32 {
    return _clang_isStatement(unnamed1)
}
private let _clang_isStatement: @convention(c) (_: CXCursorKind) -> UInt32 = library.loadSymbol("clang_isStatement")


/**
 * \brief Determine whether the given cursor kind represents an attribute.
 */
public func clang_isAttribute(unnamed1: CXCursorKind) -> UInt32 {
    return _clang_isAttribute(unnamed1)
}
private let _clang_isAttribute: @convention(c) (_: CXCursorKind) -> UInt32 = library.loadSymbol("clang_isAttribute")


/**
 * \brief Determine whether the given cursor kind represents an invalid
 * cursor.
 */
public func clang_isInvalid(unnamed1: CXCursorKind) -> UInt32 {
    return _clang_isInvalid(unnamed1)
}
private let _clang_isInvalid: @convention(c) (_: CXCursorKind) -> UInt32 = library.loadSymbol("clang_isInvalid")


/**
 * \brief Determine whether the given cursor kind represents a translation
 * unit.
 */
public func clang_isTranslationUnit(unnamed1: CXCursorKind) -> UInt32 {
    return _clang_isTranslationUnit(unnamed1)
}
private let _clang_isTranslationUnit: @convention(c) (_: CXCursorKind) -> UInt32 = library.loadSymbol("clang_isTranslationUnit")


/***
 * \brief Determine whether the given cursor represents a preprocessing
 * element, such as a preprocessor directive or macro instantiation.
 */
public func clang_isPreprocessing(unnamed1: CXCursorKind) -> UInt32 {
    return _clang_isPreprocessing(unnamed1)
}
private let _clang_isPreprocessing: @convention(c) (_: CXCursorKind) -> UInt32 = library.loadSymbol("clang_isPreprocessing")


/***
 * \brief Determine whether the given cursor represents a currently
 *  unexposed piece of the AST (e.g., CXCursor_UnexposedStmt).
 */
public func clang_isUnexposed(unnamed1: CXCursorKind) -> UInt32 {
    return _clang_isUnexposed(unnamed1)
}
private let _clang_isUnexposed: @convention(c) (_: CXCursorKind) -> UInt32 = library.loadSymbol("clang_isUnexposed")


/**
 * \brief Describe the linkage of the entity referred to by a cursor.
 */
/*
public struct CXLinkageKind : RawRepresentable, Equatable {
    public init(_ rawValue: UInt32)
    public init(rawValue: UInt32)
    public var rawValue: UInt32
}
*/

/** \brief This value indicates that no linkage information is available
 * for a provided CXCursor. */
// public var CXLinkage_Invalid: CXLinkageKind { get }
/**
 * \brief This is the linkage for variables, parameters, and so on that
 *  have automatic storage.  This covers normal (non-extern) local variables.
 */
// public var CXLinkage_NoLinkage: CXLinkageKind { get }
/** \brief This is the linkage for static variables and static functions. */
// public var CXLinkage_Internal: CXLinkageKind { get }
/** \brief This is the linkage for entities with external linkage that live
 * in C++ anonymous namespaces.*/
// public var CXLinkage_UniqueExternal: CXLinkageKind { get }
/** \brief This is the linkage for entities with true, external linkage. */
// public var CXLinkage_External: CXLinkageKind { get }

/**
 * \brief Determine the linkage of the entity referred to by a given cursor.
 */
public func clang_getCursorLinkage(cursor: CXCursor) -> CXLinkageKind {
    return _clang_getCursorLinkage(cursor: cursor)
}
private let _clang_getCursorLinkage: @convention(c) (cursor: CXCursor) -> CXLinkageKind = library.loadSymbol("clang_getCursorLinkage")


/**
 * \brief Determine the availability of the entity that this cursor refers to,
 * taking the current target platform into account.
 *
 * \param cursor The cursor to query.
 *
 * \returns The availability of the cursor.
 */
public func clang_getCursorAvailability(cursor: CXCursor) -> CXAvailabilityKind {
    return _clang_getCursorAvailability(cursor: cursor)
}
private let _clang_getCursorAvailability: @convention(c) (cursor: CXCursor) -> CXAvailabilityKind = library.loadSymbol("clang_getCursorAvailability")


/**
 * Describes the availability of a given entity on a particular platform, e.g.,
 * a particular class might only be available on Mac OS 10.7 or newer.
 */
/*
public struct CXPlatformAvailability {
    /**
     * \brief A string that describes the platform for which this structure
     * provides availability information.
     *
     * Possible values are "ios" or "macosx".
     */
    public var Platform: CXString
    /**
     * \brief The version number in which this entity was introduced.
     */
    public var Introduced: CXVersion
    /**
     * \brief The version number in which this entity was deprecated (but is
     * still available).
     */
    public var Deprecated: CXVersion
    /**
     * \brief The version number in which this entity was obsoleted, and therefore
     * is no longer available.
     */
    public var Obsoleted: CXVersion
    /**
     * \brief Whether the entity is unconditionally unavailable on this platform.
     */
    public var Unavailable: Int32
    /**
     * \brief An optional message to provide to a user of this API, e.g., to
     * suggest replacement APIs.
     */
    public var Message: CXString
    public init()
    public init(Platform: CXString, Introduced: CXVersion, Deprecated: CXVersion, Obsoleted: CXVersion, Unavailable: Int32, Message: CXString)
}
*/

/**
 * \brief Determine the availability of the entity that this cursor refers to
 * on any platforms for which availability information is known.
 *
 * \param cursor The cursor to query.
 *
 * \param always_deprecated If non-NULL, will be set to indicate whether the 
 * entity is deprecated on all platforms.
 *
 * \param deprecated_message If non-NULL, will be set to the message text 
 * provided along with the unconditional deprecation of this entity. The client
 * is responsible for deallocating this string.
 *
 * \param always_unavailable If non-NULL, will be set to indicate whether the
 * entity is unavailable on all platforms.
 *
 * \param unavailable_message If non-NULL, will be set to the message text
 * provided along with the unconditional unavailability of this entity. The 
 * client is responsible for deallocating this string.
 *
 * \param availability If non-NULL, an array of CXPlatformAvailability instances
 * that will be populated with platform availability information, up to either
 * the number of platforms for which availability information is available (as
 * returned by this function) or \c availability_size, whichever is smaller.
 *
 * \param availability_size The number of elements available in the 
 * \c availability array.
 *
 * \returns The number of platforms (N) for which availability information is
 * available (which is unrelated to \c availability_size).
 *
 * Note that the client is responsible for calling 
 * \c clang_disposeCXPlatformAvailability to free each of the 
 * platform-availability structures returned. There are 
 * \c min(N, availability_size) such structures.
 */
public func clang_getCursorPlatformAvailability(cursor: CXCursor, _ always_deprecated: UnsafeMutablePointer<Int32>, _ deprecated_message: UnsafeMutablePointer<CXString>, _ always_unavailable: UnsafeMutablePointer<Int32>, _ unavailable_message: UnsafeMutablePointer<CXString>, _ availability: UnsafeMutablePointer<CXPlatformAvailability>, _ availability_size: Int32) -> Int32 {
    return _clang_getCursorPlatformAvailability(cursor: cursor, always_deprecated: always_deprecated, deprecated_message: deprecated_message, always_unavailable: always_unavailable, unavailable_message: unavailable_message, availability: availability, availability_size: availability_size)
}
private let _clang_getCursorPlatformAvailability: @convention(c) (cursor: CXCursor, always_deprecated: UnsafeMutablePointer<Int32>, deprecated_message: UnsafeMutablePointer<CXString>, always_unavailable: UnsafeMutablePointer<Int32>, unavailable_message: UnsafeMutablePointer<CXString>, availability: UnsafeMutablePointer<CXPlatformAvailability>, availability_size: Int32) -> Int32 = library.loadSymbol("clang_getCursorPlatformAvailability")


/**
 * \brief Free the memory associated with a \c CXPlatformAvailability structure.
 */
public func clang_disposeCXPlatformAvailability(availability: UnsafeMutablePointer<CXPlatformAvailability>) {
    return _clang_disposeCXPlatformAvailability(availability: availability)
}
private let _clang_disposeCXPlatformAvailability: @convention(c) (availability: UnsafeMutablePointer<CXPlatformAvailability>) -> () = library.loadSymbol("clang_disposeCXPlatformAvailability")


/**
 * \brief Describe the "language" of the entity referred to by a cursor.
 */
/*
public struct CXLanguageKind : RawRepresentable, Equatable {
    public init(_ rawValue: UInt32)
    public init(rawValue: UInt32)
    public var rawValue: UInt32
}
*/
// public var CXLanguage_Invalid: CXLanguageKind { get }
// public var CXLanguage_C: CXLanguageKind { get }
// public var CXLanguage_ObjC: CXLanguageKind { get }
// public var CXLanguage_CPlusPlus: CXLanguageKind { get }

/**
 * \brief Determine the "language" of the entity referred to by a given cursor.
 */
public func clang_getCursorLanguage(cursor: CXCursor) -> CXLanguageKind {
    return _clang_getCursorLanguage(cursor: cursor)
}
private let _clang_getCursorLanguage: @convention(c) (cursor: CXCursor) -> CXLanguageKind = library.loadSymbol("clang_getCursorLanguage")


/**
 * \brief Returns the translation unit that a cursor originated from.
 */
public func clang_Cursor_getTranslationUnit(unnamed1: CXCursor) -> CXTranslationUnit {
    return _clang_Cursor_getTranslationUnit(unnamed1)
}
private let _clang_Cursor_getTranslationUnit: @convention(c) (_: CXCursor) -> CXTranslationUnit = library.loadSymbol("clang_Cursor_getTranslationUnit")


/**
 * \brief A fast container representing a set of CXCursors.
 */
// public typealias CXCursorSet = COpaquePointer

/**
 * \brief Creates an empty CXCursorSet.
 */
public func clang_createCXCursorSet() -> CXCursorSet {
    return _clang_createCXCursorSet()
}
private let _clang_createCXCursorSet: @convention(c) () -> CXCursorSet = library.loadSymbol("clang_createCXCursorSet")


/**
 * \brief Disposes a CXCursorSet and releases its associated memory.
 */
public func clang_disposeCXCursorSet(cset: CXCursorSet) {
    return _clang_disposeCXCursorSet(cset: cset)
}
private let _clang_disposeCXCursorSet: @convention(c) (cset: CXCursorSet) -> () = library.loadSymbol("clang_disposeCXCursorSet")


/**
 * \brief Queries a CXCursorSet to see if it contains a specific CXCursor.
 *
 * \returns non-zero if the set contains the specified cursor.
*/
public func clang_CXCursorSet_contains(cset: CXCursorSet, _ cursor: CXCursor) -> UInt32 {
    return _clang_CXCursorSet_contains(cset: cset, cursor: cursor)
}
private let _clang_CXCursorSet_contains: @convention(c) (cset: CXCursorSet, cursor: CXCursor) -> UInt32 = library.loadSymbol("clang_CXCursorSet_contains")


/**
 * \brief Inserts a CXCursor into a CXCursorSet.
 *
 * \returns zero if the CXCursor was already in the set, and non-zero otherwise.
*/
public func clang_CXCursorSet_insert(cset: CXCursorSet, _ cursor: CXCursor) -> UInt32 {
    return _clang_CXCursorSet_insert(cset: cset, cursor: cursor)
}
private let _clang_CXCursorSet_insert: @convention(c) (cset: CXCursorSet, cursor: CXCursor) -> UInt32 = library.loadSymbol("clang_CXCursorSet_insert")


/**
 * \brief Determine the semantic parent of the given cursor.
 *
 * The semantic parent of a cursor is the cursor that semantically contains
 * the given \p cursor. For many declarations, the lexical and semantic parents
 * are equivalent (the lexical parent is returned by 
 * \c clang_getCursorLexicalParent()). They diverge when declarations or
 * definitions are provided out-of-line. For example:
 *
 * \code
 * class C {
 *  void f();
 * };
 *
 * void C::f() { }
 * \endcode
 *
 * In the out-of-line definition of \c C::f, the semantic parent is
 * the class \c C, of which this function is a member. The lexical parent is
 * the place where the declaration actually occurs in the source code; in this
 * case, the definition occurs in the translation unit. In general, the
 * lexical parent for a given entity can change without affecting the semantics
 * of the program, and the lexical parent of different declarations of the
 * same entity may be different. Changing the semantic parent of a declaration,
 * on the other hand, can have a major impact on semantics, and redeclarations
 * of a particular entity should all have the same semantic context.
 *
 * In the example above, both declarations of \c C::f have \c C as their
 * semantic context, while the lexical context of the first \c C::f is \c C
 * and the lexical context of the second \c C::f is the translation unit.
 *
 * For global declarations, the semantic parent is the translation unit.
 */
public func clang_getCursorSemanticParent(cursor: CXCursor) -> CXCursor {
    return _clang_getCursorSemanticParent(cursor: cursor)
}
private let _clang_getCursorSemanticParent: @convention(c) (cursor: CXCursor) -> CXCursor = library.loadSymbol("clang_getCursorSemanticParent")


/**
 * \brief Determine the lexical parent of the given cursor.
 *
 * The lexical parent of a cursor is the cursor in which the given \p cursor
 * was actually written. For many declarations, the lexical and semantic parents
 * are equivalent (the semantic parent is returned by 
 * \c clang_getCursorSemanticParent()). They diverge when declarations or
 * definitions are provided out-of-line. For example:
 *
 * \code
 * class C {
 *  void f();
 * };
 *
 * void C::f() { }
 * \endcode
 *
 * In the out-of-line definition of \c C::f, the semantic parent is
 * the class \c C, of which this function is a member. The lexical parent is
 * the place where the declaration actually occurs in the source code; in this
 * case, the definition occurs in the translation unit. In general, the
 * lexical parent for a given entity can change without affecting the semantics
 * of the program, and the lexical parent of different declarations of the
 * same entity may be different. Changing the semantic parent of a declaration,
 * on the other hand, can have a major impact on semantics, and redeclarations
 * of a particular entity should all have the same semantic context.
 *
 * In the example above, both declarations of \c C::f have \c C as their
 * semantic context, while the lexical context of the first \c C::f is \c C
 * and the lexical context of the second \c C::f is the translation unit.
 *
 * For declarations written in the global scope, the lexical parent is
 * the translation unit.
 */
public func clang_getCursorLexicalParent(cursor: CXCursor) -> CXCursor {
    return _clang_getCursorLexicalParent(cursor: cursor)
}
private let _clang_getCursorLexicalParent: @convention(c) (cursor: CXCursor) -> CXCursor = library.loadSymbol("clang_getCursorLexicalParent")


/**
 * \brief Determine the set of methods that are overridden by the given
 * method.
 *
 * In both Objective-C and C++, a method (aka virtual member function,
 * in C++) can override a virtual method in a base class. For
 * Objective-C, a method is said to override any method in the class's
 * base class, its protocols, or its categories' protocols, that has the same
 * selector and is of the same kind (class or instance).
 * If no such method exists, the search continues to the class's superclass,
 * its protocols, and its categories, and so on. A method from an Objective-C
 * implementation is considered to override the same methods as its
 * corresponding method in the interface.
 *
 * For C++, a virtual member function overrides any virtual member
 * function with the same signature that occurs in its base
 * classes. With multiple inheritance, a virtual member function can
 * override several virtual member functions coming from different
 * base classes.
 *
 * In all cases, this function determines the immediate overridden
 * method, rather than all of the overridden methods. For example, if
 * a method is originally declared in a class A, then overridden in B
 * (which in inherits from A) and also in C (which inherited from B),
 * then the only overridden method returned from this function when
 * invoked on C's method will be B's method. The client may then
 * invoke this function again, given the previously-found overridden
 * methods, to map out the complete method-override set.
 *
 * \param cursor A cursor representing an Objective-C or C++
 * method. This routine will compute the set of methods that this
 * method overrides.
 * 
 * \param overridden A pointer whose pointee will be replaced with a
 * pointer to an array of cursors, representing the set of overridden
 * methods. If there are no overridden methods, the pointee will be
 * set to NULL. The pointee must be freed via a call to 
 * \c clang_disposeOverriddenCursors().
 *
 * \param num_overridden A pointer to the number of overridden
 * functions, will be set to the number of overridden functions in the
 * array pointed to by \p overridden.
 */
public func clang_getOverriddenCursors(cursor: CXCursor, _ overridden: UnsafeMutablePointer<UnsafeMutablePointer<CXCursor>>, _ num_overridden: UnsafeMutablePointer<UInt32>) {
    return _clang_getOverriddenCursors(cursor: cursor, overridden: overridden, num_overridden: num_overridden)
}
private let _clang_getOverriddenCursors: @convention(c) (cursor: CXCursor, overridden: UnsafeMutablePointer<UnsafeMutablePointer<CXCursor>>, num_overridden: UnsafeMutablePointer<UInt32>) -> () = library.loadSymbol("clang_getOverriddenCursors")


/**
 * \brief Free the set of overridden cursors returned by \c
 * clang_getOverriddenCursors().
 */
public func clang_disposeOverriddenCursors(overridden: UnsafeMutablePointer<CXCursor>) {
    return _clang_disposeOverriddenCursors(overridden: overridden)
}
private let _clang_disposeOverriddenCursors: @convention(c) (overridden: UnsafeMutablePointer<CXCursor>) -> () = library.loadSymbol("clang_disposeOverriddenCursors")


/**
 * \brief Retrieve the file that is included by the given inclusion directive
 * cursor.
 */
public func clang_getIncludedFile(cursor: CXCursor) -> CXFile {
    return _clang_getIncludedFile(cursor: cursor)
}
private let _clang_getIncludedFile: @convention(c) (cursor: CXCursor) -> CXFile = library.loadSymbol("clang_getIncludedFile")


/**
 * @}
 */

/**
 * \defgroup CINDEX_CURSOR_SOURCE Mapping between cursors and source code
 *
 * Cursors represent a location within the Abstract Syntax Tree (AST). These
 * routines help map between cursors and the physical locations where the
 * described entities occur in the source code. The mapping is provided in
 * both directions, so one can map from source code to the AST and back.
 *
 * @{
 */

/**
 * \brief Map a source location to the cursor that describes the entity at that
 * location in the source code.
 *
 * clang_getCursor() maps an arbitrary source location within a translation
 * unit down to the most specific cursor that describes the entity at that
 * location. For example, given an expression \c x + y, invoking
 * clang_getCursor() with a source location pointing to "x" will return the
 * cursor for "x"; similarly for "y". If the cursor points anywhere between
 * "x" or "y" (e.g., on the + or the whitespace around it), clang_getCursor()
 * will return a cursor referring to the "+" expression.
 *
 * \returns a cursor representing the entity at the given source location, or
 * a NULL cursor if no such entity can be found.
 */
public func clang_getCursor(unnamed1: CXTranslationUnit, _ unnamed2: CXSourceLocation) -> CXCursor {
    return _clang_getCursor(unnamed1, unnamed2)
}
private let _clang_getCursor: @convention(c) (_: CXTranslationUnit, _: CXSourceLocation) -> CXCursor = library.loadSymbol("clang_getCursor")


/**
 * \brief Retrieve the physical location of the source constructor referenced
 * by the given cursor.
 *
 * The location of a declaration is typically the location of the name of that
 * declaration, where the name of that declaration would occur if it is
 * unnamed, or some keyword that introduces that particular declaration.
 * The location of a reference is where that reference occurs within the
 * source code.
 */
public func clang_getCursorLocation(unnamed1: CXCursor) -> CXSourceLocation {
    return _clang_getCursorLocation(unnamed1)
}
private let _clang_getCursorLocation: @convention(c) (_: CXCursor) -> CXSourceLocation = library.loadSymbol("clang_getCursorLocation")


/**
 * \brief Retrieve the physical extent of the source construct referenced by
 * the given cursor.
 *
 * The extent of a cursor starts with the file/line/column pointing at the
 * first character within the source construct that the cursor refers to and
 * ends with the last character within that source construct. For a
 * declaration, the extent covers the declaration itself. For a reference,
 * the extent covers the location of the reference (e.g., where the referenced
 * entity was actually used).
 */
public func clang_getCursorExtent(unnamed1: CXCursor) -> CXSourceRange {
    return _clang_getCursorExtent(unnamed1)
}
private let _clang_getCursorExtent: @convention(c) (_: CXCursor) -> CXSourceRange = library.loadSymbol("clang_getCursorExtent")


/**
 * @}
 */

/**
 * \defgroup CINDEX_TYPES Type information for CXCursors
 *
 * @{
 */

/**
 * \brief Describes the kind of type
 */
/*
public struct CXTypeKind : RawRepresentable, Equatable {
    public init(_ rawValue: UInt32)
    public init(rawValue: UInt32)
    public var rawValue: UInt32
}
*/

/**
 * \brief Represents an invalid type (e.g., where no type is available).
 */
// public var CXType_Invalid: CXTypeKind { get }

/**
 * \brief A type whose specific kind is not exposed via this
 * interface.
 */
// public var CXType_Unexposed: CXTypeKind { get }

/* Builtin types */
/**
 * \brief A type whose specific kind is not exposed via this
 * interface.
 */
// public var CXType_Void: CXTypeKind { get }
/**
 * \brief A type whose specific kind is not exposed via this
 * interface.
 */
// public var CXType_Bool: CXTypeKind { get }
/**
 * \brief A type whose specific kind is not exposed via this
 * interface.
 */
// public var CXType_Char_U: CXTypeKind { get }
/**
 * \brief A type whose specific kind is not exposed via this
 * interface.
 */
// public var CXType_UChar: CXTypeKind { get }
/**
 * \brief A type whose specific kind is not exposed via this
 * interface.
 */
// public var CXType_Char16: CXTypeKind { get }
/**
 * \brief A type whose specific kind is not exposed via this
 * interface.
 */
// public var CXType_Char32: CXTypeKind { get }
/**
 * \brief A type whose specific kind is not exposed via this
 * interface.
 */
// public var CXType_UShort: CXTypeKind { get }
/**
 * \brief A type whose specific kind is not exposed via this
 * interface.
 */
// public var CXType_UInt: CXTypeKind { get }
/**
 * \brief A type whose specific kind is not exposed via this
 * interface.
 */
// public var CXType_ULong: CXTypeKind { get }
/**
 * \brief A type whose specific kind is not exposed via this
 * interface.
 */
// public var CXType_ULongLong: CXTypeKind { get }
/**
 * \brief A type whose specific kind is not exposed via this
 * interface.
 */
// public var CXType_UInt128: CXTypeKind { get }
/**
 * \brief A type whose specific kind is not exposed via this
 * interface.
 */
// public var CXType_Char_S: CXTypeKind { get }
/**
 * \brief A type whose specific kind is not exposed via this
 * interface.
 */
// public var CXType_SChar: CXTypeKind { get }
/**
 * \brief A type whose specific kind is not exposed via this
 * interface.
 */
// public var CXType_WChar: CXTypeKind { get }
/**
 * \brief A type whose specific kind is not exposed via this
 * interface.
 */
// public var CXType_Short: CXTypeKind { get }
/**
 * \brief A type whose specific kind is not exposed via this
 * interface.
 */
// public var CXType_Int: CXTypeKind { get }
/**
 * \brief A type whose specific kind is not exposed via this
 * interface.
 */
// public var CXType_Long: CXTypeKind { get }
/**
 * \brief A type whose specific kind is not exposed via this
 * interface.
 */
// public var CXType_LongLong: CXTypeKind { get }
/**
 * \brief A type whose specific kind is not exposed via this
 * interface.
 */
// public var CXType_Int128: CXTypeKind { get }
/**
 * \brief A type whose specific kind is not exposed via this
 * interface.
 */
// public var CXType_Float: CXTypeKind { get }
/**
 * \brief A type whose specific kind is not exposed via this
 * interface.
 */
// public var CXType_Double: CXTypeKind { get }
/**
 * \brief A type whose specific kind is not exposed via this
 * interface.
 */
// public var CXType_LongDouble: CXTypeKind { get }
/**
 * \brief A type whose specific kind is not exposed via this
 * interface.
 */
// public var CXType_NullPtr: CXTypeKind { get }
/**
 * \brief A type whose specific kind is not exposed via this
 * interface.
 */
// public var CXType_Overload: CXTypeKind { get }
/**
 * \brief A type whose specific kind is not exposed via this
 * interface.
 */
// public var CXType_Dependent: CXTypeKind { get }
/**
 * \brief A type whose specific kind is not exposed via this
 * interface.
 */
// public var CXType_ObjCId: CXTypeKind { get }
/**
 * \brief A type whose specific kind is not exposed via this
 * interface.
 */
// public var CXType_ObjCClass: CXTypeKind { get }
/**
 * \brief A type whose specific kind is not exposed via this
 * interface.
 */
// public var CXType_ObjCSel: CXTypeKind { get }
/**
 * \brief A type whose specific kind is not exposed via this
 * interface.
 */
// public var CXType_FirstBuiltin: CXTypeKind { get }
/**
 * \brief A type whose specific kind is not exposed via this
 * interface.
 */
// public var CXType_LastBuiltin: CXTypeKind { get }

/**
 * \brief A type whose specific kind is not exposed via this
 * interface.
 */
// public var CXType_Complex: CXTypeKind { get }
/**
 * \brief A type whose specific kind is not exposed via this
 * interface.
 */
// public var CXType_Pointer: CXTypeKind { get }
/**
 * \brief A type whose specific kind is not exposed via this
 * interface.
 */
// public var CXType_BlockPointer: CXTypeKind { get }
/**
 * \brief A type whose specific kind is not exposed via this
 * interface.
 */
// public var CXType_LValueReference: CXTypeKind { get }
/**
 * \brief A type whose specific kind is not exposed via this
 * interface.
 */
// public var CXType_RValueReference: CXTypeKind { get }
/**
 * \brief A type whose specific kind is not exposed via this
 * interface.
 */
// public var CXType_Record: CXTypeKind { get }
/**
 * \brief A type whose specific kind is not exposed via this
 * interface.
 */
// public var CXType_Enum: CXTypeKind { get }
/**
 * \brief A type whose specific kind is not exposed via this
 * interface.
 */
// public var CXType_Typedef: CXTypeKind { get }
/**
 * \brief A type whose specific kind is not exposed via this
 * interface.
 */
// public var CXType_ObjCInterface: CXTypeKind { get }
/**
 * \brief A type whose specific kind is not exposed via this
 * interface.
 */
// public var CXType_ObjCObjectPointer: CXTypeKind { get }
/**
 * \brief A type whose specific kind is not exposed via this
 * interface.
 */
// public var CXType_FunctionNoProto: CXTypeKind { get }
/**
 * \brief A type whose specific kind is not exposed via this
 * interface.
 */
// public var CXType_FunctionProto: CXTypeKind { get }
/**
 * \brief A type whose specific kind is not exposed via this
 * interface.
 */
// public var CXType_ConstantArray: CXTypeKind { get }
/**
 * \brief A type whose specific kind is not exposed via this
 * interface.
 */
// public var CXType_Vector: CXTypeKind { get }
/**
 * \brief A type whose specific kind is not exposed via this
 * interface.
 */
// public var CXType_IncompleteArray: CXTypeKind { get }
/**
 * \brief A type whose specific kind is not exposed via this
 * interface.
 */
// public var CXType_VariableArray: CXTypeKind { get }
/**
 * \brief A type whose specific kind is not exposed via this
 * interface.
 */
// public var CXType_DependentSizedArray: CXTypeKind { get }
/**
 * \brief A type whose specific kind is not exposed via this
 * interface.
 */
// public var CXType_MemberPointer: CXTypeKind { get }

/**
 * \brief Describes the calling convention of a function type
 */
/*
public struct CXCallingConv : RawRepresentable, Equatable {
    public init(_ rawValue: UInt32)
    public init(rawValue: UInt32)
    public var rawValue: UInt32
}
*/
// public var CXCallingConv_Default: CXCallingConv { get }
// public var CXCallingConv_C: CXCallingConv { get }
// public var CXCallingConv_X86StdCall: CXCallingConv { get }
// public var CXCallingConv_X86FastCall: CXCallingConv { get }
// public var CXCallingConv_X86ThisCall: CXCallingConv { get }
// public var CXCallingConv_X86Pascal: CXCallingConv { get }
// public var CXCallingConv_AAPCS: CXCallingConv { get }
// public var CXCallingConv_AAPCS_VFP: CXCallingConv { get }

/* Value 8 was PnaclCall, but it was never used, so it could safely be re-used. */
// public var CXCallingConv_IntelOclBicc: CXCallingConv { get }
// public var CXCallingConv_X86_64Win64: CXCallingConv { get }
// public var CXCallingConv_X86_64SysV: CXCallingConv { get }
// public var CXCallingConv_X86VectorCall: CXCallingConv { get }

// public var CXCallingConv_Invalid: CXCallingConv { get }
// public var CXCallingConv_Unexposed: CXCallingConv { get }

/**
 * \brief The type of an element in the abstract syntax tree.
 *
 */
/*
public struct CXType {
    public var kind: CXTypeKind
    public var data: (UnsafeMutablePointer<Void>, UnsafeMutablePointer<Void>)
    public init()
    public init(kind: CXTypeKind, data: (UnsafeMutablePointer<Void>, UnsafeMutablePointer<Void>))
}
*/

/**
 * \brief Retrieve the type of a CXCursor (if any).
 */
public func clang_getCursorType(C: CXCursor) -> CXType {
    return _clang_getCursorType(C: C)
}
private let _clang_getCursorType: @convention(c) (C: CXCursor) -> CXType = library.loadSymbol("clang_getCursorType")


/**
 * \brief Pretty-print the underlying type using the rules of the
 * language of the translation unit from which it came.
 *
 * If the type is invalid, an empty string is returned.
 */
public func clang_getTypeSpelling(CT: CXType) -> CXString {
    return _clang_getTypeSpelling(CT: CT)
}
private let _clang_getTypeSpelling: @convention(c) (CT: CXType) -> CXString = library.loadSymbol("clang_getTypeSpelling")


/**
 * \brief Retrieve the underlying type of a typedef declaration.
 *
 * If the cursor does not reference a typedef declaration, an invalid type is
 * returned.
 */
public func clang_getTypedefDeclUnderlyingType(C: CXCursor) -> CXType {
    return _clang_getTypedefDeclUnderlyingType(C: C)
}
private let _clang_getTypedefDeclUnderlyingType: @convention(c) (C: CXCursor) -> CXType = library.loadSymbol("clang_getTypedefDeclUnderlyingType")


/**
 * \brief Retrieve the integer type of an enum declaration.
 *
 * If the cursor does not reference an enum declaration, an invalid type is
 * returned.
 */
public func clang_getEnumDeclIntegerType(C: CXCursor) -> CXType {
    return _clang_getEnumDeclIntegerType(C: C)
}
private let _clang_getEnumDeclIntegerType: @convention(c) (C: CXCursor) -> CXType = library.loadSymbol("clang_getEnumDeclIntegerType")


/**
 * \brief Retrieve the integer value of an enum constant declaration as a signed
 *  long long.
 *
 * If the cursor does not reference an enum constant declaration, LLONG_MIN is returned.
 * Since this is also potentially a valid constant value, the kind of the cursor
 * must be verified before calling this function.
 */
public func clang_getEnumConstantDeclValue(C: CXCursor) -> Int64 {
    return _clang_getEnumConstantDeclValue(C: C)
}
private let _clang_getEnumConstantDeclValue: @convention(c) (C: CXCursor) -> Int64 = library.loadSymbol("clang_getEnumConstantDeclValue")


/**
 * \brief Retrieve the integer value of an enum constant declaration as an unsigned
 *  long long.
 *
 * If the cursor does not reference an enum constant declaration, ULLONG_MAX is returned.
 * Since this is also potentially a valid constant value, the kind of the cursor
 * must be verified before calling this function.
 */
public func clang_getEnumConstantDeclUnsignedValue(C: CXCursor) -> UInt64 {
    return _clang_getEnumConstantDeclUnsignedValue(C: C)
}
private let _clang_getEnumConstantDeclUnsignedValue: @convention(c) (C: CXCursor) -> UInt64 = library.loadSymbol("clang_getEnumConstantDeclUnsignedValue")


/**
 * \brief Retrieve the bit width of a bit field declaration as an integer.
 *
 * If a cursor that is not a bit field declaration is passed in, -1 is returned.
 */
public func clang_getFieldDeclBitWidth(C: CXCursor) -> Int32 {
    return _clang_getFieldDeclBitWidth(C: C)
}
private let _clang_getFieldDeclBitWidth: @convention(c) (C: CXCursor) -> Int32 = library.loadSymbol("clang_getFieldDeclBitWidth")


/**
 * \brief Retrieve the number of non-variadic arguments associated with a given
 * cursor.
 *
 * The number of arguments can be determined for calls as well as for
 * declarations of functions or methods. For other cursors -1 is returned.
 */
public func clang_Cursor_getNumArguments(C: CXCursor) -> Int32 {
    return _clang_Cursor_getNumArguments(C: C)
}
private let _clang_Cursor_getNumArguments: @convention(c) (C: CXCursor) -> Int32 = library.loadSymbol("clang_Cursor_getNumArguments")


/**
 * \brief Retrieve the argument cursor of a function or method.
 *
 * The argument cursor can be determined for calls as well as for declarations
 * of functions or methods. For other cursors and for invalid indices, an
 * invalid cursor is returned.
 */
public func clang_Cursor_getArgument(C: CXCursor, _ i: UInt32) -> CXCursor {
    return _clang_Cursor_getArgument(C: C, i: i)
}
private let _clang_Cursor_getArgument: @convention(c) (C: CXCursor, i: UInt32) -> CXCursor = library.loadSymbol("clang_Cursor_getArgument")


/**
 * \brief Describes the kind of a template argument.
 *
 * See the definition of llvm::clang::TemplateArgument::ArgKind for full
 * element descriptions.
 */
/*
public struct CXTemplateArgumentKind : RawRepresentable, Equatable {
    public init(_ rawValue: UInt32)
    public init(rawValue: UInt32)
    public var rawValue: UInt32
}
*/
// public var CXTemplateArgumentKind_Null: CXTemplateArgumentKind { get }
// public var CXTemplateArgumentKind_Type: CXTemplateArgumentKind { get }
// public var CXTemplateArgumentKind_Declaration: CXTemplateArgumentKind { get }
// public var CXTemplateArgumentKind_NullPtr: CXTemplateArgumentKind { get }
// public var CXTemplateArgumentKind_Integral: CXTemplateArgumentKind { get }
// public var CXTemplateArgumentKind_Template: CXTemplateArgumentKind { get }
// public var CXTemplateArgumentKind_TemplateExpansion: CXTemplateArgumentKind { get }
// public var CXTemplateArgumentKind_Expression: CXTemplateArgumentKind { get }
// public var CXTemplateArgumentKind_Pack: CXTemplateArgumentKind { get }

/* Indicates an error case, preventing the kind from being deduced. */
// public var CXTemplateArgumentKind_Invalid: CXTemplateArgumentKind { get }

/**
 *\brief Returns the number of template args of a function decl representing a
 * template specialization.
 *
 * If the argument cursor cannot be converted into a template function
 * declaration, -1 is returned.
 *
 * For example, for the following declaration and specialization:
 *   template <typename T, int kInt, bool kBool>
 *   void foo() { ... }
 *
 *   template <>
 *   void foo<float, -7, true>();
 *
 * The value 3 would be returned from this call.
 */
public func clang_Cursor_getNumTemplateArguments(C: CXCursor) -> Int32 {
    return _clang_Cursor_getNumTemplateArguments(C: C)
}
private let _clang_Cursor_getNumTemplateArguments: @convention(c) (C: CXCursor) -> Int32 = library.loadSymbol("clang_Cursor_getNumTemplateArguments")


/**
 * \brief Retrieve the kind of the I'th template argument of the CXCursor C.
 *
 * If the argument CXCursor does not represent a FunctionDecl, an invalid
 * template argument kind is returned.
 *
 * For example, for the following declaration and specialization:
 *   template <typename T, int kInt, bool kBool>
 *   void foo() { ... }
 *
 *   template <>
 *   void foo<float, -7, true>();
 *
 * For I = 0, 1, and 2, Type, Integral, and Integral will be returned,
 * respectively.
 */
public func clang_Cursor_getTemplateArgumentKind(C: CXCursor, _ I: UInt32) -> CXTemplateArgumentKind {
    return _clang_Cursor_getTemplateArgumentKind(C: C, I: I)
}
private let _clang_Cursor_getTemplateArgumentKind: @convention(c) (C: CXCursor, I: UInt32) -> CXTemplateArgumentKind = library.loadSymbol("clang_Cursor_getTemplateArgumentKind")


/**
 * \brief Retrieve a CXType representing the type of a TemplateArgument of a
 *  function decl representing a template specialization.
 *
 * If the argument CXCursor does not represent a FunctionDecl whose I'th
 * template argument has a kind of CXTemplateArgKind_Integral, an invalid type
 * is returned.
 *
 * For example, for the following declaration and specialization:
 *   template <typename T, int kInt, bool kBool>
 *   void foo() { ... }
 *
 *   template <>
 *   void foo<float, -7, true>();
 *
 * If called with I = 0, "float", will be returned.
 * Invalid types will be returned for I == 1 or 2.
 */
public func clang_Cursor_getTemplateArgumentType(C: CXCursor, _ I: UInt32) -> CXType {
    return _clang_Cursor_getTemplateArgumentType(C: C, I: I)
}
private let _clang_Cursor_getTemplateArgumentType: @convention(c) (C: CXCursor, I: UInt32) -> CXType = library.loadSymbol("clang_Cursor_getTemplateArgumentType")


/**
 * \brief Retrieve the value of an Integral TemplateArgument (of a function
 *  decl representing a template specialization) as a signed long long.
 *
 * It is undefined to call this function on a CXCursor that does not represent a
 * FunctionDecl or whose I'th template argument is not an integral value.
 *
 * For example, for the following declaration and specialization:
 *   template <typename T, int kInt, bool kBool>
 *   void foo() { ... }
 *
 *   template <>
 *   void foo<float, -7, true>();
 *
 * If called with I = 1 or 2, -7 or true will be returned, respectively.
 * For I == 0, this function's behavior is undefined.
 */
public func clang_Cursor_getTemplateArgumentValue(C: CXCursor, _ I: UInt32) -> Int64 {
    return _clang_Cursor_getTemplateArgumentValue(C: C, I: I)
}
private let _clang_Cursor_getTemplateArgumentValue: @convention(c) (C: CXCursor, I: UInt32) -> Int64 = library.loadSymbol("clang_Cursor_getTemplateArgumentValue")


/**
 * \brief Retrieve the value of an Integral TemplateArgument (of a function
 *  decl representing a template specialization) as an unsigned long long.
 *
 * It is undefined to call this function on a CXCursor that does not represent a
 * FunctionDecl or whose I'th template argument is not an integral value.
 *
 * For example, for the following declaration and specialization:
 *   template <typename T, int kInt, bool kBool>
 *   void foo() { ... }
 *
 *   template <>
 *   void foo<float, 2147483649, true>();
 *
 * If called with I = 1 or 2, 2147483649 or true will be returned, respectively.
 * For I == 0, this function's behavior is undefined.
 */
public func clang_Cursor_getTemplateArgumentUnsignedValue(C: CXCursor, _ I: UInt32) -> UInt64 {
    return _clang_Cursor_getTemplateArgumentUnsignedValue(C: C, I: I)
}
private let _clang_Cursor_getTemplateArgumentUnsignedValue: @convention(c) (C: CXCursor, I: UInt32) -> UInt64 = library.loadSymbol("clang_Cursor_getTemplateArgumentUnsignedValue")


/**
 * \brief Determine whether two CXTypes represent the same type.
 *
 * \returns non-zero if the CXTypes represent the same type and
 *          zero otherwise.
 */
public func clang_equalTypes(A: CXType, _ B: CXType) -> UInt32 {
    return _clang_equalTypes(A: A, B: B)
}
private let _clang_equalTypes: @convention(c) (A: CXType, B: CXType) -> UInt32 = library.loadSymbol("clang_equalTypes")


/**
 * \brief Return the canonical type for a CXType.
 *
 * Clang's type system explicitly models typedefs and all the ways
 * a specific type can be represented.  The canonical type is the underlying
 * type with all the "sugar" removed.  For example, if 'T' is a typedef
 * for 'int', the canonical type for 'T' would be 'int'.
 */
public func clang_getCanonicalType(T: CXType) -> CXType {
    return _clang_getCanonicalType(T: T)
}
private let _clang_getCanonicalType: @convention(c) (T: CXType) -> CXType = library.loadSymbol("clang_getCanonicalType")


/**
 * \brief Determine whether a CXType has the "const" qualifier set,
 * without looking through typedefs that may have added "const" at a
 * different level.
 */
public func clang_isConstQualifiedType(T: CXType) -> UInt32 {
    return _clang_isConstQualifiedType(T: T)
}
private let _clang_isConstQualifiedType: @convention(c) (T: CXType) -> UInt32 = library.loadSymbol("clang_isConstQualifiedType")


/**
 * \brief Determine whether a CXType has the "volatile" qualifier set,
 * without looking through typedefs that may have added "volatile" at
 * a different level.
 */
public func clang_isVolatileQualifiedType(T: CXType) -> UInt32 {
    return _clang_isVolatileQualifiedType(T: T)
}
private let _clang_isVolatileQualifiedType: @convention(c) (T: CXType) -> UInt32 = library.loadSymbol("clang_isVolatileQualifiedType")


/**
 * \brief Determine whether a CXType has the "restrict" qualifier set,
 * without looking through typedefs that may have added "restrict" at a
 * different level.
 */
public func clang_isRestrictQualifiedType(T: CXType) -> UInt32 {
    return _clang_isRestrictQualifiedType(T: T)
}
private let _clang_isRestrictQualifiedType: @convention(c) (T: CXType) -> UInt32 = library.loadSymbol("clang_isRestrictQualifiedType")


/**
 * \brief For pointer types, returns the type of the pointee.
 */
public func clang_getPointeeType(T: CXType) -> CXType {
    return _clang_getPointeeType(T: T)
}
private let _clang_getPointeeType: @convention(c) (T: CXType) -> CXType = library.loadSymbol("clang_getPointeeType")


/**
 * \brief Return the cursor for the declaration of the given type.
 */
public func clang_getTypeDeclaration(T: CXType) -> CXCursor {
    return _clang_getTypeDeclaration(T: T)
}
private let _clang_getTypeDeclaration: @convention(c) (T: CXType) -> CXCursor = library.loadSymbol("clang_getTypeDeclaration")


/**
 * Returns the Objective-C type encoding for the specified declaration.
 */
public func clang_getDeclObjCTypeEncoding(C: CXCursor) -> CXString {
    return _clang_getDeclObjCTypeEncoding(C: C)
}
private let _clang_getDeclObjCTypeEncoding: @convention(c) (C: CXCursor) -> CXString = library.loadSymbol("clang_getDeclObjCTypeEncoding")


/**
 * \brief Retrieve the spelling of a given CXTypeKind.
 */
public func clang_getTypeKindSpelling(K: CXTypeKind) -> CXString {
    return _clang_getTypeKindSpelling(K: K)
}
private let _clang_getTypeKindSpelling: @convention(c) (K: CXTypeKind) -> CXString = library.loadSymbol("clang_getTypeKindSpelling")


/**
 * \brief Retrieve the calling convention associated with a function type.
 *
 * If a non-function type is passed in, CXCallingConv_Invalid is returned.
 */
public func clang_getFunctionTypeCallingConv(T: CXType) -> CXCallingConv {
    return _clang_getFunctionTypeCallingConv(T: T)
}
private let _clang_getFunctionTypeCallingConv: @convention(c) (T: CXType) -> CXCallingConv = library.loadSymbol("clang_getFunctionTypeCallingConv")


/**
 * \brief Retrieve the return type associated with a function type.
 *
 * If a non-function type is passed in, an invalid type is returned.
 */
public func clang_getResultType(T: CXType) -> CXType {
    return _clang_getResultType(T: T)
}
private let _clang_getResultType: @convention(c) (T: CXType) -> CXType = library.loadSymbol("clang_getResultType")


/**
 * \brief Retrieve the number of non-variadic parameters associated with a
 * function type.
 *
 * If a non-function type is passed in, -1 is returned.
 */
public func clang_getNumArgTypes(T: CXType) -> Int32 {
    return _clang_getNumArgTypes(T: T)
}
private let _clang_getNumArgTypes: @convention(c) (T: CXType) -> Int32 = library.loadSymbol("clang_getNumArgTypes")


/**
 * \brief Retrieve the type of a parameter of a function type.
 *
 * If a non-function type is passed in or the function does not have enough
 * parameters, an invalid type is returned.
 */
public func clang_getArgType(T: CXType, _ i: UInt32) -> CXType {
    return _clang_getArgType(T: T, i: i)
}
private let _clang_getArgType: @convention(c) (T: CXType, i: UInt32) -> CXType = library.loadSymbol("clang_getArgType")


/**
 * \brief Return 1 if the CXType is a variadic function type, and 0 otherwise.
 */
public func clang_isFunctionTypeVariadic(T: CXType) -> UInt32 {
    return _clang_isFunctionTypeVariadic(T: T)
}
private let _clang_isFunctionTypeVariadic: @convention(c) (T: CXType) -> UInt32 = library.loadSymbol("clang_isFunctionTypeVariadic")


/**
 * \brief Retrieve the return type associated with a given cursor.
 *
 * This only returns a valid type if the cursor refers to a function or method.
 */
public func clang_getCursorResultType(C: CXCursor) -> CXType {
    return _clang_getCursorResultType(C: C)
}
private let _clang_getCursorResultType: @convention(c) (C: CXCursor) -> CXType = library.loadSymbol("clang_getCursorResultType")


/**
 * \brief Return 1 if the CXType is a POD (plain old data) type, and 0
 *  otherwise.
 */
public func clang_isPODType(T: CXType) -> UInt32 {
    return _clang_isPODType(T: T)
}
private let _clang_isPODType: @convention(c) (T: CXType) -> UInt32 = library.loadSymbol("clang_isPODType")


/**
 * \brief Return the element type of an array, complex, or vector type.
 *
 * If a type is passed in that is not an array, complex, or vector type,
 * an invalid type is returned.
 */
public func clang_getElementType(T: CXType) -> CXType {
    return _clang_getElementType(T: T)
}
private let _clang_getElementType: @convention(c) (T: CXType) -> CXType = library.loadSymbol("clang_getElementType")


/**
 * \brief Return the number of elements of an array or vector type.
 *
 * If a type is passed in that is not an array or vector type,
 * -1 is returned.
 */
public func clang_getNumElements(T: CXType) -> Int64 {
    return _clang_getNumElements(T: T)
}
private let _clang_getNumElements: @convention(c) (T: CXType) -> Int64 = library.loadSymbol("clang_getNumElements")


/**
 * \brief Return the element type of an array type.
 *
 * If a non-array type is passed in, an invalid type is returned.
 */
public func clang_getArrayElementType(T: CXType) -> CXType {
    return _clang_getArrayElementType(T: T)
}
private let _clang_getArrayElementType: @convention(c) (T: CXType) -> CXType = library.loadSymbol("clang_getArrayElementType")


/**
 * \brief Return the array size of a constant array.
 *
 * If a non-array type is passed in, -1 is returned.
 */
public func clang_getArraySize(T: CXType) -> Int64 {
    return _clang_getArraySize(T: T)
}
private let _clang_getArraySize: @convention(c) (T: CXType) -> Int64 = library.loadSymbol("clang_getArraySize")


/**
 * \brief List the possible error codes for \c clang_Type_getSizeOf,
 *   \c clang_Type_getAlignOf, \c clang_Type_getOffsetOf and
 *   \c clang_Cursor_getOffsetOf.
 *
 * A value of this enumeration type can be returned if the target type is not
 * a valid argument to sizeof, alignof or offsetof.
 */
/*
public struct CXTypeLayoutError : RawRepresentable, Equatable {
    public init(_ rawValue: Int32)
    public init(rawValue: Int32)
    public var rawValue: Int32
}
*/

/**
 * \brief Type is of kind CXType_Invalid.
 */
// public var CXTypeLayoutError_Invalid: CXTypeLayoutError { get }
/**
 * \brief The type is an incomplete Type.
 */
// public var CXTypeLayoutError_Incomplete: CXTypeLayoutError { get }
/**
 * \brief The type is a dependent Type.
 */
// public var CXTypeLayoutError_Dependent: CXTypeLayoutError { get }
/**
 * \brief The type is not a constant size type.
 */
// public var CXTypeLayoutError_NotConstantSize: CXTypeLayoutError { get }
/**
 * \brief The Field name is not valid for this record.
 */
// public var CXTypeLayoutError_InvalidFieldName: CXTypeLayoutError { get }

/**
 * \brief Return the alignment of a type in bytes as per C++[expr.alignof]
 *   standard.
 *
 * If the type declaration is invalid, CXTypeLayoutError_Invalid is returned.
 * If the type declaration is an incomplete type, CXTypeLayoutError_Incomplete
 *   is returned.
 * If the type declaration is a dependent type, CXTypeLayoutError_Dependent is
 *   returned.
 * If the type declaration is not a constant size type,
 *   CXTypeLayoutError_NotConstantSize is returned.
 */
public func clang_Type_getAlignOf(T: CXType) -> Int64 {
    return _clang_Type_getAlignOf(T: T)
}
private let _clang_Type_getAlignOf: @convention(c) (T: CXType) -> Int64 = library.loadSymbol("clang_Type_getAlignOf")


/**
 * \brief Return the class type of an member pointer type.
 *
 * If a non-member-pointer type is passed in, an invalid type is returned.
 */
public func clang_Type_getClassType(T: CXType) -> CXType {
    return _clang_Type_getClassType(T: T)
}
private let _clang_Type_getClassType: @convention(c) (T: CXType) -> CXType = library.loadSymbol("clang_Type_getClassType")


/**
 * \brief Return the size of a type in bytes as per C++[expr.sizeof] standard.
 *
 * If the type declaration is invalid, CXTypeLayoutError_Invalid is returned.
 * If the type declaration is an incomplete type, CXTypeLayoutError_Incomplete
 *   is returned.
 * If the type declaration is a dependent type, CXTypeLayoutError_Dependent is
 *   returned.
 */
public func clang_Type_getSizeOf(T: CXType) -> Int64 {
    return _clang_Type_getSizeOf(T: T)
}
private let _clang_Type_getSizeOf: @convention(c) (T: CXType) -> Int64 = library.loadSymbol("clang_Type_getSizeOf")


/**
 * \brief Return the offset of a field named S in a record of type T in bits
 *   as it would be returned by __offsetof__ as per C++11[18.2p4]
 *
 * If the cursor is not a record field declaration, CXTypeLayoutError_Invalid
 *   is returned.
 * If the field's type declaration is an incomplete type,
 *   CXTypeLayoutError_Incomplete is returned.
 * If the field's type declaration is a dependent type,
 *   CXTypeLayoutError_Dependent is returned.
 * If the field's name S is not found,
 *   CXTypeLayoutError_InvalidFieldName is returned.
 */
public func clang_Type_getOffsetOf(T: CXType, _ S: UnsafePointer<Int8>) -> Int64 {
    return _clang_Type_getOffsetOf(T: T, S: S)
}
private let _clang_Type_getOffsetOf: @convention(c) (T: CXType, S: UnsafePointer<Int8>) -> Int64 = library.loadSymbol("clang_Type_getOffsetOf")


/**
 * \brief Return the offset of the field represented by the Cursor.
 *
 * If the cursor is not a field declaration, -1 is returned.
 * If the cursor semantic parent is not a record field declaration,
 *   CXTypeLayoutError_Invalid is returned.
 * If the field's type declaration is an incomplete type,
 *   CXTypeLayoutError_Incomplete is returned.
 * If the field's type declaration is a dependent type,
 *   CXTypeLayoutError_Dependent is returned.
 * If the field's name S is not found,
 *   CXTypeLayoutError_InvalidFieldName is returned.
 */
public func clang_Cursor_getOffsetOfField(C: CXCursor) -> Int64 {
    return _clang_Cursor_getOffsetOfField(C: C)
}
private let _clang_Cursor_getOffsetOfField: @convention(c) (C: CXCursor) -> Int64 = library.loadSymbol("clang_Cursor_getOffsetOfField")


/**
 * \brief Determine whether the given cursor represents an anonymous record
 * declaration.
 */
public func clang_Cursor_isAnonymous(C: CXCursor) -> UInt32 {
    return _clang_Cursor_isAnonymous(C: C)
}
private let _clang_Cursor_isAnonymous: @convention(c) (C: CXCursor) -> UInt32 = library.loadSymbol("clang_Cursor_isAnonymous")


/*
public struct CXRefQualifierKind : RawRepresentable, Equatable {
    public init(_ rawValue: UInt32)
    public init(rawValue: UInt32)
    public var rawValue: UInt32
}
*/

/** \brief No ref-qualifier was provided. */
// public var CXRefQualifier_None: CXRefQualifierKind { get }
/** \brief An lvalue ref-qualifier was provided (\c &). */
// public var CXRefQualifier_LValue: CXRefQualifierKind { get }
/** \brief An rvalue ref-qualifier was provided (\c &&). */
// public var CXRefQualifier_RValue: CXRefQualifierKind { get }

/**
 * \brief Returns the number of template arguments for given class template
 * specialization, or -1 if type \c T is not a class template specialization.
 *
 * Variadic argument packs count as only one argument, and can not be inspected
 * further.
 */
public func clang_Type_getNumTemplateArguments(T: CXType) -> Int32 {
    return _clang_Type_getNumTemplateArguments(T: T)
}
private let _clang_Type_getNumTemplateArguments: @convention(c) (T: CXType) -> Int32 = library.loadSymbol("clang_Type_getNumTemplateArguments")


/**
 * \brief Returns the type template argument of a template class specialization
 * at given index.
 *
 * This function only returns template type arguments and does not handle
 * template template arguments or variadic packs.
 */
public func clang_Type_getTemplateArgumentAsType(T: CXType, _ i: UInt32) -> CXType {
    return _clang_Type_getTemplateArgumentAsType(T: T, i: i)
}
private let _clang_Type_getTemplateArgumentAsType: @convention(c) (T: CXType, i: UInt32) -> CXType = library.loadSymbol("clang_Type_getTemplateArgumentAsType")


/**
 * \brief Retrieve the ref-qualifier kind of a function or method.
 *
 * The ref-qualifier is returned for C++ functions or methods. For other types
 * or non-C++ declarations, CXRefQualifier_None is returned.
 */
public func clang_Type_getCXXRefQualifier(T: CXType) -> CXRefQualifierKind {
    return _clang_Type_getCXXRefQualifier(T: T)
}
private let _clang_Type_getCXXRefQualifier: @convention(c) (T: CXType) -> CXRefQualifierKind = library.loadSymbol("clang_Type_getCXXRefQualifier")


/**
 * \brief Returns non-zero if the cursor specifies a Record member that is a
 *   bitfield.
 */
public func clang_Cursor_isBitField(C: CXCursor) -> UInt32 {
    return _clang_Cursor_isBitField(C: C)
}
private let _clang_Cursor_isBitField: @convention(c) (C: CXCursor) -> UInt32 = library.loadSymbol("clang_Cursor_isBitField")


/**
 * \brief Returns 1 if the base class specified by the cursor with kind
 *   CX_CXXBaseSpecifier is virtual.
 */
public func clang_isVirtualBase(unnamed1: CXCursor) -> UInt32 {
    return _clang_isVirtualBase(unnamed1)
}
private let _clang_isVirtualBase: @convention(c) (_: CXCursor) -> UInt32 = library.loadSymbol("clang_isVirtualBase")


/**
 * \brief Represents the C++ access control level to a base class for a
 * cursor with kind CX_CXXBaseSpecifier.
 */
/*
public struct CX_CXXAccessSpecifier : RawRepresentable, Equatable {
    public init(_ rawValue: UInt32)
    public init(rawValue: UInt32)
    public var rawValue: UInt32
}
*/
// public var CX_CXXInvalidAccessSpecifier: CX_CXXAccessSpecifier { get }
// public var CX_CXXPublic: CX_CXXAccessSpecifier { get }
// public var CX_CXXProtected: CX_CXXAccessSpecifier { get }
// public var CX_CXXPrivate: CX_CXXAccessSpecifier { get }

/**
 * \brief Returns the access control level for the referenced object.
 *
 * If the cursor refers to a C++ declaration, its access control level within its
 * parent scope is returned. Otherwise, if the cursor refers to a base specifier or
 * access specifier, the specifier itself is returned.
 */
public func clang_getCXXAccessSpecifier(unnamed1: CXCursor) -> CX_CXXAccessSpecifier {
    return _clang_getCXXAccessSpecifier(unnamed1)
}
private let _clang_getCXXAccessSpecifier: @convention(c) (_: CXCursor) -> CX_CXXAccessSpecifier = library.loadSymbol("clang_getCXXAccessSpecifier")


/**
 * \brief Represents the storage classes as declared in the source. CX_SC_Invalid
 * was added for the case that the passed cursor in not a declaration.
 */
/*
public struct CX_StorageClass : RawRepresentable, Equatable {
    public init(_ rawValue: UInt32)
    public init(rawValue: UInt32)
    public var rawValue: UInt32
}
*/
// public var CX_SC_Invalid: CX_StorageClass { get }
// public var CX_SC_None: CX_StorageClass { get }
// public var CX_SC_Extern: CX_StorageClass { get }
// public var CX_SC_Static: CX_StorageClass { get }
// public var CX_SC_PrivateExtern: CX_StorageClass { get }
// public var CX_SC_OpenCLWorkGroupLocal: CX_StorageClass { get }
// public var CX_SC_Auto: CX_StorageClass { get }
// public var CX_SC_Register: CX_StorageClass { get }

/**
 * \brief Returns the storage class for a function or variable declaration.
 *
 * If the passed in Cursor is not a function or variable declaration,
 * CX_SC_Invalid is returned else the storage class.
 */
public func clang_Cursor_getStorageClass(unnamed1: CXCursor) -> CX_StorageClass {
    return _clang_Cursor_getStorageClass(unnamed1)
}
private let _clang_Cursor_getStorageClass: @convention(c) (_: CXCursor) -> CX_StorageClass = library.loadSymbol("clang_Cursor_getStorageClass")


/**
 * \brief Determine the number of overloaded declarations referenced by a 
 * \c CXCursor_OverloadedDeclRef cursor.
 *
 * \param cursor The cursor whose overloaded declarations are being queried.
 *
 * \returns The number of overloaded declarations referenced by \c cursor. If it
 * is not a \c CXCursor_OverloadedDeclRef cursor, returns 0.
 */
public func clang_getNumOverloadedDecls(cursor: CXCursor) -> UInt32 {
    return _clang_getNumOverloadedDecls(cursor: cursor)
}
private let _clang_getNumOverloadedDecls: @convention(c) (cursor: CXCursor) -> UInt32 = library.loadSymbol("clang_getNumOverloadedDecls")


/**
 * \brief Retrieve a cursor for one of the overloaded declarations referenced
 * by a \c CXCursor_OverloadedDeclRef cursor.
 *
 * \param cursor The cursor whose overloaded declarations are being queried.
 *
 * \param index The zero-based index into the set of overloaded declarations in
 * the cursor.
 *
 * \returns A cursor representing the declaration referenced by the given 
 * \c cursor at the specified \c index. If the cursor does not have an 
 * associated set of overloaded declarations, or if the index is out of bounds,
 * returns \c clang_getNullCursor();
 */
public func clang_getOverloadedDecl(cursor: CXCursor, _ index: UInt32) -> CXCursor {
    return _clang_getOverloadedDecl(cursor: cursor, index: index)
}
private let _clang_getOverloadedDecl: @convention(c) (cursor: CXCursor, index: UInt32) -> CXCursor = library.loadSymbol("clang_getOverloadedDecl")


/**
 * @}
 */

/**
 * \defgroup CINDEX_ATTRIBUTES Information for attributes
 *
 * @{
 */

/**
 * \brief For cursors representing an iboutletcollection attribute,
 *  this function returns the collection element type.
 *
 */
public func clang_getIBOutletCollectionType(unnamed1: CXCursor) -> CXType {
    return _clang_getIBOutletCollectionType(unnamed1)
}
private let _clang_getIBOutletCollectionType: @convention(c) (_: CXCursor) -> CXType = library.loadSymbol("clang_getIBOutletCollectionType")


/**
 * @}
 */

/**
 * \defgroup CINDEX_CURSOR_TRAVERSAL Traversing the AST with cursors
 *
 * These routines provide the ability to traverse the abstract syntax tree
 * using cursors.
 *
 * @{
 */

/**
 * \brief Describes how the traversal of the children of a particular
 * cursor should proceed after visiting a particular child cursor.
 *
 * A value of this enumeration type should be returned by each
 * \c CXCursorVisitor to indicate how clang_visitChildren() proceed.
 */
/*
public struct CXChildVisitResult : RawRepresentable, Equatable {
    public init(_ rawValue: UInt32)
    public init(rawValue: UInt32)
    public var rawValue: UInt32
}
*/

/**
 * \brief Terminates the cursor traversal.
 */
// public var CXChildVisit_Break: CXChildVisitResult { get }
/**
 * \brief Continues the cursor traversal with the next sibling of
 * the cursor just visited, without visiting its children.
 */
// public var CXChildVisit_Continue: CXChildVisitResult { get }
/**
 * \brief Recursively traverse the children of this cursor, using
 * the same visitor and client data.
 */
// public var CXChildVisit_Recurse: CXChildVisitResult { get }

/**
 * \brief Visitor invoked for each cursor found by a traversal.
 *
 * This visitor function will be invoked for each cursor found by
 * clang_visitCursorChildren(). Its first argument is the cursor being
 * visited, its second argument is the parent visitor for that cursor,
 * and its third argument is the client data provided to
 * clang_visitCursorChildren().
 *
 * The visitor should return one of the \c CXChildVisitResult values
 * to direct clang_visitCursorChildren().
 */
// public typealias CXCursorVisitor = @convention(c) (CXCursor, CXCursor, CXClientData) -> CXChildVisitResult

/**
 * \brief Visit the children of a particular cursor.
 *
 * This function visits all the direct children of the given cursor,
 * invoking the given \p visitor function with the cursors of each
 * visited child. The traversal may be recursive, if the visitor returns
 * \c CXChildVisit_Recurse. The traversal may also be ended prematurely, if
 * the visitor returns \c CXChildVisit_Break.
 *
 * \param parent the cursor whose child may be visited. All kinds of
 * cursors can be visited, including invalid cursors (which, by
 * definition, have no children).
 *
 * \param visitor the visitor function that will be invoked for each
 * child of \p parent.
 *
 * \param client_data pointer data supplied by the client, which will
 * be passed to the visitor each time it is invoked.
 *
 * \returns a non-zero value if the traversal was terminated
 * prematurely by the visitor returning \c CXChildVisit_Break.
 */
public func clang_visitChildren(parent: CXCursor, _ visitor: CXCursorVisitor!, _ client_data: CXClientData) -> UInt32 {
    return _clang_visitChildren(parent: parent, visitor: visitor, client_data: client_data)
}
private let _clang_visitChildren: @convention(c) (parent: CXCursor, visitor: CXCursorVisitor!, client_data: CXClientData) -> UInt32 = library.loadSymbol("clang_visitChildren")


/**
 * \brief Visitor invoked for each cursor found by a traversal.
 *
 * This visitor block will be invoked for each cursor found by
 * clang_visitChildrenWithBlock(). Its first argument is the cursor being
 * visited, its second argument is the parent visitor for that cursor.
 *
 * The visitor should return one of the \c CXChildVisitResult values
 * to direct clang_visitChildrenWithBlock().
 */
// public typealias CXCursorVisitorBlock = (CXCursor, CXCursor) -> CXChildVisitResult

/**
 * Visits the children of a cursor using the specified block.  Behaves
 * identically to clang_visitChildren() in all other respects.
 */
public func clang_visitChildrenWithBlock(parent: CXCursor, _ block: CXCursorVisitorBlock!) -> UInt32 {
    return _clang_visitChildrenWithBlock(parent: parent, block: block)
}
private let _clang_visitChildrenWithBlock: @convention(c) (parent: CXCursor, block: CXCursorVisitorBlock!) -> UInt32 = library.loadSymbol("clang_visitChildrenWithBlock")


/**
 * @}
 */

/**
 * \defgroup CINDEX_CURSOR_XREF Cross-referencing in the AST
 *
 * These routines provide the ability to determine references within and
 * across translation units, by providing the names of the entities referenced
 * by cursors, follow reference cursors to the declarations they reference,
 * and associate declarations with their definitions.
 *
 * @{
 */

/**
 * \brief Retrieve a Unified Symbol Resolution (USR) for the entity referenced
 * by the given cursor.
 *
 * A Unified Symbol Resolution (USR) is a string that identifies a particular
 * entity (function, class, variable, etc.) within a program. USRs can be
 * compared across translation units to determine, e.g., when references in
 * one translation refer to an entity defined in another translation unit.
 */
public func clang_getCursorUSR(unnamed1: CXCursor) -> CXString {
    return _clang_getCursorUSR(unnamed1)
}
private let _clang_getCursorUSR: @convention(c) (_: CXCursor) -> CXString = library.loadSymbol("clang_getCursorUSR")


/**
 * \brief Construct a USR for a specified Objective-C class.
 */
public func clang_constructUSR_ObjCClass(class_name: UnsafePointer<Int8>) -> CXString {
    return _clang_constructUSR_ObjCClass(class_name: class_name)
}
private let _clang_constructUSR_ObjCClass: @convention(c) (class_name: UnsafePointer<Int8>) -> CXString = library.loadSymbol("clang_constructUSR_ObjCClass")


/**
 * \brief Construct a USR for a specified Objective-C category.
 */
public func clang_constructUSR_ObjCCategory(class_name: UnsafePointer<Int8>, _ category_name: UnsafePointer<Int8>) -> CXString {
    return _clang_constructUSR_ObjCCategory(class_name: class_name, category_name: category_name)
}
private let _clang_constructUSR_ObjCCategory: @convention(c) (class_name: UnsafePointer<Int8>, category_name: UnsafePointer<Int8>) -> CXString = library.loadSymbol("clang_constructUSR_ObjCCategory")


/**
 * \brief Construct a USR for a specified Objective-C protocol.
 */
public func clang_constructUSR_ObjCProtocol(protocol_name: UnsafePointer<Int8>) -> CXString {
    return _clang_constructUSR_ObjCProtocol(protocol_name: protocol_name)
}
private let _clang_constructUSR_ObjCProtocol: @convention(c) (protocol_name: UnsafePointer<Int8>) -> CXString = library.loadSymbol("clang_constructUSR_ObjCProtocol")


/**
 * \brief Construct a USR for a specified Objective-C instance variable and
 *   the USR for its containing class.
 */
public func clang_constructUSR_ObjCIvar(name: UnsafePointer<Int8>, _ classUSR: CXString) -> CXString {
    return _clang_constructUSR_ObjCIvar(name: name, classUSR: classUSR)
}
private let _clang_constructUSR_ObjCIvar: @convention(c) (name: UnsafePointer<Int8>, classUSR: CXString) -> CXString = library.loadSymbol("clang_constructUSR_ObjCIvar")


/**
 * \brief Construct a USR for a specified Objective-C method and
 *   the USR for its containing class.
 */
public func clang_constructUSR_ObjCMethod(name: UnsafePointer<Int8>, _ isInstanceMethod: UInt32, _ classUSR: CXString) -> CXString {
    return _clang_constructUSR_ObjCMethod(name: name, isInstanceMethod: isInstanceMethod, classUSR: classUSR)
}
private let _clang_constructUSR_ObjCMethod: @convention(c) (name: UnsafePointer<Int8>, isInstanceMethod: UInt32, classUSR: CXString) -> CXString = library.loadSymbol("clang_constructUSR_ObjCMethod")


/**
 * \brief Construct a USR for a specified Objective-C property and the USR
 *  for its containing class.
 */
public func clang_constructUSR_ObjCProperty(property: UnsafePointer<Int8>, _ classUSR: CXString) -> CXString {
    return _clang_constructUSR_ObjCProperty(property: property, classUSR: classUSR)
}
private let _clang_constructUSR_ObjCProperty: @convention(c) (property: UnsafePointer<Int8>, classUSR: CXString) -> CXString = library.loadSymbol("clang_constructUSR_ObjCProperty")


/**
 * \brief Retrieve a name for the entity referenced by this cursor.
 */
public func clang_getCursorSpelling(unnamed1: CXCursor) -> CXString {
    return _clang_getCursorSpelling(unnamed1)
}
private let _clang_getCursorSpelling: @convention(c) (_: CXCursor) -> CXString = library.loadSymbol("clang_getCursorSpelling")


/**
 * \brief Retrieve a range for a piece that forms the cursors spelling name.
 * Most of the times there is only one range for the complete spelling but for
 * Objective-C methods and Objective-C message expressions, there are multiple
 * pieces for each selector identifier.
 * 
 * \param pieceIndex the index of the spelling name piece. If this is greater
 * than the actual number of pieces, it will return a NULL (invalid) range.
 *  
 * \param options Reserved.
 */
public func clang_Cursor_getSpellingNameRange(unnamed1: CXCursor, _ pieceIndex: UInt32, _ options: UInt32) -> CXSourceRange {
    return _clang_Cursor_getSpellingNameRange(unnamed1, pieceIndex: pieceIndex, options: options)
}
private let _clang_Cursor_getSpellingNameRange: @convention(c) (_: CXCursor, pieceIndex: UInt32, options: UInt32) -> CXSourceRange = library.loadSymbol("clang_Cursor_getSpellingNameRange")


/**
 * \brief Retrieve the display name for the entity referenced by this cursor.
 *
 * The display name contains extra information that helps identify the cursor,
 * such as the parameters of a function or template or the arguments of a 
 * class template specialization.
 */
public func clang_getCursorDisplayName(unnamed1: CXCursor) -> CXString {
    return _clang_getCursorDisplayName(unnamed1)
}
private let _clang_getCursorDisplayName: @convention(c) (_: CXCursor) -> CXString = library.loadSymbol("clang_getCursorDisplayName")


/** \brief For a cursor that is a reference, retrieve a cursor representing the
 * entity that it references.
 *
 * Reference cursors refer to other entities in the AST. For example, an
 * Objective-C superclass reference cursor refers to an Objective-C class.
 * This function produces the cursor for the Objective-C class from the
 * cursor for the superclass reference. If the input cursor is a declaration or
 * definition, it returns that declaration or definition unchanged.
 * Otherwise, returns the NULL cursor.
 */
public func clang_getCursorReferenced(unnamed1: CXCursor) -> CXCursor {
    return _clang_getCursorReferenced(unnamed1)
}
private let _clang_getCursorReferenced: @convention(c) (_: CXCursor) -> CXCursor = library.loadSymbol("clang_getCursorReferenced")


/**
 *  \brief For a cursor that is either a reference to or a declaration
 *  of some entity, retrieve a cursor that describes the definition of
 *  that entity.
 *
 *  Some entities can be declared multiple times within a translation
 *  unit, but only one of those declarations can also be a
 *  definition. For example, given:
 *
 *  \code
 *  int f(int, int);
 *  int g(int x, int y) { return f(x, y); }
 *  int f(int a, int b) { return a + b; }
 *  int f(int, int);
 *  \endcode
 *
 *  there are three declarations of the function "f", but only the
 *  second one is a definition. The clang_getCursorDefinition()
 *  function will take any cursor pointing to a declaration of "f"
 *  (the first or fourth lines of the example) or a cursor referenced
 *  that uses "f" (the call to "f' inside "g") and will return a
 *  declaration cursor pointing to the definition (the second "f"
 *  declaration).
 *
 *  If given a cursor for which there is no corresponding definition,
 *  e.g., because there is no definition of that entity within this
 *  translation unit, returns a NULL cursor.
 */
public func clang_getCursorDefinition(unnamed1: CXCursor) -> CXCursor {
    return _clang_getCursorDefinition(unnamed1)
}
private let _clang_getCursorDefinition: @convention(c) (_: CXCursor) -> CXCursor = library.loadSymbol("clang_getCursorDefinition")


/**
 * \brief Determine whether the declaration pointed to by this cursor
 * is also a definition of that entity.
 */
public func clang_isCursorDefinition(unnamed1: CXCursor) -> UInt32 {
    return _clang_isCursorDefinition(unnamed1)
}
private let _clang_isCursorDefinition: @convention(c) (_: CXCursor) -> UInt32 = library.loadSymbol("clang_isCursorDefinition")


/**
 * \brief Retrieve the canonical cursor corresponding to the given cursor.
 *
 * In the C family of languages, many kinds of entities can be declared several
 * times within a single translation unit. For example, a structure type can
 * be forward-declared (possibly multiple times) and later defined:
 *
 * \code
 * struct X;
 * struct X;
 * struct X {
 *   int member;
 * };
 * \endcode
 *
 * The declarations and the definition of \c X are represented by three 
 * different cursors, all of which are declarations of the same underlying 
 * entity. One of these cursor is considered the "canonical" cursor, which
 * is effectively the representative for the underlying entity. One can 
 * determine if two cursors are declarations of the same underlying entity by
 * comparing their canonical cursors.
 *
 * \returns The canonical cursor for the entity referred to by the given cursor.
 */
public func clang_getCanonicalCursor(unnamed1: CXCursor) -> CXCursor {
    return _clang_getCanonicalCursor(unnamed1)
}
private let _clang_getCanonicalCursor: @convention(c) (_: CXCursor) -> CXCursor = library.loadSymbol("clang_getCanonicalCursor")


/**
 * \brief If the cursor points to a selector identifier in an Objective-C
 * method or message expression, this returns the selector index.
 *
 * After getting a cursor with #clang_getCursor, this can be called to
 * determine if the location points to a selector identifier.
 *
 * \returns The selector index if the cursor is an Objective-C method or message
 * expression and the cursor is pointing to a selector identifier, or -1
 * otherwise.
 */
public func clang_Cursor_getObjCSelectorIndex(unnamed1: CXCursor) -> Int32 {
    return _clang_Cursor_getObjCSelectorIndex(unnamed1)
}
private let _clang_Cursor_getObjCSelectorIndex: @convention(c) (_: CXCursor) -> Int32 = library.loadSymbol("clang_Cursor_getObjCSelectorIndex")


/**
 * \brief Given a cursor pointing to a C++ method call or an Objective-C
 * message, returns non-zero if the method/message is "dynamic", meaning:
 * 
 * For a C++ method: the call is virtual.
 * For an Objective-C message: the receiver is an object instance, not 'super'
 * or a specific class.
 * 
 * If the method/message is "static" or the cursor does not point to a
 * method/message, it will return zero.
 */
public func clang_Cursor_isDynamicCall(C: CXCursor) -> Int32 {
    return _clang_Cursor_isDynamicCall(C: C)
}
private let _clang_Cursor_isDynamicCall: @convention(c) (C: CXCursor) -> Int32 = library.loadSymbol("clang_Cursor_isDynamicCall")


/**
 * \brief Given a cursor pointing to an Objective-C message, returns the CXType
 * of the receiver.
 */
public func clang_Cursor_getReceiverType(C: CXCursor) -> CXType {
    return _clang_Cursor_getReceiverType(C: C)
}
private let _clang_Cursor_getReceiverType: @convention(c) (C: CXCursor) -> CXType = library.loadSymbol("clang_Cursor_getReceiverType")


/**
 * \brief Property attributes for a \c CXCursor_ObjCPropertyDecl.
 */
/*
public struct CXObjCPropertyAttrKind : RawRepresentable, Equatable {
    public init(_ rawValue: UInt32)
    public init(rawValue: UInt32)
    public var rawValue: UInt32
}
*/
// public var CXObjCPropertyAttr_noattr: CXObjCPropertyAttrKind { get }
// public var CXObjCPropertyAttr_readonly: CXObjCPropertyAttrKind { get }
// public var CXObjCPropertyAttr_getter: CXObjCPropertyAttrKind { get }
// public var CXObjCPropertyAttr_assign: CXObjCPropertyAttrKind { get }
// public var CXObjCPropertyAttr_readwrite: CXObjCPropertyAttrKind { get }
// public var CXObjCPropertyAttr_retain: CXObjCPropertyAttrKind { get }
// public var CXObjCPropertyAttr_copy: CXObjCPropertyAttrKind { get }
// public var CXObjCPropertyAttr_nonatomic: CXObjCPropertyAttrKind { get }
// public var CXObjCPropertyAttr_setter: CXObjCPropertyAttrKind { get }
// public var CXObjCPropertyAttr_atomic: CXObjCPropertyAttrKind { get }
// public var CXObjCPropertyAttr_weak: CXObjCPropertyAttrKind { get }
// public var CXObjCPropertyAttr_strong: CXObjCPropertyAttrKind { get }
// public var CXObjCPropertyAttr_unsafe_unretained: CXObjCPropertyAttrKind { get }

/**
 * \brief Given a cursor that represents a property declaration, return the
 * associated property attributes. The bits are formed from
 * \c CXObjCPropertyAttrKind.
 *
 * \param reserved Reserved for future use, pass 0.
 */
public func clang_Cursor_getObjCPropertyAttributes(C: CXCursor, _ reserved: UInt32) -> UInt32 {
    return _clang_Cursor_getObjCPropertyAttributes(C: C, reserved: reserved)
}
private let _clang_Cursor_getObjCPropertyAttributes: @convention(c) (C: CXCursor, reserved: UInt32) -> UInt32 = library.loadSymbol("clang_Cursor_getObjCPropertyAttributes")


/**
 * \brief 'Qualifiers' written next to the return and parameter types in
 * Objective-C method declarations.
 */
/*
public struct CXObjCDeclQualifierKind : RawRepresentable, Equatable {
    public init(_ rawValue: UInt32)
    public init(rawValue: UInt32)
    public var rawValue: UInt32
}
*/
// public var CXObjCDeclQualifier_None: CXObjCDeclQualifierKind { get }
// public var CXObjCDeclQualifier_In: CXObjCDeclQualifierKind { get }
// public var CXObjCDeclQualifier_Inout: CXObjCDeclQualifierKind { get }
// public var CXObjCDeclQualifier_Out: CXObjCDeclQualifierKind { get }
// public var CXObjCDeclQualifier_Bycopy: CXObjCDeclQualifierKind { get }
// public var CXObjCDeclQualifier_Byref: CXObjCDeclQualifierKind { get }
// public var CXObjCDeclQualifier_Oneway: CXObjCDeclQualifierKind { get }

/**
 * \brief Given a cursor that represents an Objective-C method or parameter
 * declaration, return the associated Objective-C qualifiers for the return
 * type or the parameter respectively. The bits are formed from
 * CXObjCDeclQualifierKind.
 */
public func clang_Cursor_getObjCDeclQualifiers(C: CXCursor) -> UInt32 {
    return _clang_Cursor_getObjCDeclQualifiers(C: C)
}
private let _clang_Cursor_getObjCDeclQualifiers: @convention(c) (C: CXCursor) -> UInt32 = library.loadSymbol("clang_Cursor_getObjCDeclQualifiers")


/**
 * \brief Given a cursor that represents an Objective-C method or property
 * declaration, return non-zero if the declaration was affected by "@optional".
 * Returns zero if the cursor is not such a declaration or it is "@required".
 */
public func clang_Cursor_isObjCOptional(C: CXCursor) -> UInt32 {
    return _clang_Cursor_isObjCOptional(C: C)
}
private let _clang_Cursor_isObjCOptional: @convention(c) (C: CXCursor) -> UInt32 = library.loadSymbol("clang_Cursor_isObjCOptional")


/**
 * \brief Returns non-zero if the given cursor is a variadic function or method.
 */
public func clang_Cursor_isVariadic(C: CXCursor) -> UInt32 {
    return _clang_Cursor_isVariadic(C: C)
}
private let _clang_Cursor_isVariadic: @convention(c) (C: CXCursor) -> UInt32 = library.loadSymbol("clang_Cursor_isVariadic")


/**
 * \brief Given a cursor that represents a declaration, return the associated
 * comment's source range.  The range may include multiple consecutive comments
 * with whitespace in between.
 */
public func clang_Cursor_getCommentRange(C: CXCursor) -> CXSourceRange {
    return _clang_Cursor_getCommentRange(C: C)
}
private let _clang_Cursor_getCommentRange: @convention(c) (C: CXCursor) -> CXSourceRange = library.loadSymbol("clang_Cursor_getCommentRange")


/**
 * \brief Given a cursor that represents a declaration, return the associated
 * comment text, including comment markers.
 */
public func clang_Cursor_getRawCommentText(C: CXCursor) -> CXString {
    return _clang_Cursor_getRawCommentText(C: C)
}
private let _clang_Cursor_getRawCommentText: @convention(c) (C: CXCursor) -> CXString = library.loadSymbol("clang_Cursor_getRawCommentText")


/**
 * \brief Given a cursor that represents a documentable entity (e.g.,
 * declaration), return the associated \\brief paragraph; otherwise return the
 * first paragraph.
 */
public func clang_Cursor_getBriefCommentText(C: CXCursor) -> CXString {
    return _clang_Cursor_getBriefCommentText(C: C)
}
private let _clang_Cursor_getBriefCommentText: @convention(c) (C: CXCursor) -> CXString = library.loadSymbol("clang_Cursor_getBriefCommentText")


/**
 * @}
 */

/** \defgroup CINDEX_MANGLE Name Mangling API Functions
 *
 * @{
 */

/**
 * \brief Retrieve the CXString representing the mangled name of the cursor.
 */
public func clang_Cursor_getMangling(unnamed1: CXCursor) -> CXString {
    return _clang_Cursor_getMangling(unnamed1)
}
private let _clang_Cursor_getMangling: @convention(c) (_: CXCursor) -> CXString = library.loadSymbol("clang_Cursor_getMangling")


/**
 * @}
 */


/**
 * \defgroup CINDEX_MODULE Module introspection
 *
 * The functions in this group provide access to information about modules.
 *
 * @{
 */
// public typealias CXModule = UnsafeMutablePointer<Void>

/**
 * \brief Given a CXCursor_ModuleImportDecl cursor, return the associated module.
 */
public func clang_Cursor_getModule(C: CXCursor) -> CXModule {
    return _clang_Cursor_getModule(C: C)
}
private let _clang_Cursor_getModule: @convention(c) (C: CXCursor) -> CXModule = library.loadSymbol("clang_Cursor_getModule")


/**
 * \brief Given a CXFile header file, return the module that contains it, if one
 * exists.
 */
public func clang_getModuleForFile(unnamed1: CXTranslationUnit, _ unnamed2: CXFile) -> CXModule {
    return _clang_getModuleForFile(unnamed1, unnamed2)
}
private let _clang_getModuleForFile: @convention(c) (_: CXTranslationUnit, _: CXFile) -> CXModule = library.loadSymbol("clang_getModuleForFile")


/**
 * \param Module a module object.
 *
 * \returns the module file where the provided module object came from.
 */
public func clang_Module_getASTFile(Module: CXModule) -> CXFile {
    return _clang_Module_getASTFile(Module: Module)
}
private let _clang_Module_getASTFile: @convention(c) (Module: CXModule) -> CXFile = library.loadSymbol("clang_Module_getASTFile")


/**
 * \param Module a module object.
 *
 * \returns the parent of a sub-module or NULL if the given module is top-level,
 * e.g. for 'std.vector' it will return the 'std' module.
 */
public func clang_Module_getParent(Module: CXModule) -> CXModule {
    return _clang_Module_getParent(Module: Module)
}
private let _clang_Module_getParent: @convention(c) (Module: CXModule) -> CXModule = library.loadSymbol("clang_Module_getParent")


/**
 * \param Module a module object.
 *
 * \returns the name of the module, e.g. for the 'std.vector' sub-module it
 * will return "vector".
 */
public func clang_Module_getName(Module: CXModule) -> CXString {
    return _clang_Module_getName(Module: Module)
}
private let _clang_Module_getName: @convention(c) (Module: CXModule) -> CXString = library.loadSymbol("clang_Module_getName")


/**
 * \param Module a module object.
 *
 * \returns the full name of the module, e.g. "std.vector".
 */
public func clang_Module_getFullName(Module: CXModule) -> CXString {
    return _clang_Module_getFullName(Module: Module)
}
private let _clang_Module_getFullName: @convention(c) (Module: CXModule) -> CXString = library.loadSymbol("clang_Module_getFullName")


/**
 * \param Module a module object.
 *
 * \returns non-zero if the module is a system one.
 */
public func clang_Module_isSystem(Module: CXModule) -> Int32 {
    return _clang_Module_isSystem(Module: Module)
}
private let _clang_Module_isSystem: @convention(c) (Module: CXModule) -> Int32 = library.loadSymbol("clang_Module_isSystem")


/**
 * \param Module a module object.
 *
 * \returns the number of top level headers associated with this module.
 */
public func clang_Module_getNumTopLevelHeaders(unnamed1: CXTranslationUnit, _ Module: CXModule) -> UInt32 {
    return _clang_Module_getNumTopLevelHeaders(unnamed1, Module: Module)
}
private let _clang_Module_getNumTopLevelHeaders: @convention(c) (_: CXTranslationUnit, Module: CXModule) -> UInt32 = library.loadSymbol("clang_Module_getNumTopLevelHeaders")



/**
 * \param Module a module object.
 *
 * \param Index top level header index (zero-based).
 *
 * \returns the specified top level header associated with the module.
 */
public func clang_Module_getTopLevelHeader(unnamed1: CXTranslationUnit, _ Module: CXModule, _ Index: UInt32) -> CXFile {
    return _clang_Module_getTopLevelHeader(unnamed1, Module: Module, Index: Index)
}
private let _clang_Module_getTopLevelHeader: @convention(c) (_: CXTranslationUnit, Module: CXModule, Index: UInt32) -> CXFile = library.loadSymbol("clang_Module_getTopLevelHeader")


/**
 * @}
 */

/**
 * \defgroup CINDEX_CPP C++ AST introspection
 *
 * The routines in this group provide access information in the ASTs specific
 * to C++ language features.
 *
 * @{
 */

/**
 * \brief Determine if a C++ field is declared 'mutable'.
 */
public func clang_CXXField_isMutable(C: CXCursor) -> UInt32 {
    return _clang_CXXField_isMutable(C: C)
}
private let _clang_CXXField_isMutable: @convention(c) (C: CXCursor) -> UInt32 = library.loadSymbol("clang_CXXField_isMutable")


/**
 * \brief Determine if a C++ member function or member function template is
 * pure virtual.
 */
public func clang_CXXMethod_isPureVirtual(C: CXCursor) -> UInt32 {
    return _clang_CXXMethod_isPureVirtual(C: C)
}
private let _clang_CXXMethod_isPureVirtual: @convention(c) (C: CXCursor) -> UInt32 = library.loadSymbol("clang_CXXMethod_isPureVirtual")


/**
 * \brief Determine if a C++ member function or member function template is 
 * declared 'static'.
 */
public func clang_CXXMethod_isStatic(C: CXCursor) -> UInt32 {
    return _clang_CXXMethod_isStatic(C: C)
}
private let _clang_CXXMethod_isStatic: @convention(c) (C: CXCursor) -> UInt32 = library.loadSymbol("clang_CXXMethod_isStatic")


/**
 * \brief Determine if a C++ member function or member function template is
 * explicitly declared 'virtual' or if it overrides a virtual method from
 * one of the base classes.
 */
public func clang_CXXMethod_isVirtual(C: CXCursor) -> UInt32 {
    return _clang_CXXMethod_isVirtual(C: C)
}
private let _clang_CXXMethod_isVirtual: @convention(c) (C: CXCursor) -> UInt32 = library.loadSymbol("clang_CXXMethod_isVirtual")


/**
 * \brief Determine if a C++ member function or member function template is
 * declared 'const'.
 */
public func clang_CXXMethod_isConst(C: CXCursor) -> UInt32 {
    return _clang_CXXMethod_isConst(C: C)
}
private let _clang_CXXMethod_isConst: @convention(c) (C: CXCursor) -> UInt32 = library.loadSymbol("clang_CXXMethod_isConst")


/**
 * \brief Given a cursor that represents a template, determine
 * the cursor kind of the specializations would be generated by instantiating
 * the template.
 *
 * This routine can be used to determine what flavor of function template,
 * class template, or class template partial specialization is stored in the
 * cursor. For example, it can describe whether a class template cursor is
 * declared with "struct", "class" or "union".
 *
 * \param C The cursor to query. This cursor should represent a template
 * declaration.
 *
 * \returns The cursor kind of the specializations that would be generated
 * by instantiating the template \p C. If \p C is not a template, returns
 * \c CXCursor_NoDeclFound.
 */
public func clang_getTemplateCursorKind(C: CXCursor) -> CXCursorKind {
    return _clang_getTemplateCursorKind(C: C)
}
private let _clang_getTemplateCursorKind: @convention(c) (C: CXCursor) -> CXCursorKind = library.loadSymbol("clang_getTemplateCursorKind")


/**
 * \brief Given a cursor that may represent a specialization or instantiation
 * of a template, retrieve the cursor that represents the template that it
 * specializes or from which it was instantiated.
 *
 * This routine determines the template involved both for explicit 
 * specializations of templates and for implicit instantiations of the template,
 * both of which are referred to as "specializations". For a class template
 * specialization (e.g., \c std::vector<bool>), this routine will return 
 * either the primary template (\c std::vector) or, if the specialization was
 * instantiated from a class template partial specialization, the class template
 * partial specialization. For a class template partial specialization and a
 * function template specialization (including instantiations), this
 * this routine will return the specialized template.
 *
 * For members of a class template (e.g., member functions, member classes, or
 * static data members), returns the specialized or instantiated member. 
 * Although not strictly "templates" in the C++ language, members of class
 * templates have the same notions of specializations and instantiations that
 * templates do, so this routine treats them similarly.
 *
 * \param C A cursor that may be a specialization of a template or a member
 * of a template.
 *
 * \returns If the given cursor is a specialization or instantiation of a 
 * template or a member thereof, the template or member that it specializes or
 * from which it was instantiated. Otherwise, returns a NULL cursor.
 */
public func clang_getSpecializedCursorTemplate(C: CXCursor) -> CXCursor {
    return _clang_getSpecializedCursorTemplate(C: C)
}
private let _clang_getSpecializedCursorTemplate: @convention(c) (C: CXCursor) -> CXCursor = library.loadSymbol("clang_getSpecializedCursorTemplate")


/**
 * \brief Given a cursor that references something else, return the source range
 * covering that reference.
 *
 * \param C A cursor pointing to a member reference, a declaration reference, or
 * an operator call.
 * \param NameFlags A bitset with three independent flags: 
 * CXNameRange_WantQualifier, CXNameRange_WantTemplateArgs, and
 * CXNameRange_WantSinglePiece.
 * \param PieceIndex For contiguous names or when passing the flag 
 * CXNameRange_WantSinglePiece, only one piece with index 0 is 
 * available. When the CXNameRange_WantSinglePiece flag is not passed for a
 * non-contiguous names, this index can be used to retrieve the individual
 * pieces of the name. See also CXNameRange_WantSinglePiece.
 *
 * \returns The piece of the name pointed to by the given cursor. If there is no
 * name, or if the PieceIndex is out-of-range, a null-cursor will be returned.
 */
public func clang_getCursorReferenceNameRange(C: CXCursor, _ NameFlags: UInt32, _ PieceIndex: UInt32) -> CXSourceRange {
    return _clang_getCursorReferenceNameRange(C: C, NameFlags: NameFlags, PieceIndex: PieceIndex)
}
private let _clang_getCursorReferenceNameRange: @convention(c) (C: CXCursor, NameFlags: UInt32, PieceIndex: UInt32) -> CXSourceRange = library.loadSymbol("clang_getCursorReferenceNameRange")


/*
public struct CXNameRefFlags : RawRepresentable, Equatable {
    public init(_ rawValue: UInt32)
    public init(rawValue: UInt32)
    public var rawValue: UInt32
}
*/

/**
 * \brief Include the nested-name-specifier, e.g. Foo:: in x.Foo::y, in the
 * range.
 */
// public var CXNameRange_WantQualifier: CXNameRefFlags { get }

/**
 * \brief Include the explicit template arguments, e.g. \<int> in x.f<int>,
 * in the range.
 */
// public var CXNameRange_WantTemplateArgs: CXNameRefFlags { get }

/**
 * \brief If the name is non-contiguous, return the full spanning range.
 *
 * Non-contiguous names occur in Objective-C when a selector with two or more
 * parameters is used, or in C++ when using an operator:
 * \code
 * [object doSomething:here withValue:there]; // Objective-C
 * return some_vector[1]; // C++
 * \endcode
 */
// public var CXNameRange_WantSinglePiece: CXNameRefFlags { get }

/**
 * @}
 */

/**
 * \defgroup CINDEX_LEX Token extraction and manipulation
 *
 * The routines in this group provide access to the tokens within a
 * translation unit, along with a semantic mapping of those tokens to
 * their corresponding cursors.
 *
 * @{
 */

/**
 * \brief Describes a kind of token.
 */
/*
public struct CXTokenKind : RawRepresentable, Equatable {
    public init(_ rawValue: UInt32)
    public init(rawValue: UInt32)
    public var rawValue: UInt32
}
*/

/**
 * \brief A token that contains some kind of punctuation.
 */
// public var CXToken_Punctuation: CXTokenKind { get }

/**
 * \brief A language keyword.
 */
// public var CXToken_Keyword: CXTokenKind { get }

/**
 * \brief An identifier (that is not a keyword).
 */
// public var CXToken_Identifier: CXTokenKind { get }

/**
 * \brief A numeric, string, or character literal.
 */
// public var CXToken_Literal: CXTokenKind { get }

/**
 * \brief A comment.
 */
// public var CXToken_Comment: CXTokenKind { get }

/**
 * \brief Describes a single preprocessing token.
 */
/*
public struct CXToken {
    public var int_data: (UInt32, UInt32, UInt32, UInt32)
    public var ptr_data: UnsafeMutablePointer<Void>
    public init()
    public init(int_data: (UInt32, UInt32, UInt32, UInt32), ptr_data: UnsafeMutablePointer<Void>)
}
*/

/**
 * \brief Determine the kind of the given token.
 */
public func clang_getTokenKind(unnamed1: CXToken) -> CXTokenKind {
    return _clang_getTokenKind(unnamed1)
}
private let _clang_getTokenKind: @convention(c) (_: CXToken) -> CXTokenKind = library.loadSymbol("clang_getTokenKind")


/**
 * \brief Determine the spelling of the given token.
 *
 * The spelling of a token is the textual representation of that token, e.g.,
 * the text of an identifier or keyword.
 */
public func clang_getTokenSpelling(unnamed1: CXTranslationUnit, _ unnamed2: CXToken) -> CXString {
    return _clang_getTokenSpelling(unnamed1, unnamed2)
}
private let _clang_getTokenSpelling: @convention(c) (_: CXTranslationUnit, _: CXToken) -> CXString = library.loadSymbol("clang_getTokenSpelling")


/**
 * \brief Retrieve the source location of the given token.
 */
public func clang_getTokenLocation(unnamed1: CXTranslationUnit, _ unnamed2: CXToken) -> CXSourceLocation {
    return _clang_getTokenLocation(unnamed1, unnamed2)
}
private let _clang_getTokenLocation: @convention(c) (_: CXTranslationUnit, _: CXToken) -> CXSourceLocation = library.loadSymbol("clang_getTokenLocation")


/**
 * \brief Retrieve a source range that covers the given token.
 */
public func clang_getTokenExtent(unnamed1: CXTranslationUnit, _ unnamed2: CXToken) -> CXSourceRange {
    return _clang_getTokenExtent(unnamed1, unnamed2)
}
private let _clang_getTokenExtent: @convention(c) (_: CXTranslationUnit, _: CXToken) -> CXSourceRange = library.loadSymbol("clang_getTokenExtent")


/**
 * \brief Tokenize the source code described by the given range into raw
 * lexical tokens.
 *
 * \param TU the translation unit whose text is being tokenized.
 *
 * \param Range the source range in which text should be tokenized. All of the
 * tokens produced by tokenization will fall within this source range,
 *
 * \param Tokens this pointer will be set to point to the array of tokens
 * that occur within the given source range. The returned pointer must be
 * freed with clang_disposeTokens() before the translation unit is destroyed.
 *
 * \param NumTokens will be set to the number of tokens in the \c *Tokens
 * array.
 *
 */
public func clang_tokenize(TU: CXTranslationUnit, _ Range: CXSourceRange, _ Tokens: UnsafeMutablePointer<UnsafeMutablePointer<CXToken>>, _ NumTokens: UnsafeMutablePointer<UInt32>) {
    return _clang_tokenize(TU: TU, Range: Range, Tokens: Tokens, NumTokens: NumTokens)
}
private let _clang_tokenize: @convention(c) (TU: CXTranslationUnit, Range: CXSourceRange, Tokens: UnsafeMutablePointer<UnsafeMutablePointer<CXToken>>, NumTokens: UnsafeMutablePointer<UInt32>) -> () = library.loadSymbol("clang_tokenize")


/**
 * \brief Annotate the given set of tokens by providing cursors for each token
 * that can be mapped to a specific entity within the abstract syntax tree.
 *
 * This token-annotation routine is equivalent to invoking
 * clang_getCursor() for the source locations of each of the
 * tokens. The cursors provided are filtered, so that only those
 * cursors that have a direct correspondence to the token are
 * accepted. For example, given a function call \c f(x),
 * clang_getCursor() would provide the following cursors:
 *
 *   * when the cursor is over the 'f', a DeclRefExpr cursor referring to 'f'.
 *   * when the cursor is over the '(' or the ')', a CallExpr referring to 'f'.
 *   * when the cursor is over the 'x', a DeclRefExpr cursor referring to 'x'.
 *
 * Only the first and last of these cursors will occur within the
 * annotate, since the tokens "f" and "x' directly refer to a function
 * and a variable, respectively, but the parentheses are just a small
 * part of the full syntax of the function call expression, which is
 * not provided as an annotation.
 *
 * \param TU the translation unit that owns the given tokens.
 *
 * \param Tokens the set of tokens to annotate.
 *
 * \param NumTokens the number of tokens in \p Tokens.
 *
 * \param Cursors an array of \p NumTokens cursors, whose contents will be
 * replaced with the cursors corresponding to each token.
 */
public func clang_annotateTokens(TU: CXTranslationUnit, _ Tokens: UnsafeMutablePointer<CXToken>, _ NumTokens: UInt32, _ Cursors: UnsafeMutablePointer<CXCursor>) {
    return _clang_annotateTokens(TU: TU, Tokens: Tokens, NumTokens: NumTokens, Cursors: Cursors)
}
private let _clang_annotateTokens: @convention(c) (TU: CXTranslationUnit, Tokens: UnsafeMutablePointer<CXToken>, NumTokens: UInt32, Cursors: UnsafeMutablePointer<CXCursor>) -> () = library.loadSymbol("clang_annotateTokens")


/**
 * \brief Free the given set of tokens.
 */
public func clang_disposeTokens(TU: CXTranslationUnit, _ Tokens: UnsafeMutablePointer<CXToken>, _ NumTokens: UInt32) {
    return _clang_disposeTokens(TU: TU, Tokens: Tokens, NumTokens: NumTokens)
}
private let _clang_disposeTokens: @convention(c) (TU: CXTranslationUnit, Tokens: UnsafeMutablePointer<CXToken>, NumTokens: UInt32) -> () = library.loadSymbol("clang_disposeTokens")


/**
 * @}
 */


/* for debug/testing */
/**
 * \defgroup CINDEX_DEBUG Debugging facilities
 *
 * These routines are used for testing and debugging, only, and should not
 * be relied upon.
 *
 * @{
 */
public func clang_getCursorKindSpelling(Kind: CXCursorKind) -> CXString {
    return _clang_getCursorKindSpelling(Kind: Kind)
}
private let _clang_getCursorKindSpelling: @convention(c) (Kind: CXCursorKind) -> CXString = library.loadSymbol("clang_getCursorKindSpelling")

public func clang_getDefinitionSpellingAndExtent(unnamed1: CXCursor, _ startBuf: UnsafeMutablePointer<UnsafePointer<Int8>>, _ endBuf: UnsafeMutablePointer<UnsafePointer<Int8>>, _ startLine: UnsafeMutablePointer<UInt32>, _ startColumn: UnsafeMutablePointer<UInt32>, _ endLine: UnsafeMutablePointer<UInt32>, _ endColumn: UnsafeMutablePointer<UInt32>) {
    return _clang_getDefinitionSpellingAndExtent(unnamed1, startBuf: startBuf, endBuf: endBuf, startLine: startLine, startColumn: startColumn, endLine: endLine, endColumn: endColumn)
}
private let _clang_getDefinitionSpellingAndExtent: @convention(c) (_: CXCursor, startBuf: UnsafeMutablePointer<UnsafePointer<Int8>>, endBuf: UnsafeMutablePointer<UnsafePointer<Int8>>, startLine: UnsafeMutablePointer<UInt32>, startColumn: UnsafeMutablePointer<UInt32>, endLine: UnsafeMutablePointer<UInt32>, endColumn: UnsafeMutablePointer<UInt32>) -> () = library.loadSymbol("clang_getDefinitionSpellingAndExtent")

public func clang_enableStackTraces() {
    return _clang_enableStackTraces()
}
private let _clang_enableStackTraces: @convention(c) () -> () = library.loadSymbol("clang_enableStackTraces")

public func clang_executeOnThread(fn: (@convention(c) (UnsafeMutablePointer<Void>) -> Void)!, _ user_data: UnsafeMutablePointer<Void>, _ stack_size: UInt32) {
    return _clang_executeOnThread(fn: fn, user_data: user_data, stack_size: stack_size)
}
private let _clang_executeOnThread: @convention(c) (fn: (@convention(c) (UnsafeMutablePointer<Void>) -> Void)!, user_data: UnsafeMutablePointer<Void>, stack_size: UInt32) -> () = library.loadSymbol("clang_executeOnThread")


/**
 * @}
 */

/**
 * \defgroup CINDEX_CODE_COMPLET Code completion
 *
 * Code completion involves taking an (incomplete) source file, along with
 * knowledge of where the user is actively editing that file, and suggesting
 * syntactically- and semantically-valid constructs that the user might want to
 * use at that particular point in the source code. These data structures and
 * routines provide support for code completion.
 *
 * @{
 */

/**
 * \brief A semantic string that describes a code-completion result.
 *
 * A semantic string that describes the formatting of a code-completion
 * result as a single "template" of text that should be inserted into the
 * source buffer when a particular code-completion result is selected.
 * Each semantic string is made up of some number of "chunks", each of which
 * contains some text along with a description of what that text means, e.g.,
 * the name of the entity being referenced, whether the text chunk is part of
 * the template, or whether it is a "placeholder" that the user should replace
 * with actual code,of a specific kind. See \c CXCompletionChunkKind for a
 * description of the different kinds of chunks.
 */
// public typealias CXCompletionString = UnsafeMutablePointer<Void>

/**
 * \brief A single result of code completion.
 */
/*
public struct CXCompletionResult {
    /**
     * \brief The kind of entity that this completion refers to.
     *
     * The cursor kind will be a macro, keyword, or a declaration (one of the
     * *Decl cursor kinds), describing the entity that the completion is
     * referring to.
     *
     * \todo In the future, we would like to provide a full cursor, to allow
     * the client to extract additional information from declaration.
     */
    public var CursorKind: CXCursorKind
    
    /**
     * \brief The code-completion string that describes how to insert this
     * code-completion result into the editing buffer.
     */
    public var CompletionString: CXCompletionString
    public init()
    public init(CursorKind: CXCursorKind, CompletionString: CXCompletionString)
}
*/

/**
 * \brief Describes a single piece of text within a code-completion string.
 *
 * Each "chunk" within a code-completion string (\c CXCompletionString) is
 * either a piece of text with a specific "kind" that describes how that text
 * should be interpreted by the client or is another completion string.
 */
/*
public struct CXCompletionChunkKind : RawRepresentable, Equatable {
    public init(_ rawValue: UInt32)
    public init(rawValue: UInt32)
    public var rawValue: UInt32
}
*/

/**
 * \brief A code-completion string that describes "optional" text that
 * could be a part of the template (but is not required).
 *
 * The Optional chunk is the only kind of chunk that has a code-completion
 * string for its representation, which is accessible via
 * \c clang_getCompletionChunkCompletionString(). The code-completion string
 * describes an additional part of the template that is completely optional.
 * For example, optional chunks can be used to describe the placeholders for
 * arguments that match up with defaulted function parameters, e.g. given:
 *
 * \code
 * void f(int x, float y = 3.14, double z = 2.71828);
 * \endcode
 *
 * The code-completion string for this function would contain:
 *   - a TypedText chunk for "f".
 *   - a LeftParen chunk for "(".
 *   - a Placeholder chunk for "int x"
 *   - an Optional chunk containing the remaining defaulted arguments, e.g.,
 *       - a Comma chunk for ","
 *       - a Placeholder chunk for "float y"
 *       - an Optional chunk containing the last defaulted argument:
 *           - a Comma chunk for ","
 *           - a Placeholder chunk for "double z"
 *   - a RightParen chunk for ")"
 *
 * There are many ways to handle Optional chunks. Two simple approaches are:
 *   - Completely ignore optional chunks, in which case the template for the
 *     function "f" would only include the first parameter ("int x").
 *   - Fully expand all optional chunks, in which case the template for the
 *     function "f" would have all of the parameters.
 */
// public var CXCompletionChunk_Optional: CXCompletionChunkKind { get }
/**
 * \brief Text that a user would be expected to type to get this
 * code-completion result.
 *
 * There will be exactly one "typed text" chunk in a semantic string, which
 * will typically provide the spelling of a keyword or the name of a
 * declaration that could be used at the current code point. Clients are
 * expected to filter the code-completion results based on the text in this
 * chunk.
 */
// public var CXCompletionChunk_TypedText: CXCompletionChunkKind { get }
/**
 * \brief Text that should be inserted as part of a code-completion result.
 *
 * A "text" chunk represents text that is part of the template to be
 * inserted into user code should this particular code-completion result
 * be selected.
 */
// public var CXCompletionChunk_Text: CXCompletionChunkKind { get }
/**
 * \brief Placeholder text that should be replaced by the user.
 *
 * A "placeholder" chunk marks a place where the user should insert text
 * into the code-completion template. For example, placeholders might mark
 * the function parameters for a function declaration, to indicate that the
 * user should provide arguments for each of those parameters. The actual
 * text in a placeholder is a suggestion for the text to display before
 * the user replaces the placeholder with real code.
 */
// public var CXCompletionChunk_Placeholder: CXCompletionChunkKind { get }
/**
 * \brief Informative text that should be displayed but never inserted as
 * part of the template.
 *
 * An "informative" chunk contains annotations that can be displayed to
 * help the user decide whether a particular code-completion result is the
 * right option, but which is not part of the actual template to be inserted
 * by code completion.
 */
// public var CXCompletionChunk_Informative: CXCompletionChunkKind { get }
/**
 * \brief Text that describes the current parameter when code-completion is
 * referring to function call, message send, or template specialization.
 *
 * A "current parameter" chunk occurs when code-completion is providing
 * information about a parameter corresponding to the argument at the
 * code-completion point. For example, given a function
 *
 * \code
 * int add(int x, int y);
 * \endcode
 *
 * and the source code \c add(, where the code-completion point is after the
 * "(", the code-completion string will contain a "current parameter" chunk
 * for "int x", indicating that the current argument will initialize that
 * parameter. After typing further, to \c add(17, (where the code-completion
 * point is after the ","), the code-completion string will contain a
 * "current paremeter" chunk to "int y".
 */
// public var CXCompletionChunk_CurrentParameter: CXCompletionChunkKind { get }
/**
 * \brief A left parenthesis ('('), used to initiate a function call or
 * signal the beginning of a function parameter list.
 */
// public var CXCompletionChunk_LeftParen: CXCompletionChunkKind { get }
/**
 * \brief A right parenthesis (')'), used to finish a function call or
 * signal the end of a function parameter list.
 */
// public var CXCompletionChunk_RightParen: CXCompletionChunkKind { get }
/**
 * \brief A left bracket ('[').
 */
// public var CXCompletionChunk_LeftBracket: CXCompletionChunkKind { get }
/**
 * \brief A right bracket (']').
 */
// public var CXCompletionChunk_RightBracket: CXCompletionChunkKind { get }
/**
 * \brief A left brace ('{').
 */
// public var CXCompletionChunk_LeftBrace: CXCompletionChunkKind { get }
/**
 * \brief A right brace ('}').
 */
// public var CXCompletionChunk_RightBrace: CXCompletionChunkKind { get }
/**
 * \brief A left angle bracket ('<').
 */
// public var CXCompletionChunk_LeftAngle: CXCompletionChunkKind { get }
/**
 * \brief A right angle bracket ('>').
 */
// public var CXCompletionChunk_RightAngle: CXCompletionChunkKind { get }
/**
 * \brief A comma separator (',').
 */
// public var CXCompletionChunk_Comma: CXCompletionChunkKind { get }
/**
 * \brief Text that specifies the result type of a given result.
 *
 * This special kind of informative chunk is not meant to be inserted into
 * the text buffer. Rather, it is meant to illustrate the type that an
 * expression using the given completion string would have.
 */
// public var CXCompletionChunk_ResultType: CXCompletionChunkKind { get }
/**
 * \brief A colon (':').
 */
// public var CXCompletionChunk_Colon: CXCompletionChunkKind { get }
/**
 * \brief A semicolon (';').
 */
// public var CXCompletionChunk_SemiColon: CXCompletionChunkKind { get }
/**
 * \brief An '=' sign.
 */
// public var CXCompletionChunk_Equal: CXCompletionChunkKind { get }
/**
 * Horizontal space (' ').
 */
// public var CXCompletionChunk_HorizontalSpace: CXCompletionChunkKind { get }
/**
 * Vertical space ('
'), after which it is generally a good idea to
 * perform indentation.
 */
// public var CXCompletionChunk_VerticalSpace: CXCompletionChunkKind { get }

/**
 * \brief Determine the kind of a particular chunk within a completion string.
 *
 * \param completion_string the completion string to query.
 *
 * \param chunk_number the 0-based index of the chunk in the completion string.
 *
 * \returns the kind of the chunk at the index \c chunk_number.
 */
public func clang_getCompletionChunkKind(completion_string: CXCompletionString, _ chunk_number: UInt32) -> CXCompletionChunkKind {
    return _clang_getCompletionChunkKind(completion_string: completion_string, chunk_number: chunk_number)
}
private let _clang_getCompletionChunkKind: @convention(c) (completion_string: CXCompletionString, chunk_number: UInt32) -> CXCompletionChunkKind = library.loadSymbol("clang_getCompletionChunkKind")


/**
 * \brief Retrieve the text associated with a particular chunk within a
 * completion string.
 *
 * \param completion_string the completion string to query.
 *
 * \param chunk_number the 0-based index of the chunk in the completion string.
 *
 * \returns the text associated with the chunk at index \c chunk_number.
 */
public func clang_getCompletionChunkText(completion_string: CXCompletionString, _ chunk_number: UInt32) -> CXString {
    return _clang_getCompletionChunkText(completion_string: completion_string, chunk_number: chunk_number)
}
private let _clang_getCompletionChunkText: @convention(c) (completion_string: CXCompletionString, chunk_number: UInt32) -> CXString = library.loadSymbol("clang_getCompletionChunkText")


/**
 * \brief Retrieve the completion string associated with a particular chunk
 * within a completion string.
 *
 * \param completion_string the completion string to query.
 *
 * \param chunk_number the 0-based index of the chunk in the completion string.
 *
 * \returns the completion string associated with the chunk at index
 * \c chunk_number.
 */
public func clang_getCompletionChunkCompletionString(completion_string: CXCompletionString, _ chunk_number: UInt32) -> CXCompletionString {
    return _clang_getCompletionChunkCompletionString(completion_string: completion_string, chunk_number: chunk_number)
}
private let _clang_getCompletionChunkCompletionString: @convention(c) (completion_string: CXCompletionString, chunk_number: UInt32) -> CXCompletionString = library.loadSymbol("clang_getCompletionChunkCompletionString")


/**
 * \brief Retrieve the number of chunks in the given code-completion string.
 */
public func clang_getNumCompletionChunks(completion_string: CXCompletionString) -> UInt32 {
    return _clang_getNumCompletionChunks(completion_string: completion_string)
}
private let _clang_getNumCompletionChunks: @convention(c) (completion_string: CXCompletionString) -> UInt32 = library.loadSymbol("clang_getNumCompletionChunks")


/**
 * \brief Determine the priority of this code completion.
 *
 * The priority of a code completion indicates how likely it is that this 
 * particular completion is the completion that the user will select. The
 * priority is selected by various internal heuristics.
 *
 * \param completion_string The completion string to query.
 *
 * \returns The priority of this completion string. Smaller values indicate
 * higher-priority (more likely) completions.
 */
public func clang_getCompletionPriority(completion_string: CXCompletionString) -> UInt32 {
    return _clang_getCompletionPriority(completion_string: completion_string)
}
private let _clang_getCompletionPriority: @convention(c) (completion_string: CXCompletionString) -> UInt32 = library.loadSymbol("clang_getCompletionPriority")


/**
 * \brief Determine the availability of the entity that this code-completion
 * string refers to.
 *
 * \param completion_string The completion string to query.
 *
 * \returns The availability of the completion string.
 */
public func clang_getCompletionAvailability(completion_string: CXCompletionString) -> CXAvailabilityKind {
    return _clang_getCompletionAvailability(completion_string: completion_string)
}
private let _clang_getCompletionAvailability: @convention(c) (completion_string: CXCompletionString) -> CXAvailabilityKind = library.loadSymbol("clang_getCompletionAvailability")


/**
 * \brief Retrieve the number of annotations associated with the given
 * completion string.
 *
 * \param completion_string the completion string to query.
 *
 * \returns the number of annotations associated with the given completion
 * string.
 */
public func clang_getCompletionNumAnnotations(completion_string: CXCompletionString) -> UInt32 {
    return _clang_getCompletionNumAnnotations(completion_string: completion_string)
}
private let _clang_getCompletionNumAnnotations: @convention(c) (completion_string: CXCompletionString) -> UInt32 = library.loadSymbol("clang_getCompletionNumAnnotations")


/**
 * \brief Retrieve the annotation associated with the given completion string.
 *
 * \param completion_string the completion string to query.
 *
 * \param annotation_number the 0-based index of the annotation of the
 * completion string.
 *
 * \returns annotation string associated with the completion at index
 * \c annotation_number, or a NULL string if that annotation is not available.
 */
public func clang_getCompletionAnnotation(completion_string: CXCompletionString, _ annotation_number: UInt32) -> CXString {
    return _clang_getCompletionAnnotation(completion_string: completion_string, annotation_number: annotation_number)
}
private let _clang_getCompletionAnnotation: @convention(c) (completion_string: CXCompletionString, annotation_number: UInt32) -> CXString = library.loadSymbol("clang_getCompletionAnnotation")


/**
 * \brief Retrieve the parent context of the given completion string.
 *
 * The parent context of a completion string is the semantic parent of 
 * the declaration (if any) that the code completion represents. For example,
 * a code completion for an Objective-C method would have the method's class
 * or protocol as its context.
 *
 * \param completion_string The code completion string whose parent is
 * being queried.
 *
 * \param kind DEPRECATED: always set to CXCursor_NotImplemented if non-NULL.
 *
 * \returns The name of the completion parent, e.g., "NSObject" if
 * the completion string represents a method in the NSObject class.
 */
public func clang_getCompletionParent(completion_string: CXCompletionString, _ kind: UnsafeMutablePointer<CXCursorKind>) -> CXString {
    return _clang_getCompletionParent(completion_string: completion_string, kind: kind)
}
private let _clang_getCompletionParent: @convention(c) (completion_string: CXCompletionString, kind: UnsafeMutablePointer<CXCursorKind>) -> CXString = library.loadSymbol("clang_getCompletionParent")


/**
 * \brief Retrieve the brief documentation comment attached to the declaration
 * that corresponds to the given completion string.
 */
public func clang_getCompletionBriefComment(completion_string: CXCompletionString) -> CXString {
    return _clang_getCompletionBriefComment(completion_string: completion_string)
}
private let _clang_getCompletionBriefComment: @convention(c) (completion_string: CXCompletionString) -> CXString = library.loadSymbol("clang_getCompletionBriefComment")


/**
 * \brief Retrieve a completion string for an arbitrary declaration or macro
 * definition cursor.
 *
 * \param cursor The cursor to query.
 *
 * \returns A non-context-sensitive completion string for declaration and macro
 * definition cursors, or NULL for other kinds of cursors.
 */
public func clang_getCursorCompletionString(cursor: CXCursor) -> CXCompletionString {
    return _clang_getCursorCompletionString(cursor: cursor)
}
private let _clang_getCursorCompletionString: @convention(c) (cursor: CXCursor) -> CXCompletionString = library.loadSymbol("clang_getCursorCompletionString")


/**
 * \brief Contains the results of code-completion.
 *
 * This data structure contains the results of code completion, as
 * produced by \c clang_codeCompleteAt(). Its contents must be freed by
 * \c clang_disposeCodeCompleteResults.
 */
/*
public struct CXCodeCompleteResults {
    /**
     * \brief The code-completion results.
     */
    public var Results: UnsafeMutablePointer<CXCompletionResult>
    
    /**
     * \brief The number of code-completion results stored in the
     * \c Results array.
     */
    public var NumResults: UInt32
    public init()
    public init(Results: UnsafeMutablePointer<CXCompletionResult>, NumResults: UInt32)
}
*/

/**
 * \brief Flags that can be passed to \c clang_codeCompleteAt() to
 * modify its behavior.
 *
 * The enumerators in this enumeration can be bitwise-OR'd together to
 * provide multiple options to \c clang_codeCompleteAt().
 */
/*
public struct CXCodeComplete_Flags : RawRepresentable, Equatable {
    public init(_ rawValue: UInt32)
    public init(rawValue: UInt32)
    public var rawValue: UInt32
}
*/

/**
 * \brief Whether to include macros within the set of code
 * completions returned.
 */
// public var CXCodeComplete_IncludeMacros: CXCodeComplete_Flags { get }

/**
 * \brief Whether to include code patterns for language constructs
 * within the set of code completions, e.g., for loops.
 */
// public var CXCodeComplete_IncludeCodePatterns: CXCodeComplete_Flags { get }

/**
 * \brief Whether to include brief documentation within the set of code
 * completions returned.
 */
// public var CXCodeComplete_IncludeBriefComments: CXCodeComplete_Flags { get }

/**
 * \brief Bits that represent the context under which completion is occurring.
 *
 * The enumerators in this enumeration may be bitwise-OR'd together if multiple
 * contexts are occurring simultaneously.
 */
/*
public struct CXCompletionContext : RawRepresentable, Equatable {
    public init(_ rawValue: UInt32)
    public init(rawValue: UInt32)
    public var rawValue: UInt32
}
*/

/**
 * \brief The context for completions is unexposed, as only Clang results
 * should be included. (This is equivalent to having no context bits set.)
 */
// public var CXCompletionContext_Unexposed: CXCompletionContext { get }

/**
 * \brief Completions for any possible type should be included in the results.
 */
// public var CXCompletionContext_AnyType: CXCompletionContext { get }

/**
 * \brief Completions for any possible value (variables, function calls, etc.)
 * should be included in the results.
 */
// public var CXCompletionContext_AnyValue: CXCompletionContext { get }
/**
 * \brief Completions for values that resolve to an Objective-C object should
 * be included in the results.
 */
// public var CXCompletionContext_ObjCObjectValue: CXCompletionContext { get }
/**
 * \brief Completions for values that resolve to an Objective-C selector
 * should be included in the results.
 */
// public var CXCompletionContext_ObjCSelectorValue: CXCompletionContext { get }
/**
 * \brief Completions for values that resolve to a C++ class type should be
 * included in the results.
 */
// public var CXCompletionContext_CXXClassTypeValue: CXCompletionContext { get }

/**
 * \brief Completions for fields of the member being accessed using the dot
 * operator should be included in the results.
 */
// public var CXCompletionContext_DotMemberAccess: CXCompletionContext { get }
/**
 * \brief Completions for fields of the member being accessed using the arrow
 * operator should be included in the results.
 */
// public var CXCompletionContext_ArrowMemberAccess: CXCompletionContext { get }
/**
 * \brief Completions for properties of the Objective-C object being accessed
 * using the dot operator should be included in the results.
 */
// public var CXCompletionContext_ObjCPropertyAccess: CXCompletionContext { get }

/**
 * \brief Completions for enum tags should be included in the results.
 */
// public var CXCompletionContext_EnumTag: CXCompletionContext { get }
/**
 * \brief Completions for union tags should be included in the results.
 */
// public var CXCompletionContext_UnionTag: CXCompletionContext { get }
/**
 * \brief Completions for struct tags should be included in the results.
 */
// public var CXCompletionContext_StructTag: CXCompletionContext { get }

/**
 * \brief Completions for C++ class names should be included in the results.
 */
// public var CXCompletionContext_ClassTag: CXCompletionContext { get }
/**
 * \brief Completions for C++ namespaces and namespace aliases should be
 * included in the results.
 */
// public var CXCompletionContext_Namespace: CXCompletionContext { get }
/**
 * \brief Completions for C++ nested name specifiers should be included in
 * the results.
 */
// public var CXCompletionContext_NestedNameSpecifier: CXCompletionContext { get }

/**
 * \brief Completions for Objective-C interfaces (classes) should be included
 * in the results.
 */
// public var CXCompletionContext_ObjCInterface: CXCompletionContext { get }
/**
 * \brief Completions for Objective-C protocols should be included in
 * the results.
 */
// public var CXCompletionContext_ObjCProtocol: CXCompletionContext { get }
/**
 * \brief Completions for Objective-C categories should be included in
 * the results.
 */
// public var CXCompletionContext_ObjCCategory: CXCompletionContext { get }
/**
 * \brief Completions for Objective-C instance messages should be included
 * in the results.
 */
// public var CXCompletionContext_ObjCInstanceMessage: CXCompletionContext { get }
/**
 * \brief Completions for Objective-C class messages should be included in
 * the results.
 */
// public var CXCompletionContext_ObjCClassMessage: CXCompletionContext { get }
/**
 * \brief Completions for Objective-C selector names should be included in
 * the results.
 */
// public var CXCompletionContext_ObjCSelectorName: CXCompletionContext { get }

/**
 * \brief Completions for preprocessor macro names should be included in
 * the results.
 */
// public var CXCompletionContext_MacroName: CXCompletionContext { get }

/**
 * \brief Natural language completions should be included in the results.
 */
// public var CXCompletionContext_NaturalLanguage: CXCompletionContext { get }

/**
 * \brief The current context is unknown, so set all contexts.
 */
// public var CXCompletionContext_Unknown: CXCompletionContext { get }

/**
 * \brief Returns a default set of code-completion options that can be
 * passed to\c clang_codeCompleteAt(). 
 */
public func clang_defaultCodeCompleteOptions() -> UInt32 {
    return _clang_defaultCodeCompleteOptions()
}
private let _clang_defaultCodeCompleteOptions: @convention(c) () -> UInt32 = library.loadSymbol("clang_defaultCodeCompleteOptions")



/**
 * \brief Perform code completion at a given location in a translation unit.
 *
 * This function performs code completion at a particular file, line, and
 * column within source code, providing results that suggest potential
 * code snippets based on the context of the completion. The basic model
 * for code completion is that Clang will parse a complete source file,
 * performing syntax checking up to the location where code-completion has
 * been requested. At that point, a special code-completion token is passed
 * to the parser, which recognizes this token and determines, based on the
 * current location in the C/Objective-C/C++ grammar and the state of
 * semantic analysis, what completions to provide. These completions are
 * returned via a new \c CXCodeCompleteResults structure.
 *
 * Code completion itself is meant to be triggered by the client when the
 * user types punctuation characters or whitespace, at which point the
 * code-completion location will coincide with the cursor. For example, if \c p
 * is a pointer, code-completion might be triggered after the "-" and then
 * after the ">" in \c p->. When the code-completion location is afer the ">",
 * the completion results will provide, e.g., the members of the struct that
 * "p" points to. The client is responsible for placing the cursor at the
 * beginning of the token currently being typed, then filtering the results
 * based on the contents of the token. For example, when code-completing for
 * the expression \c p->get, the client should provide the location just after
 * the ">" (e.g., pointing at the "g") to this code-completion hook. Then, the
 * client can filter the results based on the current token text ("get"), only
 * showing those results that start with "get". The intent of this interface
 * is to separate the relatively high-latency acquisition of code-completion
 * results from the filtering of results on a per-character basis, which must
 * have a lower latency.
 *
 * \param TU The translation unit in which code-completion should
 * occur. The source files for this translation unit need not be
 * completely up-to-date (and the contents of those source files may
 * be overridden via \p unsaved_files). Cursors referring into the
 * translation unit may be invalidated by this invocation.
 *
 * \param complete_filename The name of the source file where code
 * completion should be performed. This filename may be any file
 * included in the translation unit.
 *
 * \param complete_line The line at which code-completion should occur.
 *
 * \param complete_column The column at which code-completion should occur.
 * Note that the column should point just after the syntactic construct that
 * initiated code completion, and not in the middle of a lexical token.
 *
 * \param unsaved_files the Tiles that have not yet been saved to disk
 * but may be required for parsing or code completion, including the
 * contents of those files.  The contents and name of these files (as
 * specified by CXUnsavedFile) are copied when necessary, so the
 * client only needs to guarantee their validity until the call to
 * this function returns.
 *
 * \param num_unsaved_files The number of unsaved file entries in \p
 * unsaved_files.
 *
 * \param options Extra options that control the behavior of code
 * completion, expressed as a bitwise OR of the enumerators of the
 * CXCodeComplete_Flags enumeration. The 
 * \c clang_defaultCodeCompleteOptions() function returns a default set
 * of code-completion options.
 *
 * \returns If successful, a new \c CXCodeCompleteResults structure
 * containing code-completion results, which should eventually be
 * freed with \c clang_disposeCodeCompleteResults(). If code
 * completion fails, returns NULL.
 */
public func clang_codeCompleteAt(TU: CXTranslationUnit, _ complete_filename: UnsafePointer<Int8>, _ complete_line: UInt32, _ complete_column: UInt32, _ unsaved_files: UnsafeMutablePointer<CXUnsavedFile>, _ num_unsaved_files: UInt32, _ options: UInt32) -> UnsafeMutablePointer<CXCodeCompleteResults> {
    return _clang_codeCompleteAt(TU: TU, complete_filename: complete_filename, complete_line: complete_line, complete_column: complete_column, unsaved_files: unsaved_files, num_unsaved_files: num_unsaved_files, options: options)
}
private let _clang_codeCompleteAt: @convention(c) (TU: CXTranslationUnit, complete_filename: UnsafePointer<Int8>, complete_line: UInt32, complete_column: UInt32, unsaved_files: UnsafeMutablePointer<CXUnsavedFile>, num_unsaved_files: UInt32, options: UInt32) -> UnsafeMutablePointer<CXCodeCompleteResults> = library.loadSymbol("clang_codeCompleteAt")



/**
 * \brief Sort the code-completion results in case-insensitive alphabetical 
 * order.
 *
 * \param Results The set of results to sort.
 * \param NumResults The number of results in \p Results.
 */
public func clang_sortCodeCompletionResults(Results: UnsafeMutablePointer<CXCompletionResult>, _ NumResults: UInt32) {
    return _clang_sortCodeCompletionResults(Results: Results, NumResults: NumResults)
}
private let _clang_sortCodeCompletionResults: @convention(c) (Results: UnsafeMutablePointer<CXCompletionResult>, NumResults: UInt32) -> () = library.loadSymbol("clang_sortCodeCompletionResults")



/**
 * \brief Free the given set of code-completion results.
 */
public func clang_disposeCodeCompleteResults(Results: UnsafeMutablePointer<CXCodeCompleteResults>) {
    return _clang_disposeCodeCompleteResults(Results: Results)
}
private let _clang_disposeCodeCompleteResults: @convention(c) (Results: UnsafeMutablePointer<CXCodeCompleteResults>) -> () = library.loadSymbol("clang_disposeCodeCompleteResults")



/**
 * \brief Determine the number of diagnostics produced prior to the
 * location where code completion was performed.
 */
public func clang_codeCompleteGetNumDiagnostics(Results: UnsafeMutablePointer<CXCodeCompleteResults>) -> UInt32 {
    return _clang_codeCompleteGetNumDiagnostics(Results: Results)
}
private let _clang_codeCompleteGetNumDiagnostics: @convention(c) (Results: UnsafeMutablePointer<CXCodeCompleteResults>) -> UInt32 = library.loadSymbol("clang_codeCompleteGetNumDiagnostics")



/**
 * \brief Retrieve a diagnostic associated with the given code completion.
 *
 * \param Results the code completion results to query.
 * \param Index the zero-based diagnostic number to retrieve.
 *
 * \returns the requested diagnostic. This diagnostic must be freed
 * via a call to \c clang_disposeDiagnostic().
 */
public func clang_codeCompleteGetDiagnostic(Results: UnsafeMutablePointer<CXCodeCompleteResults>, _ Index: UInt32) -> CXDiagnostic {
    return _clang_codeCompleteGetDiagnostic(Results: Results, Index: Index)
}
private let _clang_codeCompleteGetDiagnostic: @convention(c) (Results: UnsafeMutablePointer<CXCodeCompleteResults>, Index: UInt32) -> CXDiagnostic = library.loadSymbol("clang_codeCompleteGetDiagnostic")



/**
 * \brief Determines what completions are appropriate for the context
 * the given code completion.
 * 
 * \param Results the code completion results to query
 *
 * \returns the kinds of completions that are appropriate for use
 * along with the given code completion results.
 */
public func clang_codeCompleteGetContexts(Results: UnsafeMutablePointer<CXCodeCompleteResults>) -> UInt64 {
    return _clang_codeCompleteGetContexts(Results: Results)
}
private let _clang_codeCompleteGetContexts: @convention(c) (Results: UnsafeMutablePointer<CXCodeCompleteResults>) -> UInt64 = library.loadSymbol("clang_codeCompleteGetContexts")



/**
 * \brief Returns the cursor kind for the container for the current code
 * completion context. The container is only guaranteed to be set for
 * contexts where a container exists (i.e. member accesses or Objective-C
 * message sends); if there is not a container, this function will return
 * CXCursor_InvalidCode.
 *
 * \param Results the code completion results to query
 *
 * \param IsIncomplete on return, this value will be false if Clang has complete
 * information about the container. If Clang does not have complete
 * information, this value will be true.
 *
 * \returns the container kind, or CXCursor_InvalidCode if there is not a
 * container
 */
public func clang_codeCompleteGetContainerKind(Results: UnsafeMutablePointer<CXCodeCompleteResults>, _ IsIncomplete: UnsafeMutablePointer<UInt32>) -> CXCursorKind {
    return _clang_codeCompleteGetContainerKind(Results: Results, IsIncomplete: IsIncomplete)
}
private let _clang_codeCompleteGetContainerKind: @convention(c) (Results: UnsafeMutablePointer<CXCodeCompleteResults>, IsIncomplete: UnsafeMutablePointer<UInt32>) -> CXCursorKind = library.loadSymbol("clang_codeCompleteGetContainerKind")



/**
 * \brief Returns the USR for the container for the current code completion
 * context. If there is not a container for the current context, this
 * function will return the empty string.
 *
 * \param Results the code completion results to query
 *
 * \returns the USR for the container
 */
public func clang_codeCompleteGetContainerUSR(Results: UnsafeMutablePointer<CXCodeCompleteResults>) -> CXString {
    return _clang_codeCompleteGetContainerUSR(Results: Results)
}
private let _clang_codeCompleteGetContainerUSR: @convention(c) (Results: UnsafeMutablePointer<CXCodeCompleteResults>) -> CXString = library.loadSymbol("clang_codeCompleteGetContainerUSR")



/**
 * \brief Returns the currently-entered selector for an Objective-C message
 * send, formatted like "initWithFoo:bar:". Only guaranteed to return a
 * non-empty string for CXCompletionContext_ObjCInstanceMessage and
 * CXCompletionContext_ObjCClassMessage.
 *
 * \param Results the code completion results to query
 *
 * \returns the selector (or partial selector) that has been entered thus far
 * for an Objective-C message send.
 */
public func clang_codeCompleteGetObjCSelector(Results: UnsafeMutablePointer<CXCodeCompleteResults>) -> CXString {
    return _clang_codeCompleteGetObjCSelector(Results: Results)
}
private let _clang_codeCompleteGetObjCSelector: @convention(c) (Results: UnsafeMutablePointer<CXCodeCompleteResults>) -> CXString = library.loadSymbol("clang_codeCompleteGetObjCSelector")


/**
 * @}
 */

/**
 * \defgroup CINDEX_MISC Miscellaneous utility functions
 *
 * @{
 */

/**
 * \brief Return a version string, suitable for showing to a user, but not
 *        intended to be parsed (the format is not guaranteed to be stable).
 */
public func clang_getClangVersion() -> CXString {
    return _clang_getClangVersion()
}
private let _clang_getClangVersion: @convention(c) () -> CXString = library.loadSymbol("clang_getClangVersion")


/**
 * \brief Enable/disable crash recovery.
 *
 * \param isEnabled Flag to indicate if crash recovery is enabled.  A non-zero
 *        value enables crash recovery, while 0 disables it.
 */
public func clang_toggleCrashRecovery(isEnabled: UInt32) {
    return _clang_toggleCrashRecovery(isEnabled: isEnabled)
}
private let _clang_toggleCrashRecovery: @convention(c) (isEnabled: UInt32) -> () = library.loadSymbol("clang_toggleCrashRecovery")


/**
 * \brief Visitor invoked for each file in a translation unit
 *        (used with clang_getInclusions()).
 *
 * This visitor function will be invoked by clang_getInclusions() for each
 * file included (either at the top-level or by \#include directives) within
 * a translation unit.  The first argument is the file being included, and
 * the second and third arguments provide the inclusion stack.  The
 * array is sorted in order of immediate inclusion.  For example,
 * the first element refers to the location that included 'included_file'.
 */
// public typealias CXInclusionVisitor = @convention(c) (CXFile, UnsafeMutablePointer<CXSourceLocation>, UInt32, CXClientData) -> Void

/**
 * \brief Visit the set of preprocessor inclusions in a translation unit.
 *   The visitor function is called with the provided data for every included
 *   file.  This does not include headers included by the PCH file (unless one
 *   is inspecting the inclusions in the PCH file itself).
 */
public func clang_getInclusions(tu: CXTranslationUnit, _ visitor: CXInclusionVisitor!, _ client_data: CXClientData) {
    return _clang_getInclusions(tu: tu, visitor: visitor, client_data: client_data)
}
private let _clang_getInclusions: @convention(c) (tu: CXTranslationUnit, visitor: CXInclusionVisitor!, client_data: CXClientData) -> () = library.loadSymbol("clang_getInclusions")


/**
 * @}
 */

/** \defgroup CINDEX_REMAPPING Remapping functions
 *
 * @{
 */

/**
 * \brief A remapping of original source files and their translated files.
 */
// public typealias CXRemapping = UnsafeMutablePointer<Void>

/**
 * \brief Retrieve a remapping.
 *
 * \param path the path that contains metadata about remappings.
 *
 * \returns the requested remapping. This remapping must be freed
 * via a call to \c clang_remap_dispose(). Can return NULL if an error occurred.
 */
public func clang_getRemappings(path: UnsafePointer<Int8>) -> CXRemapping {
    return _clang_getRemappings(path: path)
}
private let _clang_getRemappings: @convention(c) (path: UnsafePointer<Int8>) -> CXRemapping = library.loadSymbol("clang_getRemappings")



/**
 * \brief Retrieve a remapping.
 *
 * \param filePaths pointer to an array of file paths containing remapping info.
 *
 * \param numFiles number of file paths.
 *
 * \returns the requested remapping. This remapping must be freed
 * via a call to \c clang_remap_dispose(). Can return NULL if an error occurred.
 */
public func clang_getRemappingsFromFileList(filePaths: UnsafeMutablePointer<UnsafePointer<Int8>>, _ numFiles: UInt32) -> CXRemapping {
    return _clang_getRemappingsFromFileList(filePaths: filePaths, numFiles: numFiles)
}
private let _clang_getRemappingsFromFileList: @convention(c) (filePaths: UnsafeMutablePointer<UnsafePointer<Int8>>, numFiles: UInt32) -> CXRemapping = library.loadSymbol("clang_getRemappingsFromFileList")


/**
 * \brief Determine the number of remappings.
 */
public func clang_remap_getNumFiles(unnamed1: CXRemapping) -> UInt32 {
    return _clang_remap_getNumFiles(unnamed1)
}
private let _clang_remap_getNumFiles: @convention(c) (_: CXRemapping) -> UInt32 = library.loadSymbol("clang_remap_getNumFiles")


/**
 * \brief Get the original and the associated filename from the remapping.
 * 
 * \param original If non-NULL, will be set to the original filename.
 *
 * \param transformed If non-NULL, will be set to the filename that the original
 * is associated with.
 */
public func clang_remap_getFilenames(unnamed1: CXRemapping, _ index: UInt32, _ original: UnsafeMutablePointer<CXString>, _ transformed: UnsafeMutablePointer<CXString>) {
    return _clang_remap_getFilenames(unnamed1, index: index, original: original, transformed: transformed)
}
private let _clang_remap_getFilenames: @convention(c) (_: CXRemapping, index: UInt32, original: UnsafeMutablePointer<CXString>, transformed: UnsafeMutablePointer<CXString>) -> () = library.loadSymbol("clang_remap_getFilenames")


/**
 * \brief Dispose the remapping.
 */
public func clang_remap_dispose(unnamed1: CXRemapping) {
    return _clang_remap_dispose(unnamed1)
}
private let _clang_remap_dispose: @convention(c) (_: CXRemapping) -> () = library.loadSymbol("clang_remap_dispose")


/**
 * @}
 */


/** \defgroup CINDEX_HIGH Higher level API functions
 *
 * @{
 */
/*
public struct CXVisitorResult : RawRepresentable, Equatable {
    public init(_ rawValue: UInt32)
    public init(rawValue: UInt32)
    public var rawValue: UInt32
}
*/
// public var CXVisit_Break: CXVisitorResult { get }
// public var CXVisit_Continue: CXVisitorResult { get }

/*
public struct CXCursorAndRangeVisitor {
    public var context: UnsafeMutablePointer<Void>
    public var visit: (@convention(c) (UnsafeMutablePointer<Void>, CXCursor, CXSourceRange) -> CXVisitorResult)!
    public init()
    public init(context: UnsafeMutablePointer<Void>, visit: (@convention(c) (UnsafeMutablePointer<Void>, CXCursor, CXSourceRange) -> CXVisitorResult)!)
}
*/

/*
public struct CXResult : RawRepresentable, Equatable {
    public init(_ rawValue: UInt32)
    public init(rawValue: UInt32)
    public var rawValue: UInt32
}
*/

/**
 * \brief Function returned successfully.
 */
// public var CXResult_Success: CXResult { get }
/**
 * \brief One of the parameters was invalid for the function.
 */
// public var CXResult_Invalid: CXResult { get }
/**
 * \brief The function was terminated by a callback (e.g. it returned
 * CXVisit_Break)
 */
// public var CXResult_VisitBreak: CXResult { get }

/**
 * \brief Find references of a declaration in a specific file.
 * 
 * \param cursor pointing to a declaration or a reference of one.
 *
 * \param file to search for references.
 *
 * \param visitor callback that will receive pairs of CXCursor/CXSourceRange for
 * each reference found.
 * The CXSourceRange will point inside the file; if the reference is inside
 * a macro (and not a macro argument) the CXSourceRange will be invalid.
 *
 * \returns one of the CXResult enumerators.
 */
public func clang_findReferencesInFile(cursor: CXCursor, _ file: CXFile, _ visitor: CXCursorAndRangeVisitor) -> CXResult {
    return _clang_findReferencesInFile(cursor: cursor, file: file, visitor: visitor)
}
private let _clang_findReferencesInFile: @convention(c) (cursor: CXCursor, file: CXFile, visitor: CXCursorAndRangeVisitor) -> CXResult = library.loadSymbol("clang_findReferencesInFile")


/**
 * \brief Find #import/#include directives in a specific file.
 *
 * \param TU translation unit containing the file to query.
 *
 * \param file to search for #import/#include directives.
 *
 * \param visitor callback that will receive pairs of CXCursor/CXSourceRange for
 * each directive found.
 *
 * \returns one of the CXResult enumerators.
 */
public func clang_findIncludesInFile(TU: CXTranslationUnit, _ file: CXFile, _ visitor: CXCursorAndRangeVisitor) -> CXResult {
    return _clang_findIncludesInFile(TU: TU, file: file, visitor: visitor)
}
private let _clang_findIncludesInFile: @convention(c) (TU: CXTranslationUnit, file: CXFile, visitor: CXCursorAndRangeVisitor) -> CXResult = library.loadSymbol("clang_findIncludesInFile")


// public typealias CXCursorAndRangeVisitorBlock = (CXCursor, CXSourceRange) -> CXVisitorResult

public func clang_findReferencesInFileWithBlock(unnamed1: CXCursor, _ unnamed3: CXFile, _ unnamed2: CXCursorAndRangeVisitorBlock!) -> CXResult {
    return _clang_findReferencesInFileWithBlock(unnamed1, unnamed3, unnamed2)
}
private let _clang_findReferencesInFileWithBlock: @convention(c) (_: CXCursor, _: CXFile, _: CXCursorAndRangeVisitorBlock!) -> CXResult = library.loadSymbol("clang_findReferencesInFileWithBlock")


public func clang_findIncludesInFileWithBlock(unnamed1: CXTranslationUnit, _ unnamed3: CXFile, _ unnamed2: CXCursorAndRangeVisitorBlock!) -> CXResult {
    return _clang_findIncludesInFileWithBlock(unnamed1, unnamed3, unnamed2)
}
private let _clang_findIncludesInFileWithBlock: @convention(c) (_: CXTranslationUnit, _: CXFile, _: CXCursorAndRangeVisitorBlock!) -> CXResult = library.loadSymbol("clang_findIncludesInFileWithBlock")


/**
 * \brief The client's data object that is associated with a CXFile.
 */
// public typealias CXIdxClientFile = UnsafeMutablePointer<Void>

/**
 * \brief The client's data object that is associated with a semantic entity.
 */
// public typealias CXIdxClientEntity = UnsafeMutablePointer<Void>

/**
 * \brief The client's data object that is associated with a semantic container
 * of entities.
 */
// public typealias CXIdxClientContainer = UnsafeMutablePointer<Void>

/**
 * \brief The client's data object that is associated with an AST file (PCH
 * or module).
 */
// public typealias CXIdxClientASTFile = UnsafeMutablePointer<Void>

/**
 * \brief Source location passed to index callbacks.
 */
/*
public struct CXIdxLoc {
    public var ptr_data: (UnsafeMutablePointer<Void>, UnsafeMutablePointer<Void>)
    public var int_data: UInt32
    public init()
    public init(ptr_data: (UnsafeMutablePointer<Void>, UnsafeMutablePointer<Void>), int_data: UInt32)
}
*/

/**
 * \brief Data for ppIncludedFile callback.
 */
/*
public struct CXIdxIncludedFileInfo {
    /**
     * \brief Location of '#' in the \#include/\#import directive.
     */
    public var hashLoc: CXIdxLoc
    /**
     * \brief Filename as written in the \#include/\#import directive.
     */
    public var filename: UnsafePointer<Int8>
    /**
     * \brief The actual file that the \#include/\#import directive resolved to.
     */
    public var file: CXFile
    public var isImport: Int32
    public var isAngled: Int32
    /**
     * \brief Non-zero if the directive was automatically turned into a module
     * import.
     */
    public var isModuleImport: Int32
    public init()
    public init(hashLoc: CXIdxLoc, filename: UnsafePointer<Int8>, file: CXFile, isImport: Int32, isAngled: Int32, isModuleImport: Int32)
}
*/

/**
 * \brief Data for IndexerCallbacks#importedASTFile.
 */
/*
public struct CXIdxImportedASTFileInfo {
    /**
     * \brief Top level AST file containing the imported PCH, module or submodule.
     */
    public var file: CXFile
    /**
     * \brief The imported module or NULL if the AST file is a PCH.
     */
    public var module: CXModule
    /**
     * \brief Location where the file is imported. Applicable only for modules.
     */
    public var loc: CXIdxLoc
    /**
     * \brief Non-zero if an inclusion directive was automatically turned into
     * a module import. Applicable only for modules.
     */
    public var isImplicit: Int32
    public init()
    public init(file: CXFile, module: CXModule, loc: CXIdxLoc, isImplicit: Int32)
}
*/

/*
public struct CXIdxEntityKind : RawRepresentable, Equatable {
    public init(_ rawValue: UInt32)
    public init(rawValue: UInt32)
    public var rawValue: UInt32
}
*/
// public var CXIdxEntity_Unexposed: CXIdxEntityKind { get }
// public var CXIdxEntity_Typedef: CXIdxEntityKind { get }
// public var CXIdxEntity_Function: CXIdxEntityKind { get }
// public var CXIdxEntity_Variable: CXIdxEntityKind { get }
// public var CXIdxEntity_Field: CXIdxEntityKind { get }
// public var CXIdxEntity_EnumConstant: CXIdxEntityKind { get }
// public var CXIdxEntity_ObjCClass: CXIdxEntityKind { get }
// public var CXIdxEntity_ObjCProtocol: CXIdxEntityKind { get }
// public var CXIdxEntity_ObjCCategory: CXIdxEntityKind { get }
// public var CXIdxEntity_ObjCInstanceMethod: CXIdxEntityKind { get }
// public var CXIdxEntity_ObjCClassMethod: CXIdxEntityKind { get }
// public var CXIdxEntity_ObjCProperty: CXIdxEntityKind { get }
// public var CXIdxEntity_ObjCIvar: CXIdxEntityKind { get }
// public var CXIdxEntity_Enum: CXIdxEntityKind { get }
// public var CXIdxEntity_Struct: CXIdxEntityKind { get }
// public var CXIdxEntity_Union: CXIdxEntityKind { get }
// public var CXIdxEntity_CXXClass: CXIdxEntityKind { get }
// public var CXIdxEntity_CXXNamespace: CXIdxEntityKind { get }
// public var CXIdxEntity_CXXNamespaceAlias: CXIdxEntityKind { get }
// public var CXIdxEntity_CXXStaticVariable: CXIdxEntityKind { get }
// public var CXIdxEntity_CXXStaticMethod: CXIdxEntityKind { get }
// public var CXIdxEntity_CXXInstanceMethod: CXIdxEntityKind { get }
// public var CXIdxEntity_CXXConstructor: CXIdxEntityKind { get }
// public var CXIdxEntity_CXXDestructor: CXIdxEntityKind { get }
// public var CXIdxEntity_CXXConversionFunction: CXIdxEntityKind { get }
// public var CXIdxEntity_CXXTypeAlias: CXIdxEntityKind { get }
// public var CXIdxEntity_CXXInterface: CXIdxEntityKind { get }

/*
public struct CXIdxEntityLanguage : RawRepresentable, Equatable {
    public init(_ rawValue: UInt32)
    public init(rawValue: UInt32)
    public var rawValue: UInt32
}
*/
// public var CXIdxEntityLang_None: CXIdxEntityLanguage { get }
// public var CXIdxEntityLang_C: CXIdxEntityLanguage { get }
// public var CXIdxEntityLang_ObjC: CXIdxEntityLanguage { get }
// public var CXIdxEntityLang_CXX: CXIdxEntityLanguage { get }

/**
 * \brief Extra C++ template information for an entity. This can apply to:
 * CXIdxEntity_Function
 * CXIdxEntity_CXXClass
 * CXIdxEntity_CXXStaticMethod
 * CXIdxEntity_CXXInstanceMethod
 * CXIdxEntity_CXXConstructor
 * CXIdxEntity_CXXConversionFunction
 * CXIdxEntity_CXXTypeAlias
 */
/*
public struct CXIdxEntityCXXTemplateKind : RawRepresentable, Equatable {
    public init(_ rawValue: UInt32)
    public init(rawValue: UInt32)
    public var rawValue: UInt32
}
*/
// public var CXIdxEntity_NonTemplate: CXIdxEntityCXXTemplateKind { get }
// public var CXIdxEntity_Template: CXIdxEntityCXXTemplateKind { get }
// public var CXIdxEntity_TemplatePartialSpecialization: CXIdxEntityCXXTemplateKind { get }
// public var CXIdxEntity_TemplateSpecialization: CXIdxEntityCXXTemplateKind { get }

/*
public struct CXIdxAttrKind : RawRepresentable, Equatable {
    public init(_ rawValue: UInt32)
    public init(rawValue: UInt32)
    public var rawValue: UInt32
}
*/
// public var CXIdxAttr_Unexposed: CXIdxAttrKind { get }
// public var CXIdxAttr_IBAction: CXIdxAttrKind { get }
// public var CXIdxAttr_IBOutlet: CXIdxAttrKind { get }
// public var CXIdxAttr_IBOutletCollection: CXIdxAttrKind { get }

/*
public struct CXIdxAttrInfo {
    public var kind: CXIdxAttrKind
    public var cursor: CXCursor
    public var loc: CXIdxLoc
    public init()
    public init(kind: CXIdxAttrKind, cursor: CXCursor, loc: CXIdxLoc)
}
*/

/*
public struct CXIdxEntityInfo {
    public var kind: CXIdxEntityKind
    public var templateKind: CXIdxEntityCXXTemplateKind
    public var lang: CXIdxEntityLanguage
    public var name: UnsafePointer<Int8>
    public var USR: UnsafePointer<Int8>
    public var cursor: CXCursor
    public var attributes: UnsafePointer<UnsafePointer<CXIdxAttrInfo>>
    public var numAttributes: UInt32
    public init()
    public init(kind: CXIdxEntityKind, templateKind: CXIdxEntityCXXTemplateKind, lang: CXIdxEntityLanguage, name: UnsafePointer<Int8>, USR: UnsafePointer<Int8>, cursor: CXCursor, attributes: UnsafePointer<UnsafePointer<CXIdxAttrInfo>>, numAttributes: UInt32)
}
*/

/*
public struct CXIdxContainerInfo {
    public var cursor: CXCursor
    public init()
    public init(cursor: CXCursor)
}
*/

/*
public struct CXIdxIBOutletCollectionAttrInfo {
    public var attrInfo: UnsafePointer<CXIdxAttrInfo>
    public var objcClass: UnsafePointer<CXIdxEntityInfo>
    public var classCursor: CXCursor
    public var classLoc: CXIdxLoc
    public init()
    public init(attrInfo: UnsafePointer<CXIdxAttrInfo>, objcClass: UnsafePointer<CXIdxEntityInfo>, classCursor: CXCursor, classLoc: CXIdxLoc)
}
*/

/*
public struct CXIdxDeclInfoFlags : RawRepresentable, Equatable {
    public init(_ rawValue: UInt32)
    public init(rawValue: UInt32)
    public var rawValue: UInt32
}
*/
// public var CXIdxDeclFlag_Skipped: CXIdxDeclInfoFlags { get }

/*
public struct CXIdxDeclInfo {
    public var entityInfo: UnsafePointer<CXIdxEntityInfo>
    public var cursor: CXCursor
    public var loc: CXIdxLoc
    public var semanticContainer: UnsafePointer<CXIdxContainerInfo>
    /**
     * \brief Generally same as #semanticContainer but can be different in
     * cases like out-of-line C++ member functions.
     */
    public var lexicalContainer: UnsafePointer<CXIdxContainerInfo>
    public var isRedeclaration: Int32
    public var isDefinition: Int32
    public var isContainer: Int32
    public var declAsContainer: UnsafePointer<CXIdxContainerInfo>
    /**
     * \brief Whether the declaration exists in code or was created implicitly
     * by the compiler, e.g. implicit Objective-C methods for properties.
     */
    public var isImplicit: Int32
    public var attributes: UnsafePointer<UnsafePointer<CXIdxAttrInfo>>
    public var numAttributes: UInt32
    
    public var flags: UInt32
    public init()
    public init(entityInfo: UnsafePointer<CXIdxEntityInfo>, cursor: CXCursor, loc: CXIdxLoc, semanticContainer: UnsafePointer<CXIdxContainerInfo>, lexicalContainer: UnsafePointer<CXIdxContainerInfo>, isRedeclaration: Int32, isDefinition: Int32, isContainer: Int32, declAsContainer: UnsafePointer<CXIdxContainerInfo>, isImplicit: Int32, attributes: UnsafePointer<UnsafePointer<CXIdxAttrInfo>>, numAttributes: UInt32, flags: UInt32)
}
*/

/*
public struct CXIdxObjCContainerKind : RawRepresentable, Equatable {
    public init(_ rawValue: UInt32)
    public init(rawValue: UInt32)
    public var rawValue: UInt32
}
*/
// public var CXIdxObjCContainer_ForwardRef: CXIdxObjCContainerKind { get }
// public var CXIdxObjCContainer_Interface: CXIdxObjCContainerKind { get }
// public var CXIdxObjCContainer_Implementation: CXIdxObjCContainerKind { get }

/*
public struct CXIdxObjCContainerDeclInfo {
    public var declInfo: UnsafePointer<CXIdxDeclInfo>
    public var kind: CXIdxObjCContainerKind
    public init()
    public init(declInfo: UnsafePointer<CXIdxDeclInfo>, kind: CXIdxObjCContainerKind)
}
*/

/*
public struct CXIdxBaseClassInfo {
    public var base: UnsafePointer<CXIdxEntityInfo>
    public var cursor: CXCursor
    public var loc: CXIdxLoc
    public init()
    public init(base: UnsafePointer<CXIdxEntityInfo>, cursor: CXCursor, loc: CXIdxLoc)
}
*/

/*
public struct CXIdxObjCProtocolRefInfo {
    public var `protocol`: UnsafePointer<CXIdxEntityInfo>
    public var cursor: CXCursor
    public var loc: CXIdxLoc
    public init()
    public init(`protocol`: UnsafePointer<CXIdxEntityInfo>, cursor: CXCursor, loc: CXIdxLoc)
}
*/

/*
public struct CXIdxObjCProtocolRefListInfo {
    public var protocols: UnsafePointer<UnsafePointer<CXIdxObjCProtocolRefInfo>>
    public var numProtocols: UInt32
    public init()
    public init(protocols: UnsafePointer<UnsafePointer<CXIdxObjCProtocolRefInfo>>, numProtocols: UInt32)
}
*/

/*
public struct CXIdxObjCInterfaceDeclInfo {
    public var containerInfo: UnsafePointer<CXIdxObjCContainerDeclInfo>
    public var superInfo: UnsafePointer<CXIdxBaseClassInfo>
    public var protocols: UnsafePointer<CXIdxObjCProtocolRefListInfo>
    public init()
    public init(containerInfo: UnsafePointer<CXIdxObjCContainerDeclInfo>, superInfo: UnsafePointer<CXIdxBaseClassInfo>, protocols: UnsafePointer<CXIdxObjCProtocolRefListInfo>)
}
*/

/*
public struct CXIdxObjCCategoryDeclInfo {
    public var containerInfo: UnsafePointer<CXIdxObjCContainerDeclInfo>
    public var objcClass: UnsafePointer<CXIdxEntityInfo>
    public var classCursor: CXCursor
    public var classLoc: CXIdxLoc
    public var protocols: UnsafePointer<CXIdxObjCProtocolRefListInfo>
    public init()
    public init(containerInfo: UnsafePointer<CXIdxObjCContainerDeclInfo>, objcClass: UnsafePointer<CXIdxEntityInfo>, classCursor: CXCursor, classLoc: CXIdxLoc, protocols: UnsafePointer<CXIdxObjCProtocolRefListInfo>)
}
*/

/*
public struct CXIdxObjCPropertyDeclInfo {
    public var declInfo: UnsafePointer<CXIdxDeclInfo>
    public var getter: UnsafePointer<CXIdxEntityInfo>
    public var setter: UnsafePointer<CXIdxEntityInfo>
    public init()
    public init(declInfo: UnsafePointer<CXIdxDeclInfo>, getter: UnsafePointer<CXIdxEntityInfo>, setter: UnsafePointer<CXIdxEntityInfo>)
}
*/

/*
public struct CXIdxCXXClassDeclInfo {
    public var declInfo: UnsafePointer<CXIdxDeclInfo>
    public var bases: UnsafePointer<UnsafePointer<CXIdxBaseClassInfo>>
    public var numBases: UInt32
    public init()
    public init(declInfo: UnsafePointer<CXIdxDeclInfo>, bases: UnsafePointer<UnsafePointer<CXIdxBaseClassInfo>>, numBases: UInt32)
}
*/

/**
 * \brief Data for IndexerCallbacks#indexEntityReference.
 */
/*
public struct CXIdxEntityRefKind : RawRepresentable, Equatable {
    public init(_ rawValue: UInt32)
    public init(rawValue: UInt32)
    public var rawValue: UInt32
}
*/

/**
 * \brief The entity is referenced directly in user's code.
 */
// public var CXIdxEntityRef_Direct: CXIdxEntityRefKind { get }
/**
 * \brief An implicit reference, e.g. a reference of an Objective-C method
 * via the dot syntax.
 */
// public var CXIdxEntityRef_Implicit: CXIdxEntityRefKind { get }

/**
 * \brief Data for IndexerCallbacks#indexEntityReference.
 */
/*
public struct CXIdxEntityRefInfo {
    public var kind: CXIdxEntityRefKind
    /**
     * \brief Reference cursor.
     */
    public var cursor: CXCursor
    public var loc: CXIdxLoc
    /**
     * \brief The entity that gets referenced.
     */
    public var referencedEntity: UnsafePointer<CXIdxEntityInfo>
    /**
     * \brief Immediate "parent" of the reference. For example:
     * 
     * \code
     * Foo *var;
     * \endcode
     * 
     * The parent of reference of type 'Foo' is the variable 'var'.
     * For references inside statement bodies of functions/methods,
     * the parentEntity will be the function/method.
     */
    public var parentEntity: UnsafePointer<CXIdxEntityInfo>
    /**
     * \brief Lexical container context of the reference.
     */
    public var container: UnsafePointer<CXIdxContainerInfo>
    public init()
    public init(kind: CXIdxEntityRefKind, cursor: CXCursor, loc: CXIdxLoc, referencedEntity: UnsafePointer<CXIdxEntityInfo>, parentEntity: UnsafePointer<CXIdxEntityInfo>, container: UnsafePointer<CXIdxContainerInfo>)
}
*/

/**
 * \brief A group of callbacks used by #clang_indexSourceFile and
 * #clang_indexTranslationUnit.
 */
/*
public struct IndexerCallbacks {
    /**
     * \brief Called periodically to check whether indexing should be aborted.
     * Should return 0 to continue, and non-zero to abort.
     */
    public var abortQuery: (@convention(c) (CXClientData, UnsafeMutablePointer<Void>) -> Int32)!
    
    /**
     * \brief Called at the end of indexing; passes the complete diagnostic set.
     */
    public var diagnostic: (@convention(c) (CXClientData, CXDiagnosticSet, UnsafeMutablePointer<Void>) -> Void)!
    
    public var enteredMainFile: (@convention(c) (CXClientData, CXFile, UnsafeMutablePointer<Void>) -> CXIdxClientFile)!
    
    /**
     * \brief Called when a file gets \#included/\#imported.
     */
    public var ppIncludedFile: (@convention(c) (CXClientData, UnsafePointer<CXIdxIncludedFileInfo>) -> CXIdxClientFile)!
    
    /**
     * \brief Called when a AST file (PCH or module) gets imported.
     * 
     * AST files will not get indexed (there will not be callbacks to index all
     * the entities in an AST file). The recommended action is that, if the AST
     * file is not already indexed, to initiate a new indexing job specific to
     * the AST file.
     */
    public var importedASTFile: (@convention(c) (CXClientData, UnsafePointer<CXIdxImportedASTFileInfo>) -> CXIdxClientASTFile)!
    
    /**
     * \brief Called at the beginning of indexing a translation unit.
     */
    public var startedTranslationUnit: (@convention(c) (CXClientData, UnsafeMutablePointer<Void>) -> CXIdxClientContainer)!
    
    public var indexDeclaration: (@convention(c) (CXClientData, UnsafePointer<CXIdxDeclInfo>) -> Void)!
    
    /**
     * \brief Called to index a reference of an entity.
     */
    public var indexEntityReference: (@convention(c) (CXClientData, UnsafePointer<CXIdxEntityRefInfo>) -> Void)!
    public init()
    public init(abortQuery: (@convention(c) (CXClientData, UnsafeMutablePointer<Void>) -> Int32)!, diagnostic: (@convention(c) (CXClientData, CXDiagnosticSet, UnsafeMutablePointer<Void>) -> Void)!, enteredMainFile: (@convention(c) (CXClientData, CXFile, UnsafeMutablePointer<Void>) -> CXIdxClientFile)!, ppIncludedFile: (@convention(c) (CXClientData, UnsafePointer<CXIdxIncludedFileInfo>) -> CXIdxClientFile)!, importedASTFile: (@convention(c) (CXClientData, UnsafePointer<CXIdxImportedASTFileInfo>) -> CXIdxClientASTFile)!, startedTranslationUnit: (@convention(c) (CXClientData, UnsafeMutablePointer<Void>) -> CXIdxClientContainer)!, indexDeclaration: (@convention(c) (CXClientData, UnsafePointer<CXIdxDeclInfo>) -> Void)!, indexEntityReference: (@convention(c) (CXClientData, UnsafePointer<CXIdxEntityRefInfo>) -> Void)!)
}
*/

public func clang_index_isEntityObjCContainerKind(unnamed1: CXIdxEntityKind) -> Int32 {
    return _clang_index_isEntityObjCContainerKind(unnamed1)
}
private let _clang_index_isEntityObjCContainerKind: @convention(c) (_: CXIdxEntityKind) -> Int32 = library.loadSymbol("clang_index_isEntityObjCContainerKind")

public func clang_index_getObjCContainerDeclInfo(unnamed1: UnsafePointer<CXIdxDeclInfo>) -> UnsafePointer<CXIdxObjCContainerDeclInfo> {
    return _clang_index_getObjCContainerDeclInfo(unnamed1)
}
private let _clang_index_getObjCContainerDeclInfo: @convention(c) (_: UnsafePointer<CXIdxDeclInfo>) -> UnsafePointer<CXIdxObjCContainerDeclInfo> = library.loadSymbol("clang_index_getObjCContainerDeclInfo")


public func clang_index_getObjCInterfaceDeclInfo(unnamed1: UnsafePointer<CXIdxDeclInfo>) -> UnsafePointer<CXIdxObjCInterfaceDeclInfo> {
    return _clang_index_getObjCInterfaceDeclInfo(unnamed1)
}
private let _clang_index_getObjCInterfaceDeclInfo: @convention(c) (_: UnsafePointer<CXIdxDeclInfo>) -> UnsafePointer<CXIdxObjCInterfaceDeclInfo> = library.loadSymbol("clang_index_getObjCInterfaceDeclInfo")


public func clang_index_getObjCCategoryDeclInfo(unnamed1: UnsafePointer<CXIdxDeclInfo>) -> UnsafePointer<CXIdxObjCCategoryDeclInfo> {
    return _clang_index_getObjCCategoryDeclInfo(unnamed1)
}
private let _clang_index_getObjCCategoryDeclInfo: @convention(c) (_: UnsafePointer<CXIdxDeclInfo>) -> UnsafePointer<CXIdxObjCCategoryDeclInfo> = library.loadSymbol("clang_index_getObjCCategoryDeclInfo")


public func clang_index_getObjCProtocolRefListInfo(unnamed1: UnsafePointer<CXIdxDeclInfo>) -> UnsafePointer<CXIdxObjCProtocolRefListInfo> {
    return _clang_index_getObjCProtocolRefListInfo(unnamed1)
}
private let _clang_index_getObjCProtocolRefListInfo: @convention(c) (_: UnsafePointer<CXIdxDeclInfo>) -> UnsafePointer<CXIdxObjCProtocolRefListInfo> = library.loadSymbol("clang_index_getObjCProtocolRefListInfo")


public func clang_index_getObjCPropertyDeclInfo(unnamed1: UnsafePointer<CXIdxDeclInfo>) -> UnsafePointer<CXIdxObjCPropertyDeclInfo> {
    return _clang_index_getObjCPropertyDeclInfo(unnamed1)
}
private let _clang_index_getObjCPropertyDeclInfo: @convention(c) (_: UnsafePointer<CXIdxDeclInfo>) -> UnsafePointer<CXIdxObjCPropertyDeclInfo> = library.loadSymbol("clang_index_getObjCPropertyDeclInfo")


public func clang_index_getIBOutletCollectionAttrInfo(unnamed1: UnsafePointer<CXIdxAttrInfo>) -> UnsafePointer<CXIdxIBOutletCollectionAttrInfo> {
    return _clang_index_getIBOutletCollectionAttrInfo(unnamed1)
}
private let _clang_index_getIBOutletCollectionAttrInfo: @convention(c) (_: UnsafePointer<CXIdxAttrInfo>) -> UnsafePointer<CXIdxIBOutletCollectionAttrInfo> = library.loadSymbol("clang_index_getIBOutletCollectionAttrInfo")


public func clang_index_getCXXClassDeclInfo(unnamed1: UnsafePointer<CXIdxDeclInfo>) -> UnsafePointer<CXIdxCXXClassDeclInfo> {
    return _clang_index_getCXXClassDeclInfo(unnamed1)
}
private let _clang_index_getCXXClassDeclInfo: @convention(c) (_: UnsafePointer<CXIdxDeclInfo>) -> UnsafePointer<CXIdxCXXClassDeclInfo> = library.loadSymbol("clang_index_getCXXClassDeclInfo")


/**
 * \brief For retrieving a custom CXIdxClientContainer attached to a
 * container.
 */
public func clang_index_getClientContainer(unnamed1: UnsafePointer<CXIdxContainerInfo>) -> CXIdxClientContainer {
    return _clang_index_getClientContainer(unnamed1)
}
private let _clang_index_getClientContainer: @convention(c) (_: UnsafePointer<CXIdxContainerInfo>) -> CXIdxClientContainer = library.loadSymbol("clang_index_getClientContainer")


/**
 * \brief For setting a custom CXIdxClientContainer attached to a
 * container.
 */
public func clang_index_setClientContainer(unnamed1: UnsafePointer<CXIdxContainerInfo>, _ unnamed2: CXIdxClientContainer) {
    return _clang_index_setClientContainer(unnamed1, unnamed2)
}
private let _clang_index_setClientContainer: @convention(c) (_: UnsafePointer<CXIdxContainerInfo>, _: CXIdxClientContainer) -> () = library.loadSymbol("clang_index_setClientContainer")


/**
 * \brief For retrieving a custom CXIdxClientEntity attached to an entity.
 */
public func clang_index_getClientEntity(unnamed1: UnsafePointer<CXIdxEntityInfo>) -> CXIdxClientEntity {
    return _clang_index_getClientEntity(unnamed1)
}
private let _clang_index_getClientEntity: @convention(c) (_: UnsafePointer<CXIdxEntityInfo>) -> CXIdxClientEntity = library.loadSymbol("clang_index_getClientEntity")


/**
 * \brief For setting a custom CXIdxClientEntity attached to an entity.
 */
public func clang_index_setClientEntity(unnamed1: UnsafePointer<CXIdxEntityInfo>, _ unnamed2: CXIdxClientEntity) {
    return _clang_index_setClientEntity(unnamed1, unnamed2)
}
private let _clang_index_setClientEntity: @convention(c) (_: UnsafePointer<CXIdxEntityInfo>, _: CXIdxClientEntity) -> () = library.loadSymbol("clang_index_setClientEntity")


/**
 * \brief An indexing action/session, to be applied to one or multiple
 * translation units.
 */
// public typealias CXIndexAction = UnsafeMutablePointer<Void>

/**
 * \brief An indexing action/session, to be applied to one or multiple
 * translation units.
 *
 * \param CIdx The index object with which the index action will be associated.
 */
public func clang_IndexAction_create(CIdx: CXIndex) -> CXIndexAction {
    return _clang_IndexAction_create(CIdx: CIdx)
}
private let _clang_IndexAction_create: @convention(c) (CIdx: CXIndex) -> CXIndexAction = library.loadSymbol("clang_IndexAction_create")


/**
 * \brief Destroy the given index action.
 *
 * The index action must not be destroyed until all of the translation units
 * created within that index action have been destroyed.
 */
public func clang_IndexAction_dispose(unnamed1: CXIndexAction) {
    return _clang_IndexAction_dispose(unnamed1)
}
private let _clang_IndexAction_dispose: @convention(c) (_: CXIndexAction) -> () = library.loadSymbol("clang_IndexAction_dispose")


/*
public struct CXIndexOptFlags : RawRepresentable, Equatable {
    public init(_ rawValue: UInt32)
    public init(rawValue: UInt32)
    public var rawValue: UInt32
}
*/

/**
 * \brief Used to indicate that no special indexing options are needed.
 */
// public var CXIndexOpt_None: CXIndexOptFlags { get }

/**
 * \brief Used to indicate that IndexerCallbacks#indexEntityReference should
 * be invoked for only one reference of an entity per source file that does
 * not also include a declaration/definition of the entity.
 */
// public var CXIndexOpt_SuppressRedundantRefs: CXIndexOptFlags { get }

/**
 * \brief Function-local symbols should be indexed. If this is not set
 * function-local symbols will be ignored.
 */
// public var CXIndexOpt_IndexFunctionLocalSymbols: CXIndexOptFlags { get }

/**
 * \brief Implicit function/class template instantiations should be indexed.
 * If this is not set, implicit instantiations will be ignored.
 */
// public var CXIndexOpt_IndexImplicitTemplateInstantiations: CXIndexOptFlags { get }

/**
 * \brief Suppress all compiler warnings when parsing for indexing.
 */
// public var CXIndexOpt_SuppressWarnings: CXIndexOptFlags { get }

/**
 * \brief Skip a function/method body that was already parsed during an
 * indexing session associated with a \c CXIndexAction object.
 * Bodies in system headers are always skipped.
 */
// public var CXIndexOpt_SkipParsedBodiesInSession: CXIndexOptFlags { get }

/**
 * \brief Index the given source file and the translation unit corresponding
 * to that file via callbacks implemented through #IndexerCallbacks.
 *
 * \param client_data pointer data supplied by the client, which will
 * be passed to the invoked callbacks.
 *
 * \param index_callbacks Pointer to indexing callbacks that the client
 * implements.
 *
 * \param index_callbacks_size Size of #IndexerCallbacks structure that gets
 * passed in index_callbacks.
 *
 * \param index_options A bitmask of options that affects how indexing is
 * performed. This should be a bitwise OR of the CXIndexOpt_XXX flags.
 *
 * \param[out] out_TU pointer to store a \c CXTranslationUnit that can be
 * reused after indexing is finished. Set to \c NULL if you do not require it.
 *
 * \returns 0 on success or if there were errors from which the compiler could
 * recover.  If there is a failure from which there is no recovery, returns
 * a non-zero \c CXErrorCode.
 *
 * The rest of the parameters are the same as #clang_parseTranslationUnit.
 */
public func clang_indexSourceFile(unnamed1: CXIndexAction, _ client_data: CXClientData, _ index_callbacks: UnsafeMutablePointer<IndexerCallbacks>, _ index_callbacks_size: UInt32, _ index_options: UInt32, _ source_filename: UnsafePointer<Int8>, _ command_line_args: UnsafePointer<UnsafePointer<Int8>>, _ num_command_line_args: Int32, _ unsaved_files: UnsafeMutablePointer<CXUnsavedFile>, _ num_unsaved_files: UInt32, _ out_TU: UnsafeMutablePointer<CXTranslationUnit>, _ TU_options: UInt32) -> Int32 {
    return _clang_indexSourceFile(unnamed1, client_data: client_data, index_callbacks: index_callbacks, index_callbacks_size: index_callbacks_size, index_options: index_options, source_filename: source_filename, command_line_args: command_line_args, num_command_line_args: num_command_line_args, unsaved_files: unsaved_files, num_unsaved_files: num_unsaved_files, out_TU: out_TU, TU_options: TU_options)
}
private let _clang_indexSourceFile: @convention(c) (_: CXIndexAction, client_data: CXClientData, index_callbacks: UnsafeMutablePointer<IndexerCallbacks>, index_callbacks_size: UInt32, index_options: UInt32, source_filename: UnsafePointer<Int8>, command_line_args: UnsafePointer<UnsafePointer<Int8>>, num_command_line_args: Int32, unsaved_files: UnsafeMutablePointer<CXUnsavedFile>, num_unsaved_files: UInt32, out_TU: UnsafeMutablePointer<CXTranslationUnit>, TU_options: UInt32) -> Int32 = library.loadSymbol("clang_indexSourceFile")


/**
 * \brief Index the given translation unit via callbacks implemented through
 * #IndexerCallbacks.
 * 
 * The order of callback invocations is not guaranteed to be the same as
 * when indexing a source file. The high level order will be:
 * 
 *   -Preprocessor callbacks invocations
 *   -Declaration/reference callbacks invocations
 *   -Diagnostic callback invocations
 *
 * The parameters are the same as #clang_indexSourceFile.
 * 
 * \returns If there is a failure from which there is no recovery, returns
 * non-zero, otherwise returns 0.
 */
public func clang_indexTranslationUnit(unnamed1: CXIndexAction, _ client_data: CXClientData, _ index_callbacks: UnsafeMutablePointer<IndexerCallbacks>, _ index_callbacks_size: UInt32, _ index_options: UInt32, _ unnamed2: CXTranslationUnit) -> Int32 {
    return _clang_indexTranslationUnit(unnamed1, client_data: client_data, index_callbacks: index_callbacks, index_callbacks_size: index_callbacks_size, index_options: index_options, unnamed2)
}
private let _clang_indexTranslationUnit: @convention(c) (_: CXIndexAction, client_data: CXClientData, index_callbacks: UnsafeMutablePointer<IndexerCallbacks>, index_callbacks_size: UInt32, index_options: UInt32, _: CXTranslationUnit) -> Int32 = library.loadSymbol("clang_indexTranslationUnit")


/**
 * \brief Retrieve the CXIdxFile, file, line, column, and offset represented by
 * the given CXIdxLoc.
 *
 * If the location refers into a macro expansion, retrieves the
 * location of the macro expansion and if it refers into a macro argument
 * retrieves the location of the argument.
 */
public func clang_indexLoc_getFileLocation(loc: CXIdxLoc, _ indexFile: UnsafeMutablePointer<CXIdxClientFile>, _ file: UnsafeMutablePointer<CXFile>, _ line: UnsafeMutablePointer<UInt32>, _ column: UnsafeMutablePointer<UInt32>, _ offset: UnsafeMutablePointer<UInt32>) {
    return _clang_indexLoc_getFileLocation(loc: loc, indexFile: indexFile, file: file, line: line, column: column, offset: offset)
}
private let _clang_indexLoc_getFileLocation: @convention(c) (loc: CXIdxLoc, indexFile: UnsafeMutablePointer<CXIdxClientFile>, file: UnsafeMutablePointer<CXFile>, line: UnsafeMutablePointer<UInt32>, column: UnsafeMutablePointer<UInt32>, offset: UnsafeMutablePointer<UInt32>) -> () = library.loadSymbol("clang_indexLoc_getFileLocation")



/**
 * \brief Retrieve the CXSourceLocation represented by the given CXIdxLoc.
 */
public func clang_indexLoc_getCXSourceLocation(loc: CXIdxLoc) -> CXSourceLocation {
    return _clang_indexLoc_getCXSourceLocation(loc: loc)
}
private let _clang_indexLoc_getCXSourceLocation: @convention(c) (loc: CXIdxLoc) -> CXSourceLocation = library.loadSymbol("clang_indexLoc_getCXSourceLocation")


/**
 * \brief Visitor invoked for each field found by a traversal.
 *
 * This visitor function will be invoked for each field found by
 * \c clang_Type_visitFields. Its first argument is the cursor being
 * visited, its second argument is the client data provided to
 * \c clang_Type_visitFields.
 *
 * The visitor should return one of the \c CXVisitorResult values
 * to direct \c clang_Type_visitFields.
 */
// public typealias CXFieldVisitor = @convention(c) (CXCursor, CXClientData) -> CXVisitorResult

/**
 * \brief Visit the fields of a particular type.
 *
 * This function visits all the direct fields of the given cursor,
 * invoking the given \p visitor function with the cursors of each
 * visited field. The traversal may be ended prematurely, if
 * the visitor returns \c CXFieldVisit_Break.
 *
 * \param T the record type whose field may be visited.
 *
 * \param visitor the visitor function that will be invoked for each
 * field of \p T.
 *
 * \param client_data pointer data supplied by the client, which will
 * be passed to the visitor each time it is invoked.
 *
 * \returns a non-zero value if the traversal was terminated
 * prematurely by the visitor returning \c CXFieldVisit_Break.
 */
public func clang_Type_visitFields(T: CXType, _ visitor: CXFieldVisitor!, _ client_data: CXClientData) -> UInt32 {
    return _clang_Type_visitFields(T: T, visitor: visitor, client_data: client_data)
}
private let _clang_Type_visitFields: @convention(c) (T: CXType, visitor: CXFieldVisitor!, client_data: CXClientData) -> UInt32 = library.loadSymbol("clang_Type_visitFields")


