// this file is generated by `convert_generated_interface_to_wrapper.py`
#if SWIFT_PACKAGE
import Clang_C
#endif
private let library = toolchainLoader.load("libclang.dylib")
// swiftlint:disable file_length
// swiftlint:disable force_unwrapping
// swiftlint:disable function_parameter_count
// swiftlint:disable missing_docs
// swiftlint:disable trailing_newline
// swiftlint:disable variable_name
// swiftlint:disable valid_docs

/*==-- clang-c/Documentation.h - Utilities for comment processing -*- C -*-===*\
|*                                                                            *|
|*                     The LLVM Compiler Infrastructure                       *|
|*                                                                            *|
|* This file is distributed under the University of Illinois Open Source      *|
|* License. See LICENSE.TXT for details.                                      *|
|*                                                                            *|
|*===----------------------------------------------------------------------===*|
|*                                                                            *|
|* This header provides a supplementary interface for inspecting              *|
|* documentation comments.                                                    *|
|*                                                                            *|
\*===----------------------------------------------------------------------===*/

/**
 * \defgroup CINDEX_COMMENT Comment introspection
 *
 * The routines in this group provide access to information in documentation
 * comments. These facilities are distinct from the core and may be subject to
 * their own schedule of stability and deprecation.
 *
 * @{
 */

/**
 * \brief A parsed comment.
 */
/*
public struct CXComment {
    public var ASTNode: UnsafePointer<Void>
    public var TranslationUnit: CXTranslationUnit
    public init()
    public init(ASTNode: UnsafePointer<Void>, TranslationUnit: CXTranslationUnit)
}
*/

/**
 * \brief Given a cursor that represents a documentable entity (e.g.,
 * declaration), return the associated parsed comment as a
 * \c CXComment_FullComment AST node.
 */
public func clang_Cursor_getParsedComment(C: CXCursor) -> CXComment {
    return _clang_Cursor_getParsedComment(C: C)
}
private let _clang_Cursor_getParsedComment: @convention(c) (C: CXCursor) -> CXComment = library.loadSymbol("clang_Cursor_getParsedComment")


/**
 * \brief Describes the type of the comment AST node (\c CXComment).  A comment
 * node can be considered block content (e. g., paragraph), inline content
 * (plain text) or neither (the root AST node).
 */
/*
public struct CXCommentKind : RawRepresentable, Equatable {
    public init(_ rawValue: UInt32)
    public init(rawValue: UInt32)
    public var rawValue: UInt32
}
*/

/**
 * \brief Null comment.  No AST node is constructed at the requested location
 * because there is no text or a syntax error.
 */
// public var CXComment_Null: CXCommentKind { get }

/**
 * \brief Plain text.  Inline content.
 */
// public var CXComment_Text: CXCommentKind { get }

/**
 * \brief A command with word-like arguments that is considered inline content.
 *
 * For example: \\c command.
 */
// public var CXComment_InlineCommand: CXCommentKind { get }

/**
 * \brief HTML start tag with attributes (name-value pairs).  Considered
 * inline content.
 *
 * For example:
 * \verbatim
 * <br> <br /> <a href="http://example.org/">
 * \endverbatim
 */
// public var CXComment_HTMLStartTag: CXCommentKind { get }

/**
 * \brief HTML end tag.  Considered inline content.
 *
 * For example:
 * \verbatim
 * </a>
 * \endverbatim
 */
// public var CXComment_HTMLEndTag: CXCommentKind { get }

/**
 * \brief A paragraph, contains inline comment.  The paragraph itself is
 * block content.
 */
// public var CXComment_Paragraph: CXCommentKind { get }

/**
 * \brief A command that has zero or more word-like arguments (number of
 * word-like arguments depends on command name) and a paragraph as an
 * argument.  Block command is block content.
 *
 * Paragraph argument is also a child of the block command.
 *
 * For example: \\brief has 0 word-like arguments and a paragraph argument.
 *
 * AST nodes of special kinds that parser knows about (e. g., \\param
 * command) have their own node kinds.
 */
// public var CXComment_BlockCommand: CXCommentKind { get }

/**
 * \brief A \\param or \\arg command that describes the function parameter
 * (name, passing direction, description).
 *
 * For example: \\param [in] ParamName description.
 */
// public var CXComment_ParamCommand: CXCommentKind { get }

/**
 * \brief A \\tparam command that describes a template parameter (name and
 * description).
 *
 * For example: \\tparam T description.
 */
// public var CXComment_TParamCommand: CXCommentKind { get }

/**
 * \brief A verbatim block command (e. g., preformatted code).  Verbatim
 * block has an opening and a closing command and contains multiple lines of
 * text (\c CXComment_VerbatimBlockLine child nodes).
 *
 * For example:
 * \\verbatim
 * aaa
 * \\endverbatim
 */
// public var CXComment_VerbatimBlockCommand: CXCommentKind { get }

/**
 * \brief A line of text that is contained within a
 * CXComment_VerbatimBlockCommand node.
 */
// public var CXComment_VerbatimBlockLine: CXCommentKind { get }

/**
 * \brief A verbatim line command.  Verbatim line has an opening command,
 * a single line of text (up to the newline after the opening command) and
 * has no closing command.
 */
// public var CXComment_VerbatimLine: CXCommentKind { get }

/**
 * \brief A full comment attached to a declaration, contains block content.
 */
// public var CXComment_FullComment: CXCommentKind { get }

/**
 * \brief The most appropriate rendering mode for an inline command, chosen on
 * command semantics in Doxygen.
 */
/*
public struct CXCommentInlineCommandRenderKind : RawRepresentable, Equatable {
    public init(_ rawValue: UInt32)
    public init(rawValue: UInt32)
    public var rawValue: UInt32
}
*/

/**
 * \brief Command argument should be rendered in a normal font.
 */
// public var CXCommentInlineCommandRenderKind_Normal: CXCommentInlineCommandRenderKind { get }

/**
 * \brief Command argument should be rendered in a bold font.
 */
// public var CXCommentInlineCommandRenderKind_Bold: CXCommentInlineCommandRenderKind { get }

/**
 * \brief Command argument should be rendered in a monospaced font.
 */
// public var CXCommentInlineCommandRenderKind_Monospaced: CXCommentInlineCommandRenderKind { get }

/**
 * \brief Command argument should be rendered emphasized (typically italic
 * font).
 */
// public var CXCommentInlineCommandRenderKind_Emphasized: CXCommentInlineCommandRenderKind { get }

/**
 * \brief Describes parameter passing direction for \\param or \\arg command.
 */
/*
public struct CXCommentParamPassDirection : RawRepresentable, Equatable {
    public init(_ rawValue: UInt32)
    public init(rawValue: UInt32)
    public var rawValue: UInt32
}
*/

/**
 * \brief The parameter is an input parameter.
 */
// public var CXCommentParamPassDirection_In: CXCommentParamPassDirection { get }

/**
 * \brief The parameter is an output parameter.
 */
// public var CXCommentParamPassDirection_Out: CXCommentParamPassDirection { get }

/**
 * \brief The parameter is an input and output parameter.
 */
// public var CXCommentParamPassDirection_InOut: CXCommentParamPassDirection { get }

/**
 * \param Comment AST node of any kind.
 *
 * \returns the type of the AST node.
 */
public func clang_Comment_getKind(Comment: CXComment) -> CXCommentKind {
    return _clang_Comment_getKind(Comment: Comment)
}
private let _clang_Comment_getKind: @convention(c) (Comment: CXComment) -> CXCommentKind = library.loadSymbol("clang_Comment_getKind")


/**
 * \param Comment AST node of any kind.
 *
 * \returns number of children of the AST node.
 */
public func clang_Comment_getNumChildren(Comment: CXComment) -> UInt32 {
    return _clang_Comment_getNumChildren(Comment: Comment)
}
private let _clang_Comment_getNumChildren: @convention(c) (Comment: CXComment) -> UInt32 = library.loadSymbol("clang_Comment_getNumChildren")



/**
 * \param Comment AST node of any kind.
 *
 * \param ChildIdx child index (zero-based).
 *
 * \returns the specified child of the AST node.
 */
public func clang_Comment_getChild(Comment: CXComment, _ ChildIdx: UInt32) -> CXComment {
    return _clang_Comment_getChild(Comment: Comment, ChildIdx: ChildIdx)
}
private let _clang_Comment_getChild: @convention(c) (Comment: CXComment, ChildIdx: UInt32) -> CXComment = library.loadSymbol("clang_Comment_getChild")


/**
 * \brief A \c CXComment_Paragraph node is considered whitespace if it contains
 * only \c CXComment_Text nodes that are empty or whitespace.
 *
 * Other AST nodes (except \c CXComment_Paragraph and \c CXComment_Text) are
 * never considered whitespace.
 *
 * \returns non-zero if \c Comment is whitespace.
 */
public func clang_Comment_isWhitespace(Comment: CXComment) -> UInt32 {
    return _clang_Comment_isWhitespace(Comment: Comment)
}
private let _clang_Comment_isWhitespace: @convention(c) (Comment: CXComment) -> UInt32 = library.loadSymbol("clang_Comment_isWhitespace")



/**
 * \returns non-zero if \c Comment is inline content and has a newline
 * immediately following it in the comment text.  Newlines between paragraphs
 * do not count.
 */
public func clang_InlineContentComment_hasTrailingNewline(Comment: CXComment) -> UInt32 {
    return _clang_InlineContentComment_hasTrailingNewline(Comment: Comment)
}
private let _clang_InlineContentComment_hasTrailingNewline: @convention(c) (Comment: CXComment) -> UInt32 = library.loadSymbol("clang_InlineContentComment_hasTrailingNewline")


/**
 * \param Comment a \c CXComment_Text AST node.
 *
 * \returns text contained in the AST node.
 */
public func clang_TextComment_getText(Comment: CXComment) -> CXString {
    return _clang_TextComment_getText(Comment: Comment)
}
private let _clang_TextComment_getText: @convention(c) (Comment: CXComment) -> CXString = library.loadSymbol("clang_TextComment_getText")



/**
 * \param Comment a \c CXComment_InlineCommand AST node.
 *
 * \returns name of the inline command.
 */
public func clang_InlineCommandComment_getCommandName(Comment: CXComment) -> CXString {
    return _clang_InlineCommandComment_getCommandName(Comment: Comment)
}
private let _clang_InlineCommandComment_getCommandName: @convention(c) (Comment: CXComment) -> CXString = library.loadSymbol("clang_InlineCommandComment_getCommandName")


/**
 * \param Comment a \c CXComment_InlineCommand AST node.
 *
 * \returns the most appropriate rendering mode, chosen on command
 * semantics in Doxygen.
 */
public func clang_InlineCommandComment_getRenderKind(Comment: CXComment) -> CXCommentInlineCommandRenderKind {
    return _clang_InlineCommandComment_getRenderKind(Comment: Comment)
}
private let _clang_InlineCommandComment_getRenderKind: @convention(c) (Comment: CXComment) -> CXCommentInlineCommandRenderKind = library.loadSymbol("clang_InlineCommandComment_getRenderKind")



/**
 * \param Comment a \c CXComment_InlineCommand AST node.
 *
 * \returns number of command arguments.
 */
public func clang_InlineCommandComment_getNumArgs(Comment: CXComment) -> UInt32 {
    return _clang_InlineCommandComment_getNumArgs(Comment: Comment)
}
private let _clang_InlineCommandComment_getNumArgs: @convention(c) (Comment: CXComment) -> UInt32 = library.loadSymbol("clang_InlineCommandComment_getNumArgs")



/**
 * \param Comment a \c CXComment_InlineCommand AST node.
 *
 * \param ArgIdx argument index (zero-based).
 *
 * \returns text of the specified argument.
 */
public func clang_InlineCommandComment_getArgText(Comment: CXComment, _ ArgIdx: UInt32) -> CXString {
    return _clang_InlineCommandComment_getArgText(Comment: Comment, ArgIdx: ArgIdx)
}
private let _clang_InlineCommandComment_getArgText: @convention(c) (Comment: CXComment, ArgIdx: UInt32) -> CXString = library.loadSymbol("clang_InlineCommandComment_getArgText")


/**
 * \param Comment a \c CXComment_HTMLStartTag or \c CXComment_HTMLEndTag AST
 * node.
 *
 * \returns HTML tag name.
 */
public func clang_HTMLTagComment_getTagName(Comment: CXComment) -> CXString {
    return _clang_HTMLTagComment_getTagName(Comment: Comment)
}
private let _clang_HTMLTagComment_getTagName: @convention(c) (Comment: CXComment) -> CXString = library.loadSymbol("clang_HTMLTagComment_getTagName")



/**
 * \param Comment a \c CXComment_HTMLStartTag AST node.
 *
 * \returns non-zero if tag is self-closing (for example, &lt;br /&gt;).
 */
public func clang_HTMLStartTagComment_isSelfClosing(Comment: CXComment) -> UInt32 {
    return _clang_HTMLStartTagComment_isSelfClosing(Comment: Comment)
}
private let _clang_HTMLStartTagComment_isSelfClosing: @convention(c) (Comment: CXComment) -> UInt32 = library.loadSymbol("clang_HTMLStartTagComment_isSelfClosing")


/**
 * \param Comment a \c CXComment_HTMLStartTag AST node.
 *
 * \returns number of attributes (name-value pairs) attached to the start tag.
 */
public func clang_HTMLStartTag_getNumAttrs(Comment: CXComment) -> UInt32 {
    return _clang_HTMLStartTag_getNumAttrs(Comment: Comment)
}
private let _clang_HTMLStartTag_getNumAttrs: @convention(c) (Comment: CXComment) -> UInt32 = library.loadSymbol("clang_HTMLStartTag_getNumAttrs")



/**
 * \param Comment a \c CXComment_HTMLStartTag AST node.
 *
 * \param AttrIdx attribute index (zero-based).
 *
 * \returns name of the specified attribute.
 */
public func clang_HTMLStartTag_getAttrName(Comment: CXComment, _ AttrIdx: UInt32) -> CXString {
    return _clang_HTMLStartTag_getAttrName(Comment: Comment, AttrIdx: AttrIdx)
}
private let _clang_HTMLStartTag_getAttrName: @convention(c) (Comment: CXComment, AttrIdx: UInt32) -> CXString = library.loadSymbol("clang_HTMLStartTag_getAttrName")



/**
 * \param Comment a \c CXComment_HTMLStartTag AST node.
 *
 * \param AttrIdx attribute index (zero-based).
 *
 * \returns value of the specified attribute.
 */
public func clang_HTMLStartTag_getAttrValue(Comment: CXComment, _ AttrIdx: UInt32) -> CXString {
    return _clang_HTMLStartTag_getAttrValue(Comment: Comment, AttrIdx: AttrIdx)
}
private let _clang_HTMLStartTag_getAttrValue: @convention(c) (Comment: CXComment, AttrIdx: UInt32) -> CXString = library.loadSymbol("clang_HTMLStartTag_getAttrValue")



/**
 * \param Comment a \c CXComment_BlockCommand AST node.
 *
 * \returns name of the block command.
 */
public func clang_BlockCommandComment_getCommandName(Comment: CXComment) -> CXString {
    return _clang_BlockCommandComment_getCommandName(Comment: Comment)
}
private let _clang_BlockCommandComment_getCommandName: @convention(c) (Comment: CXComment) -> CXString = library.loadSymbol("clang_BlockCommandComment_getCommandName")



/**
 * \param Comment a \c CXComment_BlockCommand AST node.
 *
 * \returns number of word-like arguments.
 */
public func clang_BlockCommandComment_getNumArgs(Comment: CXComment) -> UInt32 {
    return _clang_BlockCommandComment_getNumArgs(Comment: Comment)
}
private let _clang_BlockCommandComment_getNumArgs: @convention(c) (Comment: CXComment) -> UInt32 = library.loadSymbol("clang_BlockCommandComment_getNumArgs")



/**
 * \param Comment a \c CXComment_BlockCommand AST node.
 *
 * \param ArgIdx argument index (zero-based).
 *
 * \returns text of the specified word-like argument.
 */
public func clang_BlockCommandComment_getArgText(Comment: CXComment, _ ArgIdx: UInt32) -> CXString {
    return _clang_BlockCommandComment_getArgText(Comment: Comment, ArgIdx: ArgIdx)
}
private let _clang_BlockCommandComment_getArgText: @convention(c) (Comment: CXComment, ArgIdx: UInt32) -> CXString = library.loadSymbol("clang_BlockCommandComment_getArgText")



/**
 * \param Comment a \c CXComment_BlockCommand or
 * \c CXComment_VerbatimBlockCommand AST node.
 *
 * \returns paragraph argument of the block command.
 */
public func clang_BlockCommandComment_getParagraph(Comment: CXComment) -> CXComment {
    return _clang_BlockCommandComment_getParagraph(Comment: Comment)
}
private let _clang_BlockCommandComment_getParagraph: @convention(c) (Comment: CXComment) -> CXComment = library.loadSymbol("clang_BlockCommandComment_getParagraph")



/**
 * \param Comment a \c CXComment_ParamCommand AST node.
 *
 * \returns parameter name.
 */
public func clang_ParamCommandComment_getParamName(Comment: CXComment) -> CXString {
    return _clang_ParamCommandComment_getParamName(Comment: Comment)
}
private let _clang_ParamCommandComment_getParamName: @convention(c) (Comment: CXComment) -> CXString = library.loadSymbol("clang_ParamCommandComment_getParamName")



/**
 * \param Comment a \c CXComment_ParamCommand AST node.
 *
 * \returns non-zero if the parameter that this AST node represents was found
 * in the function prototype and \c clang_ParamCommandComment_getParamIndex
 * function will return a meaningful value.
 */
public func clang_ParamCommandComment_isParamIndexValid(Comment: CXComment) -> UInt32 {
    return _clang_ParamCommandComment_isParamIndexValid(Comment: Comment)
}
private let _clang_ParamCommandComment_isParamIndexValid: @convention(c) (Comment: CXComment) -> UInt32 = library.loadSymbol("clang_ParamCommandComment_isParamIndexValid")



/**
 * \param Comment a \c CXComment_ParamCommand AST node.
 *
 * \returns zero-based parameter index in function prototype.
 */
public func clang_ParamCommandComment_getParamIndex(Comment: CXComment) -> UInt32 {
    return _clang_ParamCommandComment_getParamIndex(Comment: Comment)
}
private let _clang_ParamCommandComment_getParamIndex: @convention(c) (Comment: CXComment) -> UInt32 = library.loadSymbol("clang_ParamCommandComment_getParamIndex")



/**
 * \param Comment a \c CXComment_ParamCommand AST node.
 *
 * \returns non-zero if parameter passing direction was specified explicitly in
 * the comment.
 */
public func clang_ParamCommandComment_isDirectionExplicit(Comment: CXComment) -> UInt32 {
    return _clang_ParamCommandComment_isDirectionExplicit(Comment: Comment)
}
private let _clang_ParamCommandComment_isDirectionExplicit: @convention(c) (Comment: CXComment) -> UInt32 = library.loadSymbol("clang_ParamCommandComment_isDirectionExplicit")



/**
 * \param Comment a \c CXComment_ParamCommand AST node.
 *
 * \returns parameter passing direction.
 */
public func clang_ParamCommandComment_getDirection(Comment: CXComment) -> CXCommentParamPassDirection {
    return _clang_ParamCommandComment_getDirection(Comment: Comment)
}
private let _clang_ParamCommandComment_getDirection: @convention(c) (Comment: CXComment) -> CXCommentParamPassDirection = library.loadSymbol("clang_ParamCommandComment_getDirection")



/**
 * \param Comment a \c CXComment_TParamCommand AST node.
 *
 * \returns template parameter name.
 */
public func clang_TParamCommandComment_getParamName(Comment: CXComment) -> CXString {
    return _clang_TParamCommandComment_getParamName(Comment: Comment)
}
private let _clang_TParamCommandComment_getParamName: @convention(c) (Comment: CXComment) -> CXString = library.loadSymbol("clang_TParamCommandComment_getParamName")



/**
 * \param Comment a \c CXComment_TParamCommand AST node.
 *
 * \returns non-zero if the parameter that this AST node represents was found
 * in the template parameter list and
 * \c clang_TParamCommandComment_getDepth and
 * \c clang_TParamCommandComment_getIndex functions will return a meaningful
 * value.
 */
public func clang_TParamCommandComment_isParamPositionValid(Comment: CXComment) -> UInt32 {
    return _clang_TParamCommandComment_isParamPositionValid(Comment: Comment)
}
private let _clang_TParamCommandComment_isParamPositionValid: @convention(c) (Comment: CXComment) -> UInt32 = library.loadSymbol("clang_TParamCommandComment_isParamPositionValid")



/**
 * \param Comment a \c CXComment_TParamCommand AST node.
 *
 * \returns zero-based nesting depth of this parameter in the template parameter list.
 *
 * For example,
 * \verbatim
 *     template<typename C, template<typename T> class TT>
 *     void test(TT<int> aaa);
 * \endverbatim
 * for C and TT nesting depth is 0,
 * for T nesting depth is 1.
 */
public func clang_TParamCommandComment_getDepth(Comment: CXComment) -> UInt32 {
    return _clang_TParamCommandComment_getDepth(Comment: Comment)
}
private let _clang_TParamCommandComment_getDepth: @convention(c) (Comment: CXComment) -> UInt32 = library.loadSymbol("clang_TParamCommandComment_getDepth")



/**
 * \param Comment a \c CXComment_TParamCommand AST node.
 *
 * \returns zero-based parameter index in the template parameter list at a
 * given nesting depth.
 *
 * For example,
 * \verbatim
 *     template<typename C, template<typename T> class TT>
 *     void test(TT<int> aaa);
 * \endverbatim
 * for C and TT nesting depth is 0, so we can ask for index at depth 0:
 * at depth 0 C's index is 0, TT's index is 1.
 *
 * For T nesting depth is 1, so we can ask for index at depth 0 and 1:
 * at depth 0 T's index is 1 (same as TT's),
 * at depth 1 T's index is 0.
 */
public func clang_TParamCommandComment_getIndex(Comment: CXComment, _ Depth: UInt32) -> UInt32 {
    return _clang_TParamCommandComment_getIndex(Comment: Comment, Depth: Depth)
}
private let _clang_TParamCommandComment_getIndex: @convention(c) (Comment: CXComment, Depth: UInt32) -> UInt32 = library.loadSymbol("clang_TParamCommandComment_getIndex")



/**
 * \param Comment a \c CXComment_VerbatimBlockLine AST node.
 *
 * \returns text contained in the AST node.
 */
public func clang_VerbatimBlockLineComment_getText(Comment: CXComment) -> CXString {
    return _clang_VerbatimBlockLineComment_getText(Comment: Comment)
}
private let _clang_VerbatimBlockLineComment_getText: @convention(c) (Comment: CXComment) -> CXString = library.loadSymbol("clang_VerbatimBlockLineComment_getText")


/**
 * \param Comment a \c CXComment_VerbatimLine AST node.
 *
 * \returns text contained in the AST node.
 */
public func clang_VerbatimLineComment_getText(Comment: CXComment) -> CXString {
    return _clang_VerbatimLineComment_getText(Comment: Comment)
}
private let _clang_VerbatimLineComment_getText: @convention(c) (Comment: CXComment) -> CXString = library.loadSymbol("clang_VerbatimLineComment_getText")


/**
 * \brief Convert an HTML tag AST node to string.
 *
 * \param Comment a \c CXComment_HTMLStartTag or \c CXComment_HTMLEndTag AST
 * node.
 *
 * \returns string containing an HTML tag.
 */
public func clang_HTMLTagComment_getAsString(Comment: CXComment) -> CXString {
    return _clang_HTMLTagComment_getAsString(Comment: Comment)
}
private let _clang_HTMLTagComment_getAsString: @convention(c) (Comment: CXComment) -> CXString = library.loadSymbol("clang_HTMLTagComment_getAsString")


/**
 * \brief Convert a given full parsed comment to an HTML fragment.
 *
 * Specific details of HTML layout are subject to change.  Don't try to parse
 * this HTML back into an AST, use other APIs instead.
 *
 * Currently the following CSS classes are used:
 * \li "para-brief" for \\brief paragraph and equivalent commands;
 * \li "para-returns" for \\returns paragraph and equivalent commands;
 * \li "word-returns" for the "Returns" word in \\returns paragraph.
 *
 * Function argument documentation is rendered as a \<dl\> list with arguments
 * sorted in function prototype order.  CSS classes used:
 * \li "param-name-index-NUMBER" for parameter name (\<dt\>);
 * \li "param-descr-index-NUMBER" for parameter description (\<dd\>);
 * \li "param-name-index-invalid" and "param-descr-index-invalid" are used if
 * parameter index is invalid.
 *
 * Template parameter documentation is rendered as a \<dl\> list with
 * parameters sorted in template parameter list order.  CSS classes used:
 * \li "tparam-name-index-NUMBER" for parameter name (\<dt\>);
 * \li "tparam-descr-index-NUMBER" for parameter description (\<dd\>);
 * \li "tparam-name-index-other" and "tparam-descr-index-other" are used for
 * names inside template template parameters;
 * \li "tparam-name-index-invalid" and "tparam-descr-index-invalid" are used if
 * parameter position is invalid.
 *
 * \param Comment a \c CXComment_FullComment AST node.
 *
 * \returns string containing an HTML fragment.
 */
public func clang_FullComment_getAsHTML(Comment: CXComment) -> CXString {
    return _clang_FullComment_getAsHTML(Comment: Comment)
}
private let _clang_FullComment_getAsHTML: @convention(c) (Comment: CXComment) -> CXString = library.loadSymbol("clang_FullComment_getAsHTML")


/**
 * \brief Convert a given full parsed comment to an XML document.
 *
 * A Relax NG schema for the XML can be found in comment-xml-schema.rng file
 * inside clang source tree.
 *
 * \param Comment a \c CXComment_FullComment AST node.
 *
 * \returns string containing an XML document.
 */
public func clang_FullComment_getAsXML(Comment: CXComment) -> CXString {
    return _clang_FullComment_getAsXML(Comment: Comment)
}
private let _clang_FullComment_getAsXML: @convention(c) (Comment: CXComment) -> CXString = library.loadSymbol("clang_FullComment_getAsXML")


